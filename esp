--[[
    TrisESP - Pure API ESP System
    
    No UI - Controlled entirely via getgenv().TrisESP
    
    Load via: loadstring(game:HttpGet("YOUR_URL_HERE"))()
    
    Quick Start:
        getgenv().TrisESP.Settings.Enabled = true
        getgenv().TrisESP.Settings.Boxes = true
        getgenv().TrisESP.TrackObjectsByName("Diamond")
    
    See bottom of file for full API documentation.
--]]

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local renderConn

local ESPObjects = {}
local RainbowHue = 0

local ESPSettings = {
    Enabled = true,
    MaxDistance = 1500,
    TextSize = 14,
    
    -- Filtering settings
    FilterMode = "All", -- "All", "Whitelist", "Blacklist"
    WhitelistedPlayers = {}, -- Player names to show when FilterMode = "Whitelist"
    BlacklistedPlayers = {}, -- Player names to hide when FilterMode = "Blacklist"
    -- Extended whitelist/blacklist that can store Instances (folders, models) or tables
    WhitelistedEntities = {}, -- keys can be Instances or nested tables
    BlacklistedEntities = {},
    
    -- Team ESP settings
    -- When TeamCheckEnabled = true, teammates are automatically hidden (no separate toggle)
    TeamCheckEnabled = false, -- When enabled, auto-hides teammates
    TeamDetectionMode = "Auto", -- "Auto", "RobloxTeams", "Folder", "Custom"
    CustomTeamFolder = nil, -- Folder instance for folder-based teams
    CustomTeamFunction = nil, -- Custom function(player1, player2) -> boolean (same team?)
    
    -- Modular text entries (easy to add more)
    TextEntries = {
        Name = { Enabled = true, Order = 1 },
        Health = { Enabled = true, Order = 2 },
        Distance = { Enabled = true, Order = 3 },
        -- Add more here: Weapon = { Enabled = false, Order = 4 }, etc.
    },
    
    -- Equipped tool display
    EquippedEnabled = false,
    EquippedMode = "Text", -- "Text" or "Image"
    EquippedPosition = "Inline", -- "Inline" or "Bottom"
    EquippedImage = "", -- image data or asset id for image mode
    
    -- Legacy compatibility
    ShowName = true,
    ShowHealthText = true,
    ShowDistance = true,
    NamePosition = "Top",
    HealthTextPosition = "Top",
    DistancePosition = "Top",
    -- Individual rainbow toggles for text elements
    NameRainbow = false,
    HealthTextRainbow = false,
    DistanceRainbow = false,
    
    -- Rainbow settings (per element)
    RainbowSpeed = 1,
    
    -- Custom gradient colors for rainbow (instead of HSV rainbow)
    -- Global toggle: when true, use per-element custom 3-color gradients
    UseCustomGradient = false,
    -- Global fallback 3 colors
    CustomGradientColor1 = Color3.fromRGB(255, 0, 0),
    CustomGradientColor2 = Color3.fromRGB(255, 165, 0),
    CustomGradientColor3 = Color3.fromRGB(0, 0, 255),
    -- Per-element custom 3-color sets (Boxes, Tracers, HealthBar, Chams, Name, FOV, Objects)
    BoxCustomColor1 = Color3.fromRGB(255, 0, 0), BoxCustomColor2 = Color3.fromRGB(255, 165, 0), BoxCustomColor3 = Color3.fromRGB(0, 0, 255),
    BoxFillCustomColor1 = Color3.fromRGB(255, 0, 0), BoxFillCustomColor2 = Color3.fromRGB(255, 165, 0), BoxFillCustomColor3 = Color3.fromRGB(0, 0, 255),
    TracerCustomColor1 = Color3.fromRGB(255, 0, 0), TracerCustomColor2 = Color3.fromRGB(255, 165, 0), TracerCustomColor3 = Color3.fromRGB(0, 0, 255),
    HealthBarCustomColor1 = Color3.fromRGB(255, 0, 0), HealthBarCustomColor2 = Color3.fromRGB(255, 165, 0), HealthBarCustomColor3 = Color3.fromRGB(0, 0, 255),
    ChamsCustomColor1 = Color3.fromRGB(255, 0, 0), ChamsCustomColor2 = Color3.fromRGB(255, 165, 0), ChamsCustomColor3 = Color3.fromRGB(0, 0, 255),
    NameCustomColor1 = Color3.fromRGB(255, 0, 0), NameCustomColor2 = Color3.fromRGB(255, 165, 0), NameCustomColor3 = Color3.fromRGB(0, 0, 255),
    FOVCustomColor1 = Color3.fromRGB(255, 0, 0), FOVCustomColor2 = Color3.fromRGB(255, 165, 0), FOVCustomColor3 = Color3.fromRGB(0, 0, 255),
    ObjectCustomColor1 = Color3.fromRGB(255, 0, 0), ObjectCustomColor2 = Color3.fromRGB(255, 165, 0), ObjectCustomColor3 = Color3.fromRGB(0, 0, 255),

    -- Text-specific custom gradients (for Name/Health/Distance separate gradients)
    HealthTextCustomColor1 = Color3.fromRGB(255, 255, 255), HealthTextCustomColor2 = Color3.fromRGB(255, 255, 255), HealthTextCustomColor3 = Color3.fromRGB(255, 255, 255),
    DistanceCustomColor1 = Color3.fromRGB(255, 255, 255), DistanceCustomColor2 = Color3.fromRGB(255, 255, 255), DistanceCustomColor3 = Color3.fromRGB(255, 255, 255),
    
    -- FOV Circle settings
    FOVCircleEnabled = false,
    FOVCircleRadius = 100,
    FOVCircleColor = Color3.fromRGB(255, 255, 255),
    FOVCircleThickness = 1,
    FOVCircleTransparency = 0,
    FOVCircleRainbow = false,
    FOVCircleFilled = false,
    FOVCircleFillColor = Color3.fromRGB(255, 255, 255),
    FOVCircleFillTransparency = 0.8,
    FOVCircleFillRainbow = false,
    FOVCircleSegments = 128,
    
    -- Box settings
    Boxes = true,
    BoxType = "Square",
    BoxColor = Color3.fromRGB(0, 170, 255),
    BoxRainbow = false,
    Thickness = 3,
    BoxOutlineColor = Color3.new(0, 0, 0),
    
    -- Box fill settings
    BoxFill = false,
    BoxFillColor = Color3.fromRGB(0, 170, 255),
    BoxFillTransparency = 0.5,
    BoxFillRainbow = false,
    
    -- Tracer settings
    Tracers = false,
    TracerFrom = "Bottom",
    TracerThickness = 2,
    TracerColor = Color3.fromRGB(0, 170, 255),
    TracerRainbow = false,
    
    -- Health bar settings
    HealthBarEnabled = true,
    HealthBarPosition = "Left",
    HealthBarThickness = 3,
    HealthBarOutline = true,
    HealthBarOutlineColor = Color3.new(0, 0, 0),
    HealthBarRainbow = false,
    
    -- Chams settings
    Highlight = true,
    GlobalChamColor = Color3.fromRGB(0, 170, 255),
    FillTransparency = 0.5,
    OutlineTransparency = 0,
    ChamDepthMode = "AlwaysOnTop",
    ChamsRainbow = false,
    
    -- Name settings
    NameRainbow = false,
    NameColor = Color3.fromRGB(255, 255, 255)
}

-- Object ESP configurations (for non-players)
local ObjectESPConfigs = {}

local AllowedParts = {
    Head = true, HumanoidRootPart = true,
    Torso = true, ["Left Arm"] = true, ["Right Arm"] = true, ["Left Leg"] = true, ["Right Leg"] = true,
    UpperTorso = true, LowerTorso = true,
    LeftUpperArm = true, LeftLowerArm = true, LeftHand = true,
    RightUpperArm = true, RightLowerArm = true, RightHand = true,
    LeftUpperLeg = true, LeftLowerLeg = true, LeftFoot = true,
    RightUpperLeg = true, RightLowerLeg = true, RightFoot = true
}

-- Utility functions
local function getRainbowColor(offset, element)
    offset = offset or 0
    element = element or ""

    -- Use per-element 3-color gradient (stops always = 3)
    local stops = 3

    local function pickColorsForElement(el)
        if el == "Box" then
            return {ESPSettings.BoxCustomColor1, ESPSettings.BoxCustomColor2, ESPSettings.BoxCustomColor3}
        elseif el == "BoxFill" then
            return {ESPSettings.BoxFillCustomColor1, ESPSettings.BoxFillCustomColor2, ESPSettings.BoxFillCustomColor3}
        elseif el == "Tracer" then
            return {ESPSettings.TracerCustomColor1, ESPSettings.TracerCustomColor2, ESPSettings.TracerCustomColor3}
        elseif el == "HealthBar" then
            return {ESPSettings.HealthBarCustomColor1, ESPSettings.HealthBarCustomColor2, ESPSettings.HealthBarCustomColor3}
        elseif el == "HealthText" or el == "Health" then
            return {ESPSettings.HealthTextCustomColor1, ESPSettings.HealthTextCustomColor2, ESPSettings.HealthTextCustomColor3}
        elseif el == "Chams" then
            return {ESPSettings.ChamsCustomColor1, ESPSettings.ChamsCustomColor2, ESPSettings.ChamsCustomColor3}
        elseif el == "Name" then
            return {ESPSettings.NameCustomColor1, ESPSettings.NameCustomColor2, ESPSettings.NameCustomColor3}
        elseif el == "FOV" then
            return {ESPSettings.FOVCustomColor1, ESPSettings.FOVCustomColor2, ESPSettings.FOVCustomColor3}
        elseif el == "Distance" then
            return {ESPSettings.DistanceCustomColor1, ESPSettings.DistanceCustomColor2, ESPSettings.DistanceCustomColor3}
        elseif el == "Object" then
            return {ESPSettings.ObjectCustomColor1, ESPSettings.ObjectCustomColor2, ESPSettings.ObjectCustomColor3}
        else
            return {ESPSettings.CustomGradientColor1, ESPSettings.CustomGradientColor2, ESPSettings.CustomGradientColor3}
        end
    end

    local colors = pickColorsForElement(element)

    -- Use absolute time + offset for smooth animation through stops
    local t = ((RainbowHue + offset) % 1) * stops
    local idx = math.floor(t) % stops
    local frac = t - math.floor(t)

    local c1 = colors[idx + 1]
    local c2 = colors[(idx + 1) % stops + 1]

    -- Smoothstep interpolation for cleaner blending
    frac = frac * frac * (3 - 2 * frac)

    return Color3.new(
        c1.R + (c2.R - c1.R) * frac,
        c1.G + (c2.G - c1.G) * frac,
        c1.B + (c2.B - c1.B) * frac
    )
end

-- Get custom gradient color (for non-rainbow gradients with custom colors)
local function getCustomGradientColor(t, color1, color2)
    t = math.clamp(t, 0, 1)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local function lerpColor(c1, c2, t)
    t = math.clamp(t, 0, 1)
    return Color3.new(
        c1.R + (c2.R - c1.R) * t,
        c1.G + (c2.G - c1.G) * t,
        c1.B + (c2.B - c1.B) * t
    )
end

local function getHealthColor(ratio)
    if ratio > 0.5 then
        return lerpColor(Color3.fromRGB(255, 255, 0), Color3.fromRGB(0, 255, 0), (ratio - 0.5) * 2)
    else
        return lerpColor(Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 255, 0), ratio * 2)
    end
end

local function isSameTeam(player1, player2)
    if not player1 or not player2 or player1 == player2 then return false end
    
    local mode = ESPSettings.TeamDetectionMode
    
    -- Custom function takes priority
    if mode == "Custom" and ESPSettings.CustomTeamFunction then
        return ESPSettings.CustomTeamFunction(player1, player2)
    end
    
    -- Folder-based teams
    if mode == "Folder" and ESPSettings.CustomTeamFolder then
        local folder = ESPSettings.CustomTeamFolder
        if folder and folder:IsA("Folder") then
            local char1 = player1.Character
            local char2 = player2.Character
            if char1 and char2 then
                -- Check if both characters are in the same child folder
                for _, teamFolder in ipairs(folder:GetChildren()) do
                    if teamFolder:IsA("Folder") then
                        local has1 = teamFolder:IsAncestorOf(char1)
                        local has2 = teamFolder:IsAncestorOf(char2)
                        if has1 and has2 then return true end
                    end
                end
            end
        end
        return false
    end
    
    -- Roblox built-in Teams or Auto mode
    if mode == "RobloxTeams" or mode == "Auto" then
        if player1.Team and player2.Team then
            return player1.Team == player2.Team
        end
    end
    
    return false
end

local function shouldShowPlayer(player)
    if not player or player == LocalPlayer then return false end
    
    -- Team check - when enabled, automatically hide teammates
    if ESPSettings.TeamCheckEnabled then
        if isSameTeam(player, LocalPlayer) then
            return false -- Hide teammates
        end
    end
    
    local function matchesEntityList(list)
        -- list contains keys that may be strings or Instances
        if not list then return false end
        -- name match
        if list[player.Name] then return true end
        -- instance matches (folders/models/players)
        for ent, _ in pairs(list) do
            if typeof(ent) == "Instance" then
                -- direct player instance
                if ent:IsA("Player") and ent == player then return true end
                -- character/model/folder containment: check if player's character is descendant
                if player.Character and ent:IsAncestorOf(player.Character) then return true end
            end
        end
        return false
    end

    local filterMode = ESPSettings.FilterMode
    if filterMode == "Whitelist" then
        -- whitelist must explicitly match by name or instance/folder
        if matchesEntityList(ESPSettings.WhitelistedPlayers) then return true end
        if matchesEntityList(ESPSettings.WhitelistedEntities) then return true end
        return false
    elseif filterMode == "Blacklist" then
        -- blacklist hides any match
        if matchesEntityList(ESPSettings.BlacklistedPlayers) then return false end
        if matchesEntityList(ESPSettings.BlacklistedEntities) then return false end
        return true
    end
    return true -- "All" mode
end

local function getScreenRectForCharacter(char)
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local any = false
    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") and AllowedParts[part.Name] then
            local sx, sy, sz = part.Size.X/2, part.Size.Y/2, part.Size.Z/2
            local corners = {
                Vector3.new( sx,  sy,  sz), Vector3.new(-sx,  sy,  sz),
                Vector3.new( sx, -sy,  sz), Vector3.new(-sx, -sy,  sz),
                Vector3.new( sx,  sy, -sz), Vector3.new(-sx,  sy, -sz),
                Vector3.new( sx, -sy, -sz), Vector3.new(-sx, -sy, -sz),
            }
            for _, off in ipairs(corners) do
                local worldPos = (part.CFrame * CFrame.new(off)).Position
                local sp = Camera:WorldToViewportPoint(worldPos)
                if sp.Z > 0 and sp.X >= 0 and sp.X <= vw and sp.Y >= 0 and sp.Y <= vh then
                    any = true
                    minX = math.min(minX, sp.X)
                    maxX = math.max(maxX, sp.X)
                    minY = math.min(minY, sp.Y)
                    maxY = math.max(maxY, sp.Y)
                end

                
            end
        end
    end
    if not any or minX == math.huge then return end
    local w = math.max(1, (maxX - minX))
    local h = math.max(1, (maxY - minY))
    
    -- Only filter out extreme edge cases, not valid close-up boxes
    if w < 2 or h < 2 then return end
    if w > vw * 0.95 or h > vh * 0.95 then return end
    
    local aspect = h / math.max(1, w)
    if aspect > 6.0 or aspect < 0.1 then return end
    return { x = minX, y = minY, w = w, h = h, cx = (minX + maxX)/2, cy = (minY + maxY)/2 }
end

local function getFallbackRect(char)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local head = char:FindFirstChild("Head")
    if not hrp or not head then return end
    local hrpPos = Camera:WorldToViewportPoint(hrp.Position)
    local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
    if hrpPos.Z <= 0 or headPos.Z <= 0 then return end
    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    if hrpPos.X < 0 or hrpPos.X > vw or headPos.X < 0 or headPos.X > vw then return end
    if hrpPos.Y < 0 or hrpPos.Y > vh or headPos.Y < 0 or headPos.Y > vh then return end
    local topY = math.min(headPos.Y, hrpPos.Y) - 12
    local bottomY = math.max(headPos.Y, hrpPos.Y) + 12
    local h = math.max(2, bottomY - topY)
    local w = math.max(2, (h * 0.6))
    
    -- Only filter out if taking up almost entire screen
    if w > vw * 0.95 or h > vh * 0.95 then return end
    
    local x = hrpPos.X - w / 2
    local y = topY
    return { x = x, y = y, w = w, h = h, cx = x + w/2, cy = y + h/2 }
end

local function getObjectRect(obj)
    if not obj or not obj:IsA("BasePart") and not obj:IsA("Model") then return end
    local pos
    if obj:IsA("Model") then
        local primary = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
        if not primary then return end
        pos = primary.Position
    else
        pos = obj.Position
    end
    local sp = Camera:WorldToViewportPoint(pos)
    if sp.Z <= 0 then return end
    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    if sp.X < 0 or sp.X > vw or sp.Y < 0 or sp.Y > vh then return end
    local distance = (pos - Camera.CFrame.Position).Magnitude
    local size = math.clamp(800 / distance, 20, 100)
    return { x = sp.X - size/2, y = sp.Y - size/2, w = size, h = size, cx = sp.X, cy = sp.Y, distance = distance, worldPos = pos }
end

-- NOTE: Drawing library does NOT support native gradients. Segments are the ONLY way.
-- Optimized gradient system: dynamically allocate segments based on box size
-- to minimize drawing calls while maintaining smooth appearance.
-- Segments are precisely positioned with NO overlap to prevent transparency artifacts.
local MAX_GRADIENT_SEGMENTS = 500  -- Reduced from 2000 for better performance
local MIN_GRADIENT_SEGMENTS = 10   -- Minimum segments for very small boxes
local BOX_LINE_SEGMENTS = 50       -- Reduced from 100 for better performance

local function createESPObject()
    local espObj = {
        Name = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        BoxLines = {},  -- 4 sides with gradient segments
        BoxOutlineLines = {},  -- outline for each side
        BoxFill = Drawing.new("Square"),
        GradientSegments = {},
        Corners = {
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")},
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")},
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")},
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")}
        },
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        HealthBarGradient = {},  -- For rainbow gradient on health bar
        Highlight = nil,
        Player = nil,
        IsObject = false
    }
    
    -- Create health bar gradient segments (for rainbow)
    local HEALTH_GRADIENT_SEGS = 500
    for i = 1, HEALTH_GRADIENT_SEGS do
        local seg = Drawing.new("Square")
        seg.Filled = true
        seg.Visible = false
        espObj.HealthBarGradient[i] = seg
    end
    
    -- Create box line segments for rainbow gradient on box edges
    for side = 1, 4 do
        espObj.BoxLines[side] = {}
        espObj.BoxOutlineLines[side] = {}
        for seg = 1, BOX_LINE_SEGMENTS do
            local line = Drawing.new("Line")
            line.Thickness = 1
            line.Visible = false
                    espObj.BoxLines[side][seg] = line
            
                    local outLine = Drawing.new("Line")
                    outLine.Thickness = ESPSettings.Thickness or 3
                    outLine.Color = ESPSettings.BoxOutlineColor or Color3.new(0, 0, 0)
                    outLine.Visible = false
                    espObj.BoxOutlineLines[side][seg] = outLine
        end
    end
    
    -- Create gradient segments for fill (optimized pool size)
    for i = 1, MAX_GRADIENT_SEGMENTS do
        espObj.GradientSegments[i] = Drawing.new("Square")
        espObj.GradientSegments[i].Filled = true
        espObj.GradientSegments[i].Visible = false
    end
    
    
            -- Equipped tool display (text + optional image if supported)
            espObj.EquippedText = Drawing.new("Text")
            espObj.EquippedText.Center = true
            espObj.EquippedText.Outline = true
            espObj.EquippedText.OutlineColor = Color3.new(0,0,0)
            espObj.EquippedText.Size = ESPSettings.TextSize
            espObj.EquippedText.Font = 3
            espObj.EquippedText.Visible = false
    
            local okImg, img = pcall(function() return Drawing.new("Image") end)
            if okImg and img then
                espObj.EquippedImage = img
                espObj.EquippedImage.Visible = false
            else
                espObj.EquippedImage = nil
            end
    -- Outline square for crisp non-rainbow box rendering
    espObj.OutlineSquare = Drawing.new("Square")
    espObj.OutlineSquare.Filled = false
    espObj.OutlineSquare.Visible = false
    espObj.OutlineSquare.Thickness = ESPSettings.Thickness or 3
    espObj.OutlineSquare.Color = ESPSettings.BoxColor or Color3.fromRGB(0,170,255)
    espObj.Name.Center = true
    espObj.Name.Outline = true
    espObj.Name.OutlineColor = Color3.new(0,0,0)
    espObj.Name.Size = ESPSettings.TextSize
    espObj.Name.Font = 3
    espObj.Name.Visible = false
    -- Separate text objects for Name / Health / Distance (so they can be positioned independently)
    espObj.HealthText = Drawing.new("Text")
    espObj.HealthText.Center = true
    espObj.HealthText.Outline = true
    espObj.HealthText.OutlineColor = Color3.new(0,0,0)
    espObj.HealthText.Size = ESPSettings.TextSize
    espObj.HealthText.Font = 3
    espObj.HealthText.Visible = false

    espObj.DistanceText = Drawing.new("Text")
    espObj.DistanceText.Center = true
    espObj.DistanceText.Outline = true
    espObj.DistanceText.OutlineColor = Color3.new(0,0,0)
    espObj.DistanceText.Size = ESPSettings.TextSize
    espObj.DistanceText.Font = 3
    espObj.DistanceText.Visible = false
    
    espObj.Tracer.Thickness = ESPSettings.TracerThickness
    espObj.Tracer.Visible = false
    
    espObj.BoxFill.Filled = true
    espObj.BoxFill.Visible = false
    
    for _, c in ipairs(espObj.Corners) do
        c.Line1.Thickness = ESPSettings.Thickness or 1
        c.Line2.Thickness = ESPSettings.Thickness or 1
        c.Line1.Visible = false
        c.Line2.Visible = false
    end
    
    espObj.HealthBar.Filled = true
    espObj.HealthBar.Visible = false
    
    espObj.HealthBarOutline.Filled = false
    espObj.HealthBarOutline.Thickness = 2
    espObj.HealthBarOutline.Visible = false
    
    return espObj
end

local function removeESP(espObj)
    if not espObj then return end
    pcall(function() espObj.Name:Remove() end)
    pcall(function() if espObj.HealthText then espObj.HealthText:Remove() end end)
    pcall(function() if espObj.DistanceText then espObj.DistanceText:Remove() end end)
    pcall(function() espObj.Tracer:Remove() end)
    for side = 1, 4 do
        for _, line in ipairs(espObj.BoxLines[side] or {}) do pcall(function() line:Remove() end) end
        for _, line in ipairs(espObj.BoxOutlineLines[side] or {}) do pcall(function() line:Remove() end) end
    end
    pcall(function() espObj.BoxFill:Remove() end)
    for _, seg in ipairs(espObj.GradientSegments or {}) do
        pcall(function() seg:Remove() end)
    end
    pcall(function() espObj.HealthBar:Remove() end)
    pcall(function() espObj.HealthBarOutline:Remove() end)
    for _, seg in ipairs(espObj.HealthBarGradient or {}) do
        pcall(function() seg:Remove() end)
    end
    for _, c in ipairs(espObj.Corners) do
        pcall(function() c.Line1:Remove() end)
        pcall(function() c.Line2:Remove() end)
    end
    if espObj.Highlight then pcall(function() espObj.Highlight:Destroy() end) end
    pcall(function() if espObj.EquippedText then espObj.EquippedText:Remove() end end)
    pcall(function() if espObj.EquippedImage then espObj.EquippedImage:Remove() end end)
    pcall(function() if espObj.OutlineSquare then espObj.OutlineSquare:Remove() end end)
end

local function hideESP(espObj)
    espObj.Name.Visible = false
    if espObj.HealthText then espObj.HealthText.Visible = false end
    if espObj.DistanceText then espObj.DistanceText.Visible = false end
    espObj.Tracer.Visible = false
    for side = 1, 4 do
        for _, line in ipairs(espObj.BoxLines[side] or {}) do line.Visible = false end
        for _, line in ipairs(espObj.BoxOutlineLines[side] or {}) do line.Visible = false end
    end
    espObj.BoxFill.Visible = false
    for _, seg in ipairs(espObj.GradientSegments or {}) do seg.Visible = false end
    for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
    espObj.HealthBar.Visible = false
    espObj.HealthBarOutline.Visible = false
    for _, seg in ipairs(espObj.HealthBarGradient or {}) do seg.Visible = false end
    if espObj.Highlight then espObj.Highlight.Enabled = false end
    if espObj.EquippedText then espObj.EquippedText.Visible = false end
    if espObj.EquippedImage then espObj.EquippedImage.Visible = false end
    if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
end

local function drawGradient(espObj, rect, color1, color2, rotation, transparency, useRainbow, baseOffset, element)
    local segments = espObj.GradientSegments
    local maxSegs = #segments
    
    -- Use EXACT rect dimensions without modification
    local rectX = rect.x
    local rectY = rect.y
    local rectW = rect.w
    local rectH = rect.h
    
    if rectH <= 0 or rectW <= 0 then
        -- nothing to draw
        for i = 1, maxSegs do segments[i].Visible = false end
        return
    end
    
    -- Dynamic segment count: scale with box height but cap at reasonable limits
    local segCount = math.clamp(math.floor(rectH / 3), MIN_GRADIENT_SEGMENTS, math.min(maxSegs, math.max(1, math.floor(rectH))))
    
    -- Pre-calculate float-based segment positions that EXACTLY cover the rect area
    local positions = {}
    local baseSegH = rectH / segCount
    local used = 0.0
    for i = 1, segCount do
        local h = baseSegH
        positions[i] = { y = rectY + used, h = math.max(0.0001, h) }
        used = used + positions[i].h
    end
    -- Fix any floating point drift so last segment ends exactly at rectY + rectH
    if segCount > 0 then
        positions[segCount].h = (rectY + rectH) - positions[segCount].y
        if positions[segCount].h < 0 then positions[segCount].h = 0 end
    end

    -- Do NOT add integer overlaps here - we rely on float segmentation for exact coverage
    
    -- Render segments with exact positioning
    for i = 1, segCount do
        local t = (i - 0.5) / segCount
        local segColor
        if useRainbow then
            segColor = getRainbowColor((baseOffset or 0) + t * 0.5, element)
        else
            segColor = lerpColor(color1, color2, t)
        end
        
        segments[i].Size = Vector2.new(rectW, positions[i].h)
        segments[i].Position = Vector2.new(rectX, positions[i].y)
        segments[i].Color = segColor
        segments[i].Transparency = transparency or 0
        segments[i].Visible = true
    end
    
    -- Hide unused segments
    for i = segCount + 1, maxSegs do
        segments[i].Visible = false
    end
end

local function hideGradient(espObj)
    for _, seg in ipairs(espObj.GradientSegments or {}) do seg.Visible = false end
end

local function drawBoxWithGradient(espObj, x, y, w, h, useRainbow, baseColor, baseOffset)
    -- Draw 4 sides: top, right, bottom, left
    -- Rainbow gradient goes VERTICALLY DOWN based on Y position
    local sides = {
        {x, y, x + w, y},         -- top (horizontal)
        {x + w, y, x + w, y + h}, -- right (vertical)
        {x + w, y + h, x, y + h}, -- bottom (horizontal)
        {x, y + h, x, y}          -- left (vertical)
    }
    
    for sideIdx, side in ipairs(sides) do
        local sx, sy, ex, ey = side[1], side[2], side[3], side[4]
        -- Snap endpoints to the integer pixel grid for exact coverage
        local ax_sx, ax_sy = math.floor(sx + 0.5), math.floor(sy + 0.5)
        local ax_ex, ax_ey = math.floor(ex + 0.5), math.floor(ey + 0.5)
        local segCount = #espObj.BoxLines[sideIdx]

        -- Determine orientation and total integer span in pixels
        local horizontal = math.abs(ax_ex - ax_sx) >= math.abs(ax_ey - ax_sy)
        local totalLen = horizontal and math.abs(ax_ex - ax_sx) or math.abs(ax_ey - ax_sy)

        if totalLen <= 0 then
            -- Nothing to draw; hide pool
            for i = 1, segCount do
                espObj.BoxLines[sideIdx][i].Visible = false
                if espObj.BoxOutlineLines[sideIdx][i] then espObj.BoxOutlineLines[sideIdx][i].Visible = false end
            end
        else
            -- Use at most one segment per pixel where possible, clamped to pool size
            local dynamicSegCount = math.clamp(math.min(segCount, totalLen), 1, segCount)

            -- Distribute integer pixels across segments so they exactly tile the side
            local base = math.floor(totalLen / dynamicSegCount)
            local rem = totalLen - base * dynamicSegCount
            local acc = 0

            for seg = 1, dynamicSegCount do
                local segLen = base + (seg <= rem and 1 or 0)
                local startOff = acc
                local endOff = acc + segLen
                acc = acc + segLen

                local line = espObj.BoxLines[sideIdx][seg]
                local outLine = espObj.BoxOutlineLines[sideIdx][seg]

                if horizontal then
                    local sx_i = (ax_sx <= ax_ex) and (ax_sx + startOff) or (ax_sx - startOff)
                    local ex_i = (ax_sx <= ax_ex) and (ax_sx + endOff) or (ax_sx - endOff)
                    local y_i = ax_sy

                    line.From = Vector2.new(sx_i, y_i)
                    line.To = Vector2.new(ex_i, y_i)
                    outLine.From = Vector2.new(sx_i, y_i)
                    outLine.To = Vector2.new(ex_i, y_i)

                    local avgY = y_i
                    local yProgress = (avgY - y) / math.max(1, h)

                    if useRainbow then
                        line.Color = getRainbowColor(baseOffset + yProgress * 0.5, "Box")
                        if outLine then outLine.Visible = false end
                    else
                        line.Color = baseColor
                        if outLine then
                            outLine.Color = ESPSettings.BoxOutlineColor
                            outLine.Thickness = ESPSettings.Thickness or 3
                            outLine.Visible = true
                        end
                    end

                    line.Thickness = ESPSettings.Thickness or 1
                    line.Visible = true
                else
                    local sy_i = (ax_sy <= ax_ey) and (ax_sy + startOff) or (ax_sy - startOff)
                    local ey_i = (ax_sy <= ax_ey) and (ax_sy + endOff) or (ax_sy - endOff)
                    local x_i = ax_sx

                    line.From = Vector2.new(x_i, sy_i)
                    line.To = Vector2.new(x_i, ey_i)
                    outLine.From = Vector2.new(x_i, sy_i)
                    outLine.To = Vector2.new(x_i, ey_i)

                    local avgY = (sy_i + ey_i) / 2
                    local yProgress = (avgY - y) / math.max(1, h)

                    if useRainbow then
                        line.Color = getRainbowColor(baseOffset + yProgress * 0.5, "Box")
                        if outLine then outLine.Visible = false end
                    else
                        line.Color = baseColor
                        if outLine then
                            outLine.Color = ESPSettings.BoxOutlineColor
                            outLine.Thickness = ESPSettings.Thickness or 3
                            outLine.Visible = true
                        end
                    end

                    line.Thickness = ESPSettings.Thickness or 1
                    line.Visible = true
                end
            end

            -- Hide unused segments
            for seg = dynamicSegCount + 1, segCount do
                espObj.BoxLines[sideIdx][seg].Visible = false
                if espObj.BoxOutlineLines[sideIdx][seg] then espObj.BoxOutlineLines[sideIdx][seg].Visible = false end
            end
        end
    end
end

local function hideBoxLines(espObj)
    for side = 1, 4 do
        for _, line in ipairs(espObj.BoxLines[side] or {}) do line.Visible = false end
        for _, line in ipairs(espObj.BoxOutlineLines[side] or {}) do line.Visible = false end
    end
end

local function updateESP()

    for player, espObj in pairs(ESPObjects) do
        pcall(function()
            if not shouldShowPlayer(player) then 
                hideESP(espObj) 
                return 
            end
            
            local char = player and player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not char or not hrp or not hum or hum.Health <= 0 then
                hideESP(espObj)
                return
            end

            local distance = (hrp.Position - Camera.CFrame.Position).Magnitude
            if distance > ESPSettings.MaxDistance then
                hideESP(espObj)
                return
            end

            local rect = getScreenRectForCharacter(char) or getFallbackRect(char)
            if not rect then
                hideESP(espObj)
                return
            end

            -- Calculate colors with individual rainbow settings
            -- Use world-space Y position for camera-independent gradient (doesn't shift when camera moves)
            local worldY = 0
            if char and char.PrimaryPart then
                worldY = char.PrimaryPart.Position.Y
            elseif char and char:FindFirstChild("HumanoidRootPart") then
                worldY = char.HumanoidRootPart.Position.Y
            end
            
            -- Normalize world Y to 0-1 range (assuming typical world height 0-500)
            local baseOffset = (worldY % 500) / 500
            
            -- For non-box elements, use their Y position relative to box
            local topColor = getRainbowColor(baseOffset, "Box")                    -- Top of box
            local centerColor = getRainbowColor(baseOffset + 0.25, "Chams")          -- Center of box
            local bottomColor = getRainbowColor(baseOffset + 0.5, "Tracer")           -- Bottom of box
            
            local boxColor = ESPSettings.BoxRainbow and topColor or (ESPSettings.BoxCustomColor1 or ESPSettings.BoxColor)
            -- Tracer ends at bottom of box, so use bottom color
            local tracerColor = ESPSettings.TracerRainbow and bottomColor or (ESPSettings.TracerCustomColor1 or ESPSettings.TracerColor)
            -- Chams use center color
            local chamColor = ESPSettings.ChamsRainbow and centerColor or (ESPSettings.ChamsCustomColor1 or ESPSettings.GlobalChamColor)
            -- Name is above box; when using rainbow, use Name element colors
            local nameColor = ESPSettings.NameRainbow and getRainbowColor(baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)

            -- precompute box coordinates so healthbar/chams can render even when ESP visuals are disabled
            local x, y, w, h = rect.x, rect.y, rect.w, rect.h

            if ESPSettings.Enabled then
                -- Text: render Name, Health and Distance as separate Drawing.Text objects so
                -- each can be positioned independently and receive per-element rainbow colors.
                local topList, bottomList, leftList, rightList = {}, {}, {}, {}

                if ESPSettings.ShowName then
                    table.insert((ESPSettings.NamePosition or "Top") == "Top" and topList or (ESPSettings.NamePosition == "Bottom" and bottomList or (ESPSettings.NamePosition == "Left" and leftList or rightList)), {key = "Name", text = player.Name})
                end
                if ESPSettings.ShowHealthText then
                    table.insert((ESPSettings.HealthTextPosition or "Top") == "Top" and topList or (ESPSettings.HealthTextPosition == "Bottom" and bottomList or (ESPSettings.HealthTextPosition == "Left" and leftList or rightList)), {key = "Health", text = math.floor(hum.Health) .. "HP"})
                end
                if ESPSettings.ShowDistance then
                    table.insert((ESPSettings.DistancePosition or "Top") == "Top" and topList or (ESPSettings.DistancePosition == "Bottom" and bottomList or (ESPSettings.DistancePosition == "Left" and leftList or rightList)), {key = "Distance", text = math.floor(distance) .. "m"})
                end

                -- Collect simple custom text entries and append to top by default
                local customTopConcat
                for entryName, entry in pairs(ESPSettings.TextEntries) do
                    if entry.Enabled and entry.GetText then
                        local customText = entry.GetText(player, char, hum, distance)
                        if customText then
                            customTopConcat = customTopConcat and (customTopConcat .. " | " .. customText) or customText
                        end
                    end
                end

                -- Positioning helpers
                local lineHeight = (ESPSettings.TextSize or 14) + 4

                -- Helper to detect collisions of multiple items in same anchor; when multiple
                -- items (eg Name+Health) share the same anchor we fall back to the old combined
                -- single-line behavior to preserve spacing and avoid overlap.
                local function shouldCombine(list, anchor)
                    -- Only use combined single-line fallback for Top anchor (preserves old UX)
                    return anchor == "Top" and list and #list > 1
                end

                local function renderCombined(list, anchor)
                    if not list or #list == 0 then return end
                    local texts = {}
                    for _, item in ipairs(list) do table.insert(texts, item.text) end
                    local combined = table.concat(texts, " | ")
                    local x = math.floor(rect.cx)
                    local y
                    if anchor == "Top" then
                        y = math.floor(rect.y - 18)
                        if ESPSettings.HealthBarEnabled and ESPSettings.HealthBarPosition == "Top" then
                            y = y - ESPSettings.HealthBarThickness - 4
                        end
                    elseif anchor == "Bottom" then
                        y = math.floor(rect.y + rect.h + 12)
                    elseif anchor == "Left" then
                        y = math.floor(rect.cy)
                        x = math.floor(rect.x - 6)
                    else
                        y = math.floor(rect.cy)
                        x = math.floor(rect.x + rect.w + 6)
                    end
                    espObj.Name.Center = (anchor == "Top" or anchor == "Bottom")
                    espObj.Name.Size = ESPSettings.TextSize
                    espObj.Name.Text = combined
                    espObj.Name.Position = Vector2.new(x, y)
                    espObj.Name.Color = ESPSettings.NameColor
                    espObj.Name.Visible = true
                    -- hide individual texts when combined
                    if espObj.HealthText then espObj.HealthText.Visible = false end
                    if espObj.DistanceText then espObj.DistanceText.Visible = false end
                end

                local function renderList(list, anchor)
                    if not list or #list == 0 then return end
                    if shouldCombine(list, anchor) then
                        renderCombined(list, anchor)
                        return
                    end

                    if anchor == "Top" then
                        -- stack upward: first item just above box (matching previous default)
                        for i, item in ipairs(list) do
                            local y = math.floor(rect.y - 18 - (i - 1) * lineHeight)
                            if ESPSettings.HealthBarEnabled and ESPSettings.HealthBarPosition == "Top" then
                                y = y - ESPSettings.HealthBarThickness - 4
                            end
                            local x = math.floor(rect.cx)
                            local col
                            if item.key == "Name" then
                                col = ESPSettings.NameRainbow and getRainbowColor(0 + baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)
                                espObj.Name.Center = true
                                espObj.Name.Size = ESPSettings.TextSize
                                espObj.Name.Text = item.text
                                espObj.Name.Position = Vector2.new(x, y)
                                espObj.Name.Color = col
                                espObj.Name.Visible = true
                            elseif item.key == "Health" then
                                col = ESPSettings.HealthTextRainbow and getRainbowColor(0 + baseOffset, "HealthBar") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.HealthText.Center = true
                                espObj.HealthText.Size = ESPSettings.TextSize
                                espObj.HealthText.Text = item.text
                                espObj.HealthText.Position = Vector2.new(x, y)
                                espObj.HealthText.Color = col
                                espObj.HealthText.Visible = true
                            elseif item.key == "Distance" then
                                col = ESPSettings.DistanceRainbow and getRainbowColor(0 + baseOffset, "Tracer") or (ESPSettings.DistanceCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.DistanceText.Center = true
                                espObj.DistanceText.Size = ESPSettings.TextSize
                                espObj.DistanceText.Text = item.text
                                espObj.DistanceText.Position = Vector2.new(x, y)
                                espObj.DistanceText.Color = col
                                espObj.DistanceText.Visible = true
                            end
                        end
                    elseif anchor == "Bottom" then
                        for i, item in ipairs(list) do
                            local y = math.floor(rect.y + rect.h + 12 + (i - 1) * lineHeight)
                            local x = math.floor(rect.cx)
                            local col
                            if item.key == "Name" then
                                col = ESPSettings.NameRainbow and getRainbowColor(0 + baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)
                                espObj.Name.Center = true
                                espObj.Name.Size = ESPSettings.TextSize
                                espObj.Name.Text = item.text
                                espObj.Name.Position = Vector2.new(x, y)
                                espObj.Name.Color = col
                                espObj.Name.Visible = true
                            elseif item.key == "Health" then
                                col = ESPSettings.HealthTextRainbow and getRainbowColor(0 + baseOffset, "HealthBar") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.HealthText.Center = true
                                espObj.HealthText.Size = ESPSettings.TextSize
                                espObj.HealthText.Text = item.text
                                espObj.HealthText.Position = Vector2.new(x, y)
                                espObj.HealthText.Color = col
                                espObj.HealthText.Visible = true
                            elseif item.key == "Distance" then
                                col = ESPSettings.DistanceRainbow and getRainbowColor(0 + baseOffset, "Tracer") or (ESPSettings.DistanceCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.DistanceText.Center = true
                                espObj.DistanceText.Size = ESPSettings.TextSize
                                espObj.DistanceText.Text = item.text
                                espObj.DistanceText.Position = Vector2.new(x, y)
                                espObj.DistanceText.Color = col
                                espObj.DistanceText.Visible = true
                            end
                        end
                    else
                        -- Left/Right: vertically centered stacking
                        local startY = rect.cy - ((#list - 1) / 2) * lineHeight
                        for i, item in ipairs(list) do
                            local y = math.floor(startY + (i - 1) * lineHeight)
                            local x
                            if anchor == "Left" then x = math.floor(rect.x - 6) else x = math.floor(rect.x + rect.w + 6) end
                            local col
                            if item.key == "Name" then
                                col = ESPSettings.NameRainbow and getRainbowColor(0 + baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)
                                espObj.Name.Center = false
                                espObj.Name.Size = ESPSettings.TextSize
                                espObj.Name.Text = item.text
                                espObj.Name.Position = Vector2.new(x, y)
                                espObj.Name.Color = col
                                espObj.Name.Visible = true
                            elseif item.key == "Health" then
                                col = ESPSettings.HealthTextRainbow and getRainbowColor(0 + baseOffset, "HealthBar") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.HealthText.Center = false
                                espObj.HealthText.Size = ESPSettings.TextSize
                                espObj.HealthText.Text = item.text
                                espObj.HealthText.Position = Vector2.new(x, y)
                                espObj.HealthText.Color = col
                                espObj.HealthText.Visible = true
                            elseif item.key == "Distance" then
                                col = ESPSettings.DistanceRainbow and getRainbowColor(0 + baseOffset, "Tracer") or (ESPSettings.DistanceCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.DistanceText.Center = false
                                espObj.DistanceText.Size = ESPSettings.TextSize
                                espObj.DistanceText.Text = item.text
                                espObj.DistanceText.Position = Vector2.new(x, y)
                                espObj.DistanceText.Color = col
                                espObj.DistanceText.Visible = true
                            end
                        end
                    end
                end

                renderList(topList, "Top")
                renderList(bottomList, "Bottom")
                renderList(leftList, "Left")
                renderList(rightList, "Right")

                -- Render any collected custom text entries as a single top line (if present)
                if customTopConcat and customTopConcat ~= "" then
                    local y = math.floor(rect.y - 18 - (#topList) * lineHeight)
                    if ESPSettings.HealthBarEnabled and ESPSettings.HealthBarPosition == "Top" then
                        y = y - ESPSettings.HealthBarThickness - 4
                    end
                    espObj.Name.Center = true
                    espObj.Name.Size = ESPSettings.TextSize
                    espObj.Name.Text = customTopConcat
                    espObj.Name.Position = Vector2.new(math.floor(rect.cx), y)
                    espObj.Name.Color = ESPSettings.NameColor
                    espObj.Name.Visible = true
                end

                -- Equipped display (Bottom / Image handling)
                if ESPSettings.EquippedEnabled then
                    -- If image mode and image support exists, try to show image; otherwise fall back to text showing tool name or 'None'
                    local showImage = (ESPSettings.EquippedMode == "Image") and espObj.EquippedImage ~= nil
                    local mappedImage = nil
                    if showImage then
                        local toolKey = equippedName and equippedName:lower() or nil
                        if toolKey and getgenv().TrisESP then
                            -- check place-specific mapping first
                            local placeMap = getgenv().TrisESP.PlaceToolImages and getgenv().TrisESP.PlaceToolImages[tostring(game.PlaceId)]
                            if placeMap and placeMap[toolKey] then
                                mappedImage = placeMap[toolKey]
                            end
                            -- then global mapping
                            if not mappedImage and getgenv().TrisESP.ToolImages then
                                mappedImage = getgenv().TrisESP.ToolImages[toolKey]
                            end
                        end
                        -- fallback to global EquippedImage setting
                        if not mappedImage and ESPSettings.EquippedImage and ESPSettings.EquippedImage ~= "" then mappedImage = ESPSettings.EquippedImage end
                    end

                    if ESPSettings.EquippedMode == "Image" and showImage and mappedImage then
                        -- Hide text and show image
                        espObj.EquippedText.Visible = false
                        espObj.EquippedImage.Data = mappedImage
                        espObj.EquippedImage.Size = Vector2.new(32, 32)
                        if ESPSettings.EquippedPosition == "Inline" then
                            espObj.EquippedImage.Position = Vector2.new(rect.cx, rect.y - 32)
                        else
                            espObj.EquippedImage.Position = Vector2.new(rect.cx, rect.y + rect.h + 6)
                        end
                        espObj.EquippedImage.Visible = true
                    else
                        -- show text (tool name or 'None') in the chosen position
                        espObj.EquippedImage.Visible = false
                        local txt = equippedName or "None"
                        espObj.EquippedText.Text = txt
                        if ESPSettings.EquippedPosition == "Inline" then
                            -- inline already included in name, hide separate equipped text
                            espObj.EquippedText.Visible = false
                        else
                            espObj.EquippedText.Position = Vector2.new(math.floor(rect.cx), math.floor(rect.y + rect.h + 12))
                            espObj.EquippedText.Color = nameColor
                            espObj.EquippedText.Size = ESPSettings.TextSize
                            espObj.EquippedText.Visible = true
                        end
                    end
                else
                    if espObj.EquippedImage then espObj.EquippedImage.Visible = false end
                    if espObj.EquippedText then espObj.EquippedText.Visible = false end
                end

                -- Tracers
                if ESPSettings.Tracers then
                    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
                    local fromPos
                    if ESPSettings.TracerFrom == "Bottom" then
                        fromPos = Vector2.new(vw/2, vh)
                    elseif ESPSettings.TracerFrom == "Top" then
                        fromPos = Vector2.new(vw/2, 0)
                    elseif ESPSettings.TracerFrom == "Mouse" then
                        fromPos = UserInputService:GetMouseLocation()
                    else
                        fromPos = Vector2.new(vw/2, vh/2)
                    end
                    espObj.Tracer.From = fromPos
                    espObj.Tracer.To = Vector2.new(rect.cx, rect.y + rect.h)
                    espObj.Tracer.Color = tracerColor
                    espObj.Tracer.Thickness = ESPSettings.TracerThickness
                    espObj.Tracer.Visible = true
                else
                    espObj.Tracer.Visible = false
                end

                -- Box fill (independent from Box ESP)
                if ESPSettings.BoxFill then
                    if ESPSettings.BoxFillGradient or ESPSettings.BoxFillRainbow then
                        local useRainbow = ESPSettings.BoxFillRainbow
                        -- Inset gradient so it stays fully inside the outline stroke
                        local thickness = ESPSettings.Thickness or 1
                        local inset = thickness / 2
                        local innerX = x + inset
                        local innerY = y + inset
                        local innerW = math.max(0, w - inset * 2)
                        local innerH = math.max(0, h - inset * 2)

                        drawGradient(espObj, {x = innerX, y = innerY, w = innerW, h = innerH}, ESPSettings.BoxFillCustomColor1, ESPSettings.BoxFillCustomColor3, 
                            0, 1 - ESPSettings.BoxFillTransparency, useRainbow, baseOffset, "BoxFill")
                        espObj.BoxFill.Visible = false

                        -- Draw outline around gradient fill for proper bounding using exact positions
                        if espObj.OutlineSquare and ESPSettings.BoxType == "Square" and ESPSettings.Boxes then
                            espObj.OutlineSquare.Size = Vector2.new(w, h)
                            espObj.OutlineSquare.Position = Vector2.new(x, y)
                            espObj.OutlineSquare.Color = ESPSettings.BoxOutlineColor
                            espObj.OutlineSquare.Thickness = thickness
                            espObj.OutlineSquare.Visible = true
                        else
                            if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                        end
                    else
                        hideGradient(espObj)
                        local fillColor = ESPSettings.BoxFillCustomColor1 or ESPSettings.BoxFillColor
                        espObj.BoxFill.Size = Vector2.new(math.max(1, w), math.max(1, h))
                        espObj.BoxFill.Position = Vector2.new(x, y)
                        espObj.BoxFill.Color = fillColor
                        espObj.BoxFill.Transparency = 1 - ESPSettings.BoxFillTransparency
                        espObj.BoxFill.Visible = true
                        -- Draw outline around solid fill for proper bounding (only when box outlines enabled)
                        if espObj.OutlineSquare and ESPSettings.BoxType == "Square" and ESPSettings.Boxes then
                            local thickness = ESPSettings.Thickness or 1
                            espObj.OutlineSquare.Size = Vector2.new(math.floor(w), math.floor(h))
                            espObj.OutlineSquare.Position = Vector2.new(math.floor(x), math.floor(y))
                            espObj.OutlineSquare.Color = ESPSettings.BoxOutlineColor
                            espObj.OutlineSquare.Thickness = thickness
                            espObj.OutlineSquare.Visible = true
                        else
                            if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                        end
                    end
                else
                    espObj.BoxFill.Visible = false
                    hideGradient(espObj)
                    if espObj.OutlineSquare and not ESPSettings.Boxes then espObj.OutlineSquare.Visible = false end
                end

                -- Boxes (outline)
                if ESPSettings.Boxes then
                if ESPSettings.BoxType == "Square" then
                    -- Square box
                    if ESPSettings.BoxRainbow then
                        -- Use segmented lines for smooth vertical rainbow gradient
                        drawBoxWithGradient(espObj, x, y, w, h, true, boxColor, baseOffset)
                        -- hide crisp outline when using gradient segments
                        if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                    else
                        -- Use a single square outline for crisp, sharp edges when not rainbow
                        hideBoxLines(espObj)
                        if espObj.OutlineSquare and not ESPSettings.BoxFill then
                            -- Only draw outline if not already drawn for fill
                            local thickness = ESPSettings.Thickness or 1
                            local offset = math.floor(thickness / 2)
                            espObj.OutlineSquare.Size = Vector2.new(math.floor(w), math.floor(h))
                            espObj.OutlineSquare.Position = Vector2.new(math.floor(x), math.floor(y))
                            espObj.OutlineSquare.Color = boxColor
                            espObj.OutlineSquare.Thickness = thickness
                            espObj.OutlineSquare.Visible = true
                        end
                    end

                    for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
                else
                    -- Corner box
                    if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                    hideBoxLines(espObj)
                    
                    -- If BoxFill gradient is active we used an inset inner rect for the fill;
                    -- align corner lines to the visible filled rect so corners and fills match.
                    local bx, by, bw, bh = x, y, w, h
                    if ESPSettings.BoxFill and (ESPSettings.BoxFillGradient or ESPSettings.BoxFillRainbow) then
                        local thickness = ESPSettings.Thickness or 1
                        local inset = thickness / 2
                        bx = x + inset
                        by = y + inset
                        bw = math.max(0, w - inset * 2)
                        bh = math.max(0, h - inset * 2)
                    end

                    -- Snap corners to integer pixel grid so they meet segmented sides exactly
                    local left = math.floor(bx + 0.5)
                    local top = math.floor(by + 0.5)
                    local right = math.floor(bx + bw + 0.5)
                    local bottom = math.floor(by + bh + 0.5)

                    local L = math.clamp(math.floor((math.min(right - left, bottom - top) * 0.25) + 0.5), 2, 50)
                    local corners = {
                        {left, top, left + L, top, left, top + L},                     -- top-left
                        {right, top, right - L, top, right, top + L},                 -- top-right
                        {left, bottom, left + L, bottom, left, bottom - L},           -- bottom-left
                        {right, bottom, right - L, bottom, right, bottom - L}        -- bottom-right
                    }

                    -- Y positions for vertical rainbow gradient
                    local cornerYs = {0, 0, 1, 1}  -- top corners = 0, bottom corners = 1

                    for i, corner in ipairs(corners) do
                        local c = espObj.Corners[i]
                        local x1, y1 = corner[1], corner[2]
                        local x2, y2 = corner[3], corner[4]
                        local x3, y3 = corner[5], corner[6]

                        c.Line1.From = Vector2.new(x1, y1)
                        c.Line1.To = Vector2.new(x2, y2)
                        c.Line2.From = Vector2.new(x1, y1)
                        c.Line2.To = Vector2.new(x3, y3)

                        if ESPSettings.BoxRainbow then
                            -- Vertical gradient: top corners share one color, bottom corners share another
                            local yProgress = cornerYs[i]
                            c.Line1.Color = getRainbowColor(baseOffset + yProgress * 0.5, "Box")
                            c.Line2.Color = getRainbowColor(baseOffset + yProgress * 0.5, "Box")
                        else
                            c.Line1.Color, c.Line2.Color = boxColor, boxColor
                        end

                        c.Line1.Thickness = ESPSettings.Thickness or 1
                        c.Line2.Thickness = ESPSettings.Thickness or 1
                        c.Line1.Visible, c.Line2.Visible = true, true
                    end
                end
                else
                    -- Hide box outlines when Boxes disabled
                    hideBoxLines(espObj)
                    if espObj.OutlineSquare and not ESPSettings.BoxFill then espObj.OutlineSquare.Visible = false end
                    for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
                end
                
            else
                -- ESP disabled - hide all visuals
                espObj.Name.Visible = false
                espObj.Tracer.Visible = false
                hideBoxLines(espObj)
                espObj.BoxFill.Visible = false
                hideGradient(espObj)
                for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
                if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                if espObj.EquippedText then espObj.EquippedText.Visible = false end
                if espObj.EquippedImage then espObj.EquippedImage.Visible = false end
            end

            -- Health bar
            if ESPSettings.Enabled and ESPSettings.HealthBarEnabled and rect then
                local maxHealth = math.max(1, hum.MaxHealth or 100)
                local ratio = math.clamp(hum.Health / maxHealth, 0, 1)
                local thickness = ESPSettings.HealthBarThickness  -- Fixed pixel thickness
                local pos = ESPSettings.HealthBarPosition
                local barX, barY, barW, barH, fillX, fillY, fillW, fillH
                local isVertical = (pos == "Left" or pos == "Right")
                    
                    -- Use actual box dimensions - no arbitrary clamping
                    if pos == "Left" then
                        barX, barY = x - thickness - 2, y
                        barW, barH = thickness, h
                        fillW = thickness - 2
                        fillH = math.max(1, math.floor(h * ratio))
                        fillX, fillY = barX + 1, y + h - fillH
                    elseif pos == "Right" then
                        barX, barY = x + w + 2, y
                        barW, barH = thickness, h
                        fillW = thickness - 2
                        fillH = math.max(1, math.floor(h * ratio))
                        fillX, fillY = barX + 1, y + h - fillH
                    elseif pos == "Top" then
                        barX, barY = x, y - thickness - 2
                        barW, barH = w, thickness
                        fillW = math.max(1, math.floor(w * ratio))
                        fillH = thickness - 2
                        fillX, fillY = x, barY + 1
                    else -- Bottom
                        barX, barY = x, y + h + 2
                        barW, barH = w, thickness
                        fillW = math.max(1, math.floor(w * ratio))
                        fillH = thickness - 2
                        fillX, fillY = x, barY + 1
                    end

                    if ESPSettings.HealthBarOutline then
                        espObj.HealthBarOutline.Size = Vector2.new(barW, barH)
                        espObj.HealthBarOutline.Position = Vector2.new(barX, barY)
                        espObj.HealthBarOutline.Color = ESPSettings.HealthBarOutlineColor
                        espObj.HealthBarOutline.Visible = true
                    else
                        espObj.HealthBarOutline.Visible = false
                    end

                    -- Health bar rendering with optimized gradient for rainbow
                    if ESPSettings.HealthBarRainbow then
                        -- Use gradient segments for smooth rainbow blend
                        espObj.HealthBar.Visible = false
                        local segs = espObj.HealthBarGradient
                        local maxSegs = #segs
                        local isVertical = (pos == "Left" or pos == "Right")
                        
                        if isVertical then
                            -- Vertical health bar - gradient goes down
                            if fillH <= 0 or fillW <= 0 then
                                for i = 1, maxSegs do segs[i].Visible = false end
                            else
                                local segCount = math.clamp(math.floor(fillH / 2), MIN_GRADIENT_SEGMENTS, math.min(maxSegs, math.floor(fillH)))

                                -- Use EXACT fill dimensions without modification
                                local positions = {}
                                local baseSegH = math.floor(fillH / segCount)
                                local rem = fillH - baseSegH * segCount
                                local used = 0
                                for i = 1, segCount do
                                    local h = baseSegH + (i <= rem and 1 or 0)
                                    positions[i] = { y = fillY + used, h = math.max(1, h) }
                                    used = used + positions[i].h
                                end

                                for i = 1, segCount do
                                    local t = (i - 0.5) / segCount
                                    local segColor = getRainbowColor(baseOffset + t * 0.5, "HealthBar")
                                    segs[i].Size = Vector2.new(math.max(1, fillW), positions[i].h)
                                    segs[i].Position = Vector2.new(fillX, positions[i].y)
                                    segs[i].Color = segColor
                                    segs[i].Transparency = 1
                                    segs[i].Visible = true
                                end

                                for i = segCount + 1, maxSegs do
                                    segs[i].Visible = false
                                end
                            end
                        else
                            -- Horizontal health bar - gradient goes across
                            if fillW <= 0 or fillH <= 0 then
                                for i = 1, maxSegs do segs[i].Visible = false end
                            else
                                local segCount = math.clamp(math.floor(fillW / 2), MIN_GRADIENT_SEGMENTS, math.min(maxSegs, math.floor(fillW)))

                                -- Use EXACT fill dimensions without modification
                                local positions = {}
                                local baseSegW = math.floor(fillW / segCount)
                                local rem = fillW - baseSegW * segCount
                                local used = 0
                                for i = 1, segCount do
                                    local w = baseSegW + (i <= rem and 1 or 0)
                                    positions[i] = { x = fillX + used, w = math.max(1, w) }
                                    used = used + positions[i].w
                                end

                                for i = 1, segCount do
                                    local t = (i - 0.5) / segCount
                                    local segColor = getRainbowColor(baseOffset + t * 0.5, "HealthBar")
                                    segs[i].Size = Vector2.new(positions[i].w, math.max(1, fillH))
                                    segs[i].Position = Vector2.new(positions[i].x, fillY)
                                    segs[i].Color = segColor
                                    segs[i].Transparency = 1
                                    segs[i].Visible = true
                                end

                                for i = segCount + 1, maxSegs do
                                    segs[i].Visible = false
                                end
                            end
                        end
                    else
                        -- Normal health color based on ratio
                        for _, seg in ipairs(espObj.HealthBarGradient) do seg.Visible = false end
                        espObj.HealthBar.Size = Vector2.new(fillW, fillH)
                        espObj.HealthBar.Position = Vector2.new(fillX, fillY)
                        espObj.HealthBar.Color = getHealthColor(ratio)
                        espObj.HealthBar.Visible = true
                    end
            else
                espObj.HealthBar.Visible = false
                    espObj.HealthBarOutline.Visible = false
                    for _, seg in ipairs(espObj.HealthBarGradient) do seg.Visible = false end
                end

            -- Chams/Highlight
            if ESPSettings.Enabled and ESPSettings.Highlight then
                if not espObj.Highlight or espObj.Highlight.Parent ~= char then
                    if espObj.Highlight then pcall(function() espObj.Highlight:Destroy() end) end
                    espObj.Highlight = Instance.new("Highlight")
                    espObj.Highlight.Adornee = char
                    espObj.Highlight.Parent = char
                end
                espObj.Highlight.FillColor = chamColor
                espObj.Highlight.OutlineColor = chamColor
                espObj.Highlight.FillTransparency = ESPSettings.FillTransparency
                espObj.Highlight.OutlineTransparency = ESPSettings.OutlineTransparency
                espObj.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                espObj.Highlight.Enabled = true
            elseif espObj.Highlight then
                espObj.Highlight.Enabled = false
            end
        end)
    end
end

local function addESP(player)
    if not player or player == LocalPlayer or ESPObjects[player] then return end
    local espObj = createESPObject()
    espObj.Player = player
    ESPObjects[player] = espObj
    
    local function onCharAdded(char)
        task.wait(0.2)
        if ESPSettings.Highlight and char then
            if espObj.Highlight then pcall(function() espObj.Highlight:Destroy() end) end
            espObj.Highlight = Instance.new("Highlight")
            espObj.Highlight.Adornee = char
            espObj.Highlight.Parent = char
            espObj.Highlight.FillTransparency = ESPSettings.FillTransparency
            espObj.Highlight.OutlineTransparency = ESPSettings.OutlineTransparency
        end
    end
    
    player.CharacterAdded:Connect(onCharAdded)
    if player.Character then onCharAdded(player.Character) end
end

local function removePlayerESP(player)
    local espObj = ESPObjects[player]
    if not espObj then return end
    removeESP(espObj)
    ESPObjects[player] = nil
end

-- Object ESP System (for non-players)
local function createObjectESPConfig(name, options)
    options = options or {}
    local config = {
        Name = name,
        Enabled = options.Enabled or false,
        Color = options.Color or Color3.fromRGB(255, 255, 0),
        ShowName = options.ShowName ~= false,
        ShowDistance = options.ShowDistance ~= false,
        ShowBox = options.ShowBox ~= false,
        ShowTracer = options.ShowTracer or false,
        MaxDistance = options.MaxDistance or 500,
        Rainbow = options.Rainbow or false,
        Objects = {},
        ESPInstances = {},
        FindFunction = options.FindFunction -- Custom function to find objects
    }
    ObjectESPConfigs[name] = config
    return config
end

local function addObjectToESP(configName, obj, displayName)
    local config = ObjectESPConfigs[configName]
    if not config or not obj then return end
    if config.Objects[obj] then return end
    
    config.Objects[obj] = displayName or obj.Name
    
    local espObj = {
        Name = Drawing.new("Text"),
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Tracer = Drawing.new("Line")
    }
    
    espObj.Name.Center = true
    espObj.Name.Outline = true
    espObj.Name.OutlineColor = Color3.new(0, 0, 0)
    espObj.Name.Size = ESPSettings.TextSize
    espObj.Name.Font = 3
    espObj.Name.Visible = false
    
    espObj.Box.Thickness = 1
    espObj.Box.Filled = false
    espObj.Box.Visible = false
    
    espObj.BoxOutline.Thickness = 3
    espObj.BoxOutline.Filled = false
    espObj.BoxOutline.Color = Color3.new(0, 0, 0)
    espObj.BoxOutline.Visible = false
    
    espObj.Tracer.Thickness = 2
    espObj.Tracer.Visible = false
    
    config.ESPInstances[obj] = espObj
end

local function removeObjectFromESP(configName, obj)
    local config = ObjectESPConfigs[configName]
    if not config then return end
    
    config.Objects[obj] = nil
    local espObj = config.ESPInstances[obj]
    if espObj then
        pcall(function() espObj.Name:Remove() end)
        pcall(function() espObj.Box:Remove() end)
        pcall(function() espObj.BoxOutline:Remove() end)
        pcall(function() espObj.Tracer:Remove() end)
    end
    config.ESPInstances[obj] = nil
end

local function updateObjectESP()
    for configName, config in pairs(ObjectESPConfigs) do
        if config.Enabled and config.FindFunction then
            -- Auto-find objects using custom function
            local foundObjects = config.FindFunction()
            for _, obj in ipairs(foundObjects) do
                if not config.Objects[obj] then
                    addObjectToESP(configName, obj)
                end
            end
        end
        
        for obj, displayName in pairs(config.Objects) do
            local espObj = config.ESPInstances[obj]
            if not espObj then continue end
            
            pcall(function()
                if not config.Enabled or not obj or not obj.Parent then
                    espObj.Name.Visible = false
                    espObj.Box.Visible = false
                    espObj.BoxOutline.Visible = false
                    espObj.Tracer.Visible = false
                    if not obj or not obj.Parent then
                        removeObjectFromESP(configName, obj)
                    end
                    return
                end
                
                local rect = getObjectRect(obj)
                if not rect or rect.distance > config.MaxDistance then
                    espObj.Name.Visible = false
                    espObj.Box.Visible = false
                    espObj.BoxOutline.Visible = false
                    espObj.Tracer.Visible = false
                    return
                end
                
                local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
                local baseOffset = 0
                if rect and vh and vh > 0 then baseOffset = (rect.cy / vh) end
                local color = config.Rainbow and getRainbowColor(baseOffset, "Object") or config.Color
                
                -- Name
                if config.ShowName or config.ShowDistance then
                    local text = {}
                    if config.ShowName then table.insert(text, displayName) end
                    if config.ShowDistance then table.insert(text, math.floor(rect.distance) .. "m") end
                    espObj.Name.Text = table.concat(text, " | ")
                    espObj.Name.Position = Vector2.new(rect.cx, rect.y - 18)
                    espObj.Name.Color = color
                    espObj.Name.Visible = true
                else
                    espObj.Name.Visible = false
                end
                
                -- Box
                if config.ShowBox then
                    espObj.BoxOutline.Size = Vector2.new(rect.w + 2, rect.h + 2)
                    espObj.BoxOutline.Position = Vector2.new(rect.x - 1, rect.y - 1)
                    espObj.BoxOutline.Visible = true
                    
                    espObj.Box.Size = Vector2.new(rect.w, rect.h)
                    espObj.Box.Position = Vector2.new(rect.x, rect.y)
                    espObj.Box.Color = color
                    espObj.Box.Visible = true
                else
                    espObj.Box.Visible = false
                    espObj.BoxOutline.Visible = false
                end
                
                -- Tracer
                if config.ShowTracer then
                    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
                    espObj.Tracer.From = Vector2.new(vw/2, vh)
                    espObj.Tracer.To = Vector2.new(rect.cx, rect.y + rect.h)
                    espObj.Tracer.Color = color
                    espObj.Tracer.Visible = true
                else
                    espObj.Tracer.Visible = false
                end
            end)
        end
    end
end

-- Main render loop
-- FOV Circle drawing objects
local FOVCircleOutline = Drawing.new("Circle")
FOVCircleOutline.Thickness = 1
FOVCircleOutline.NumSides = 64
FOVCircleOutline.Filled = false
FOVCircleOutline.Transparency = 1
FOVCircleOutline.Color = Color3.new(0, 0, 0)
FOVCircleOutline.Visible = false

local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.NumSides = 64
FOVCircle.Filled = false
FOVCircle.Transparency = 1
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Visible = false

local FOVCircleFill = Drawing.new("Circle")
FOVCircleFill.Thickness = 1
FOVCircleFill.NumSides = 64
FOVCircleFill.Filled = true
FOVCircleFill.Transparency = 0.2
FOVCircleFill.Color = Color3.fromRGB(255, 255, 255)
FOVCircleFill.Visible = false

-- Gradient circle segments for FOV (for gradient/rainbow circle outline)
local FOV_GRADIENT_SEGMENTS = 128
local FOVGradientSegments = {}
for i = 1, FOV_GRADIENT_SEGMENTS do
    local seg = Drawing.new("Line")
    seg.Thickness = 1
    seg.Visible = false
    FOVGradientSegments[i] = seg
end

-- Gradient fill segments for FOV circle fill
local FOVFillGradientSegments = {}
for i = 1, FOV_GRADIENT_SEGMENTS do
    local seg = Drawing.new("Triangle")
    seg.Filled = true
    seg.Visible = false
    FOVFillGradientSegments[i] = seg
end

local function updateFOVCircle()
    if not ESPSettings.FOVCircleEnabled then
        FOVCircle.Visible = false
        FOVCircleOutline.Visible = false
        FOVCircleFill.Visible = false
        for _, seg in ipairs(FOVGradientSegments) do seg.Visible = false end
        for _, seg in ipairs(FOVFillGradientSegments) do seg.Visible = false end
        return
    end
    
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local radius = ESPSettings.FOVCircleRadius or 100
    local segments = math.min(ESPSettings.FOVCircleSegments or 128, FOV_GRADIENT_SEGMENTS)
    local thickness = ESPSettings.FOVCircleThickness or 1
    
    -- Determine if we need rainbow for outline
    local useRainbowOutline = ESPSettings.FOVCircleRainbow
    
    if useRainbowOutline then
        -- Hide solid circle, use rainbow segments with improved blending
        FOVCircle.Visible = false
        FOVCircleOutline.Visible = false
        
        for i = 1, segments do
            -- Smooth angle transitions with slight overlap for perfect blending
            local angle1 = ((i - 1) / segments) * math.pi * 2
            local angle2 = (i / segments) * math.pi * 2
            
            local p1 = center + Vector2.new(math.cos(angle1) * radius, math.sin(angle1) * radius)
            local p2 = center + Vector2.new(math.cos(angle2) * radius, math.sin(angle2) * radius)
            
            local seg = FOVGradientSegments[i]
            seg.From = p1
            seg.To = p2
            seg.Thickness = thickness + 0.5  -- Slight thickness increase for better blending
            seg.Transparency = 1 - (ESPSettings.FOVCircleTransparency or 0)
            
            -- Use time-based gradient with smoothstep for clean blending
            local t = i / segments
            seg.Color = getRainbowColor(t, "FOV")
            seg.Visible = true
        end
        
        -- Hide unused segments
        for i = segments + 1, FOV_GRADIENT_SEGMENTS do
            FOVGradientSegments[i].Visible = false
        end
    else
        -- Use solid circle
        for _, seg in ipairs(FOVGradientSegments) do seg.Visible = false end
        
        -- Outline
        FOVCircleOutline.Position = center
        FOVCircleOutline.Radius = radius + 1
        FOVCircleOutline.Thickness = thickness + 2
        FOVCircleOutline.NumSides = segments
        FOVCircleOutline.Color = Color3.new(0, 0, 0)
        FOVCircleOutline.Transparency = 1 - (ESPSettings.FOVCircleTransparency or 0)
        FOVCircleOutline.Visible = true
        
        -- Main circle
        FOVCircle.Position = center
        FOVCircle.Radius = radius
        FOVCircle.Thickness = thickness
        FOVCircle.NumSides = segments
        FOVCircle.Color = ESPSettings.FOVCircleColor
        FOVCircle.Transparency = 1 - (ESPSettings.FOVCircleTransparency or 0)
        FOVCircle.Visible = true
    end
    
    -- Fill circle with improved rendering
    if ESPSettings.FOVCircleFilled then
        if ESPSettings.FOVCircleFillRainbow then
            -- Use triangle segments for rainbow fill with perfect blending
            FOVCircleFill.Visible = false
            
            -- Improved triangle coverage: small angular overlap and slight outer radius expansion
            local overlap = 0.01 -- radians overlap to avoid antialias seams
            local outerR = radius + 1 -- expand slightly so edges overlap cleanly
            for i = 1, segments do
                local angle1 = ((i - 1) / segments) * math.pi * 2 - overlap
                local angle2 = (i / segments) * math.pi * 2 + overlap

                local p1 = center + Vector2.new(math.cos(angle1) * outerR, math.sin(angle1) * outerR)
                local p2 = center + Vector2.new(math.cos(angle2) * outerR, math.sin(angle2) * outerR)

                local seg = FOVFillGradientSegments[i]
                seg.PointA = center
                seg.PointB = p1
                seg.PointC = p2
                seg.Filled = true
                seg.Transparency = 1 - (ESPSettings.FOVCircleFillTransparency or 0.8)

                -- center-based t gives even circular distribution; use mid-angle for color
                local t = (i - 0.5) / segments
                seg.Color = getRainbowColor(t, "FOV")
                seg.Visible = true
            end
            
            -- Hide unused
            for i = segments + 1, FOV_GRADIENT_SEGMENTS do
                FOVFillGradientSegments[i].Visible = false
            end
        else
            -- Solid fill
            for _, seg in ipairs(FOVFillGradientSegments) do seg.Visible = false end
            
            FOVCircleFill.Position = center
            FOVCircleFill.Radius = radius
            FOVCircleFill.NumSides = segments
            FOVCircleFill.Color = ESPSettings.FOVCircleFillColor
            FOVCircleFill.Transparency = 1 - (ESPSettings.FOVCircleFillTransparency or 0.8)
            FOVCircleFill.Filled = true
            FOVCircleFill.Visible = true
        end
    else
        FOVCircleFill.Visible = false
        for _, seg in ipairs(FOVFillGradientSegments) do seg.Visible = false end
    end
end

local function mainUpdate()
    -- advance shared rainbow hue so all rainbow toggles stay in sync
    RainbowHue = (RainbowHue + (ESPSettings.RainbowSpeed or 1) * 0.001) % 1
    updateESP()
    updateObjectESP()
    updateFOVCircle()
end

if renderConn then renderConn:Disconnect() end
renderConn = RunService.RenderStepped:Connect(mainUpdate)

for _, p in ipairs(Players:GetPlayers()) do addESP(p) end
Players.PlayerAdded:Connect(addESP)
Players.PlayerRemoving:Connect(removePlayerESP)

-- ==================== HELPER FUNCTIONS ====================
-- Helper to enable/disable all player ESP visuals immediately
local function setGlobalESPEnabled(enabled)
    ESPSettings.Enabled = enabled
    for player, espObj in pairs(ESPObjects) do
        pcall(function()
            if not enabled then
                hideESP(espObj)
            end
        end)
    end
end

-- Expose API globally for external scripts
getgenv().TrisESP = {
    -- Direct access to settings table - modify any setting directly
    -- Example: getgenv().TrisESP.Settings.Boxes = true
    Settings = ESPSettings,
    
    -- Direct access to object ESP configs
    -- Example: getgenv().TrisESP.ObjectConfigs["Diamond"].Enabled = false
    ObjectConfigs = ObjectESPConfigs,
    
    -- Enable/disable all ESP immediately
    SetEnabled = setGlobalESPEnabled,
    
    -- === PLAYER FILTERING ===
    -- Whitelist a player (only show whitelisted players)
    -- Usage: TrisESP.WhitelistPlayer("PlayerName")
    WhitelistPlayer = function(playerName)
        -- Accept string, Instance (Player/Folder/Model), or table of such
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.WhitelistPlayer(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.WhitelistedEntities[playerName] = true
            return
        end
        if type(playerName) == "string" then
            ESPSettings.WhitelistedPlayers[playerName] = true
            return
        end
    end,
    
    -- Blacklist a player (hide specific players)
    -- Usage: TrisESP.BlacklistPlayer("PlayerName")
    BlacklistPlayer = function(playerName)
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.BlacklistPlayer(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.BlacklistedEntities[playerName] = true
            return
        end
        if type(playerName) == "string" then
            ESPSettings.BlacklistedPlayers[playerName] = true
            return
        end
    end,
    
    -- Remove from whitelist
    RemoveWhitelist = function(playerName)
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.RemoveWhitelist(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.WhitelistedEntities[playerName] = nil
            return
        end
        ESPSettings.WhitelistedPlayers[playerName] = nil
    end,
    
    -- Remove from blacklist
    RemoveBlacklist = function(playerName)
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.RemoveBlacklist(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.BlacklistedEntities[playerName] = nil
            return
        end
        ESPSettings.BlacklistedPlayers[playerName] = nil
    end,
    
    -- Set filter mode: "All", "Whitelist", "Blacklist"
    -- Usage: TrisESP.SetFilterMode("Whitelist")
    SetFilterMode = function(mode)
        ESPSettings.FilterMode = mode
    end,
    
    -- === TEAM CONFIGURATION ===
    -- Enable/disable team check (when enabled, teammates are auto-hidden)
    -- Usage: TrisESP.EnableTeamCheck(true)
    EnableTeamCheck = function(enabled)
        ESPSettings.TeamCheckEnabled = enabled
    end,
    
    -- Set team detection mode: "Auto", "RobloxTeams", "Folder", "Custom"
    -- Usage: TrisESP.SetTeamMode("Folder")
    SetTeamMode = function(mode)
        ESPSettings.TeamDetectionMode = mode
    end,
    
    -- Set custom team folder (for folder-based team detection)
    -- Usage: TrisESP.SetTeamFolder(workspace.Teams)
    SetTeamFolder = function(folder)
        if typeof(folder) == "Instance" and folder:IsA("Folder") then
            ESPSettings.CustomTeamFolder = folder
            ESPSettings.TeamDetectionMode = "Folder"
        end
    end,
    
    -- Set custom team detection function
    -- Usage: TrisESP.SetCustomTeamFunction(function(player1, player2) return player1:GetAttribute("Team") == player2:GetAttribute("Team") end)
    SetCustomTeamFunction = function(func)
        if type(func) == "function" then
            ESPSettings.CustomTeamFunction = func
            ESPSettings.TeamDetectionMode = "Custom"
        end
    end,
    
    -- === TEXT CUSTOMIZATION ===
    -- Add custom text to ESP (super easy!)
    -- Usage: TrisESP.AddTextEntry("Weapon", function(player, char, hum, dist) return "AK-47" end, 4)
    -- Order: 1=Name, 2=Health, 3=Distance, 4+=Custom
    AddTextEntry = function(name, getTextFunc, order)
        ESPSettings.TextEntries[name] = {
            Enabled = true,
            Order = order or 99,
            GetText = getTextFunc  -- function(player, char, humanoid, distance) -> string or nil
        }
    end,
    
    RemoveTextEntry = function(name)
        ESPSettings.TextEntries[name] = nil
    end,
    
    SetTextEntryEnabled = function(name, enabled)
        if ESPSettings.TextEntries[name] then
            ESPSettings.TextEntries[name].Enabled = enabled
        end
    end,
    
    -- Toggle built-in text elements
    -- Usage: TrisESP.ShowName(false)
    ShowName = function(enabled)
        ESPSettings.ShowName = enabled
    end,
    
    ShowHealth = function(enabled)
        ESPSettings.ShowHealthText = enabled
    end,
    
    ShowDistance = function(enabled)
        ESPSettings.ShowDistance = enabled
    end,
    
    -- === OBJECT ESP (SIMPLIFIED) ===
    -- Quick add single object with optional custom name
    -- Usage: TrisESP.AddSimpleObjectESP(workspace.Diamond, "Diamond", {Color = Color3.new(0,1,1), Rainbow = true})
    AddSimpleObjectESP = function(object, displayName, options)
        options = options or {}
        local configName = displayName or object.Name
        
        if not ObjectESPConfigs[configName] then
            createObjectESPConfig(configName, {
                Enabled = true,
                Color = options.Color or Color3.fromRGB(255, 255, 0),
                Rainbow = options.Rainbow or false,
                ShowName = options.ShowName ~= false,
                ShowDistance = options.ShowDistance ~= false,
                ShowBox = options.ShowBox ~= false,
                ShowTracer = options.ShowTracer or false,
                MaxDistance = options.MaxDistance or 500
            })
        end
        
        addObjectToESP(configName, object, displayName)
    end,
    
    -- Remove single object from ESP
    RemoveSimpleObjectESP = function(object, configName)
        removeObjectFromESP(configName, object)
    end,
    
    -- Auto-track objects by name in workspace (super easy!)
    -- Usage: TrisESP.TrackObjectsByName("Diamond", {Color = Color3.new(0,1,1), Rainbow = true})
    TrackObjectsByName = function(objectName, options)
        options = options or {}
        createObjectESPConfig(objectName, {
            Enabled = true,
            Color = options.Color or Color3.fromRGB(255, 255, 0),
            Rainbow = options.Rainbow or false,
            ShowName = options.ShowName ~= false,
            ShowDistance = options.ShowDistance ~= false,
            ShowBox = options.ShowBox ~= false,
            ShowTracer = options.ShowTracer or false,
            MaxDistance = options.MaxDistance or 500,
            FindFunction = function()
                local items = {}
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj.Name == objectName and (obj:IsA("BasePart") or obj:IsA("Model")) then
                        table.insert(items, obj)
                    end
                end
                return items
            end
        })
    end,
    
    -- Track objects in a specific folder
    -- Usage: TrisESP.TrackFolder(workspace.Items, "Items", {Color = Color3.new(1,1,0)})
    TrackFolder = function(folder, configName, options)
        options = options or {}
        configName = configName or folder.Name
        createObjectESPConfig(configName, {
            Enabled = true,
            Color = options.Color or Color3.fromRGB(255, 255, 0),
            Rainbow = options.Rainbow or false,
            ShowName = options.ShowName ~= false,
            ShowDistance = options.ShowDistance ~= false,
            ShowBox = options.ShowBox ~= false,
            ShowTracer = options.ShowTracer or false,
            MaxDistance = options.MaxDistance or 500,
            FindFunction = function()
                local items = {}
                if folder and folder.Parent then
                    for _, obj in ipairs(folder:GetChildren()) do
                        if obj:IsA("BasePart") or obj:IsA("Model") then
                            table.insert(items, obj)
                        end
                    end
                end
                return items
            end
        })
    end,
    
    -- Enable/disable object category
    EnableObjectCategory = function(configName, enabled)
        if ObjectESPConfigs[configName] then
            ObjectESPConfigs[configName].Enabled = enabled
        end
    end,
    
    -- Advanced API (for custom configs)
    CreateObjectConfig = createObjectESPConfig,
    AddObject = addObjectToESP,
    RemoveObject = removeObjectFromESP,
    GetConfigs = function() return ObjectESPConfigs end
}

-- Per-tool image map and helper API
getgenv().TrisESP.ToolImages = {}
getgenv().TrisESP.PlaceToolImages = {}
-- Global tool image
getgenv().TrisESP.SetToolImage = function(toolName, imageData)
    if not toolName then return end
    getgenv().TrisESP.ToolImages[toolName:lower()] = imageData
end
getgenv().TrisESP.RemoveToolImage = function(toolName)
    if not toolName then return end
    getgenv().TrisESP.ToolImages[toolName:lower()] = nil
end
-- Per-place tool images
getgenv().TrisESP.SetToolImageForPlace = function(placeId, toolName, imageData)
    if not placeId or not toolName then return end
    placeId = tostring(placeId)
    getgenv().TrisESP.PlaceToolImages[placeId] = getgenv().TrisESP.PlaceToolImages[placeId] or {}
    getgenv().TrisESP.PlaceToolImages[placeId][toolName:lower()] = imageData
end
getgenv().TrisESP.RemoveToolImageForPlace = function(placeId, toolName)
    if not placeId or not toolName then return end
    placeId = tostring(placeId)
    if getgenv().TrisESP.PlaceToolImages[placeId] then
        getgenv().TrisESP.PlaceToolImages[placeId][toolName:lower()] = nil
    end
end

--[[
    ====================== TrisESP API DOCUMENTATION ======================
    
    QUICK START:
        local ESP = getgenv().TrisESP
        ESP.Settings.Enabled = true
        ESP.Settings.Boxes = true
        ESP.Settings.BoxRainbow = true
    
    SETTINGS (access via ESP.Settings.SETTING_NAME):
        Enabled = true/false                    -- Master toggle
        MaxDistance = 1500                      -- Max render distance
        TextSize = 14                           -- Text size
        
        -- Boxes
        Boxes = true/false                      -- Enable boxes
        BoxType = "Square" / "Corner"           -- Box type
        BoxColor = Color3                       -- Box color
        BoxRainbow = true/false                 -- Rainbow boxes
        Thickness = 3                           -- Line thickness
        BoxFill = true/false                    -- Enable fill
        BoxFillColor = Color3                   -- Fill color
        BoxFillRainbow = true/false             -- Rainbow fill
        BoxFillGradient = true/false            -- Gradient fill
        BoxFillGradientColor1 = Color3          -- Gradient start
        BoxFillGradientColor2 = Color3          -- Gradient end
        BoxFillTransparency = 0.5               -- Fill transparency (0-1)
        
        -- Tracers
        Tracers = true/false                    -- Enable tracers
        TracerColor = Color3                    -- Tracer color
        TracerRainbow = true/false              -- Rainbow tracers
        TracerFrom = "Bottom"/"Top"/"Center"/"Mouse"
        TracerThickness = 2                     -- Tracer thickness
        
        -- Health Bar
        HealthBarEnabled = true/false           -- Enable health bar
        HealthBarPosition = "Left"/"Right"/"Top"/"Bottom"
        HealthBarThickness = 3                  -- Bar thickness
        HealthBarRainbow = true/false           -- Rainbow health bar
        HealthBarOutline = true/false           -- Show outline
        HealthBarOutlineColor = Color3          -- Outline color
        
        -- Chams
        Highlight = true/false                  -- Enable chams
        GlobalChamColor = Color3                -- Chams color
        ChamsRainbow = true/false               -- Rainbow chams
        FillTransparency = 0.5                  -- Fill transparency
        OutlineTransparency = 0                 -- Outline transparency
        
        -- Text
        ShowName = true/false                   -- Show player names
        ShowHealthText = true/false             -- Show health text
        ShowDistance = true/false               -- Show distance
        NameColor = Color3                      -- Name color
        NameRainbow = true/false                -- Rainbow names
        
        -- Equipped Tool
        EquippedEnabled = true/false            -- Show equipped tool
        EquippedMode = "Text" / "Image"         -- Display mode
        EquippedPosition = "Inline" / "Bottom"  -- Position
        
        -- Team (when TeamCheckEnabled = true, teammates are auto-hidden)
        TeamCheckEnabled = true/false           -- Enable team check
        TeamDetectionMode = "Auto"/"RobloxTeams"/"Folder"/"Custom"
        CustomTeamFolder = Folder Instance      -- For Folder mode
        CustomTeamFunction = function(p1, p2)   -- For Custom mode
        
        -- Filtering
        FilterMode = "All" / "Whitelist" / "Blacklist"
        
    OBJECT ESP (access via ESP.ObjectConfigs["name"]):
        ESP.TrackObjectsByName("Diamond", {Color = Color3.new(1,1,0), Rainbow = true})
        ESP.TrackFolder(workspace.Items, "Items", {ShowTracer = true})
        ESP.AddSimpleObjectESP(workspace.Diamond, "Diamond")
        ESP.ObjectConfigs["Diamond"].Enabled = false  -- Disable category
    
    HELPER FUNCTIONS:
        ESP.SetEnabled(true/false)              -- Toggle all ESP
        ESP.EnableTeamCheck(true/false)         -- Toggle team check
        ESP.SetTeamMode("RobloxTeams")          -- Set team detection
        ESP.SetTeamFolder(folder)               -- Set team folder
        ESP.SetCustomTeamFunction(func)         -- Set custom team check
        ESP.WhitelistPlayer("Name")             -- Add to whitelist
        ESP.BlacklistPlayer("Name")             -- Add to blacklist
        ESP.SetFilterMode("Whitelist")          -- Set filter mode
        ESP.AddTextEntry("Label", func, order)  -- Add custom text
    
    =========================================================================
--]]

print("[TrisESP] Loaded successfully - Access via getgenv().TrisESP")
