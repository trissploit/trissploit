--[[
    TrisSploit BloxStrike
    A comprehensive cheat UI for BloxStrike
    
    Tabs: Visuals, Modifications, Settings
--]]


-- Services & locals
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local VirtualInputManager = game:GetService("VirtualInputManager")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer and LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

-- Common constructors/local aliases
local Vector2 = Vector2
local Vector3 = Vector3
local CFrame = CFrame
local Color3 = Color3
local Enum = Enum
local Instance = Instance
local Drawing = Drawing
local task = task

-- Remote library loading (use TrisSploit library if available)
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local okLib, Library = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/trissploit/trissploit/refs/heads/main/library.lua"))()
end)
if not okLib or not Library then
    Library = Library or nil
end
if Library then
    pcall(function() Library.ForceCheckbox = true end)
end

local okTheme, ThemeManager = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/trissploit/trissploit/refs/heads/main/thememanager.lua"))()
end)
if not okTheme then ThemeManager = nil end

local okSave, SaveManager = pcall(function()
    return loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()
end)
if not okSave then SaveManager = nil end

-- Load ESP library
local okESP, TrisESP = pcall(function()
    return loadstring(game:HttpGet("https://raw.githubusercontent.com/trissploit/trissploit/refs/heads/main/esp"))()
end)
if okESP and TrisESP then
    getgenv().TrisESP = TrisESP
else
    TrisESP = nil
end


task.spawn(function()
    task.wait(1)
    if getgenv().TrisESP then
        local charactersFolder = Workspace:FindFirstChild("Characters")
        if charactersFolder then
            getgenv().TrisESP.SetTeamFolder(charactersFolder)
            getgenv().TrisESP.EnableTeamCheck(true)
        end
    end
end)

-- Helper to set ESP settings immediately or queue them until the ESP library is ready
local pendingESPSettings = {}
local function applyPendingESPSettings()
    if getgenv().TrisESP and getgenv().TrisESP.Settings then
        for k, v in pairs(pendingESPSettings) do
            getgenv().TrisESP.Settings[k] = v
        end
        pendingESPSettings = {}
    end
end

local function setESPSetting(key, value)
    if getgenv().TrisESP and getgenv().TrisESP.Settings then
        getgenv().TrisESP.Settings[key] = value
    else
        pendingESPSettings[key] = value
        -- try to apply shortly in background
        task.spawn(function()
            for i = 1, 20 do
                task.wait(0.1)
                if getgenv().TrisESP and getgenv().TrisESP.Settings then
                    applyPendingESPSettings()
                    return
                end
            end
        end)
    end
end



-- ═══════════════════════════════════════════════════════════════════════════
-- CREATE WINDOW
-- ═══════════════════════════════════════════════════════════════════════════

local Window = Library:CreateWindow({
    Title = "TrisSploit BloxStrike",
    Footer = "TrisSploit | BloxStrike | v1.0",
    Icon = "rbxassetid://85419017315177",
    CornerRadius = 0,
    Size = UDim2.fromOffset(620, 500),
    NotifySide = "Right",
    ShowCustomCursor = true,
    Compact = true
})

-- ═══════════════════════════════════════════════════════════════════════════
-- SILENT AIM SYSTEM
-- ═══════════════════════════════════════════════════════════════════════════

local SilentAimSettings = {
    Enabled = false,
    FOV = 100,
    HitPart = "Head",
    -- Visibility check is ON by default. The rage UI toggle can disable it.
    VisibilityCheck = true,
    DisableVisibilityCheck = false
}

local TriggerbotSettings = {
    Enabled = false,
    Delay = 50 -- milliseconds
}

local ModificationSettings = {
    AntiAim = false,
    AntiAimYaw = 0,
    AntiAimPitch = 0,
    AntiAimRoll = 0
}

-- BHop state
-- BHop removed

-- Check if player is on same team as local player (ONLY team check, no visibility/distance)
local function isTeammate(player)
    if player == LocalPlayer then return true end
    
    local charactersFolder = Workspace:FindFirstChild("Characters")
    if not charactersFolder then return false end
    
    local localChar = LocalPlayer.Character
    local targetChar = player.Character
    if not localChar or not targetChar then return false end
    
    -- Find team folders
    local localTeam = nil
    local targetTeam = nil
    
    for _, teamFolder in ipairs(charactersFolder:GetChildren()) do
        if teamFolder:IsA("Folder") then
            if teamFolder:IsAncestorOf(localChar) then
                localTeam = teamFolder
            end
            if teamFolder:IsAncestorOf(targetChar) then
                targetTeam = teamFolder
            end
        end
    end
    
    return localTeam and targetTeam and localTeam == targetTeam
end

-- Get closest player to crosshair within FOV (ONLY team check)
local function getClosestPlayerToCrosshair()
    local closestPlayer = nil
    local closestDistance = SilentAimSettings.FOV
    local screenCenter = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and not isTeammate(player) then
            local character = player.Character
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            local targetPart = character:FindFirstChild(SilentAimSettings.HitPart) or character:FindFirstChild("HumanoidRootPart")
            
            -- Only check: alive + FOV (no visibility/distance checks)
            if humanoid and humanoid.Health > 0 and targetPart then
                local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
                if onScreen then
                    local distance = (Vector2.new(screenPos.X, screenPos.Y) - screenCenter).Magnitude
                    if distance < closestDistance then
                        closestDistance = distance
                        closestPlayer = player
                    end
                end
            end
        end
    end
    
    return closestPlayer
end

-- Get target position for silent aim
local function getTargetPosition(player)
    if player and player.Character then
        local targetPart = player.Character:FindFirstChild(SilentAimSettings.HitPart) or player.Character:FindFirstChild("HumanoidRootPart")
        if targetPart then
            return targetPart.Position, targetPart
        end
    end
    return nil, nil
end

-- Line-of-sight check (visibility). Always on unless disabled by the rage toggle.
local function hasLineOfSight(origin, targetPos, targetPart)
    if not SilentAimSettings.VisibilityCheck then
        return true
    end
    if SilentAimSettings.DisableVisibilityCheck then
        return true
    end

    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Exclude
    params.IgnoreWater = true
    params.FilterDescendantsInstances = { LocalPlayer.Character, Camera }

    local result = workspace:Raycast(origin, (targetPos - origin), params)
    if not result then
        return true
    end

    local hitInst = result.Instance
    if not hitInst then
        return true
    end

    -- If the hit instance is part of the target's model, consider visible
    if targetPart and hitInst:IsDescendantOf(targetPart.Parent) then
        return true
    end

    return false
end

-- Modify bullets to target enemy
local function modifyBullets(data)
    -- Guard to avoid unexpected errors breaking remote hooks
    local ok, err = pcall(function()
        if not SilentAimSettings.Enabled then return end
        if not data or not data.Bullets then return end
        
        local target = getClosestPlayerToCrosshair()
        if not target then return end
        
        local targetPos, targetPart = getTargetPosition(target)
        if not targetPos or not targetPart then return end
        
        local localChar = LocalPlayer.Character
        if not localChar then return end
        
        local rootPart = localChar:FindFirstChild("HumanoidRootPart")
        if not rootPart then return end
        local origin = Camera and Camera.CFrame and Camera.CFrame.Position or rootPart.Position

        -- Ensure visibility before modifying bullets (unless disabled via rage toggle)
        if not hasLineOfSight(origin, targetPos, targetPart) then
            return
        end

        local direction = (targetPos - origin).Unit
        local distance = (targetPos - origin).Magnitude
        
        for _, bullet in ipairs(data.Bullets) do
            bullet.Direction = direction
            bullet.Origin = origin
            bullet.Hits = {{
                Instance = targetPart,
                Position = targetPos,
                Normal = -direction,
                Material = Enum.Material.Plastic.Name,
                Distance = distance,
                Exit = false
            }}
        end
    end)

    if not ok then
        warn("[SilentAim] modifyBullets error: ", tostring(err))
    end
end

-- ═══════════════════════════════════════════════════════════════════════════
-- TRIGGERBOT
-- ═══════════════════════════════════════════════════════════════════════════

local lastTriggerbotShot = 0

local function checkTriggerbot()
    if not TriggerbotSettings.Enabled then return end
    if not LocalPlayer.Character then return end
    
    local mouse = LocalPlayer:GetMouse()
    if not mouse or not mouse.Target then return end
    
    local target = mouse.Target
    local targetChar = target.Parent
    if not targetChar then return end
    
    local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
    if not targetHum or targetHum.Health <= 0 then return end
    
    local targetPlayer = Players:GetPlayerFromCharacter(targetChar)
    if not targetPlayer or targetPlayer == LocalPlayer then return end
    if isTeammate(targetPlayer) then return end
    
    -- Check delay
    local now = tick()
    if now - lastTriggerbotShot < (TriggerbotSettings.Delay / 1000) then return end
    -- Visibility check (no toggle)
    local headPart = targetChar:FindFirstChild(SilentAimSettings.HitPart) or targetChar:FindFirstChild("Head") or targetChar:FindFirstChild("HumanoidRootPart")
    if headPart and Camera then
        local origin = Camera.CFrame.Position
        if not hasLineOfSight(origin, headPart.Position, headPart) then
            return
        end
    end

    -- Trigger shoot
    lastTriggerbotShot = now
    mouse1press()
    task.wait(0.05)
    mouse1release()
end

RunService.RenderStepped:Connect(function()
    if TriggerbotSettings.Enabled then
        checkTriggerbot()
    end
end)

-- ═══════════════════════════════════════════════════════════════════════════
-- MODIFICATIONS (THIRD PERSON, ANTI AIM, SPINBOT)
-- ═══════════════════════════════════════════════════════════════════════════

local spinAngle = 0

RunService.RenderStepped:Connect(function(delta)
    local char = LocalPlayer.Character
    if not char then return end
    
    -- Third Person (attach to invisible part behind head)
    -- Anti Aim
    local rootPart = char:FindFirstChild("HumanoidRootPart")
    if rootPart then
        if ModificationSettings.AntiAim then
            -- Apply configured anti-aim angles (pitch, yaw, roll)
            local yaw = ModificationSettings.AntiAimYaw or 0
            local pitch = ModificationSettings.AntiAimPitch or 0
            local roll = ModificationSettings.AntiAimRoll or 0
            rootPart.CFrame = CFrame.new(rootPart.Position) * CFrame.Angles(math.rad(pitch), math.rad(yaw), math.rad(roll))
        end
    end
end)

-- Hook ByteNet ShootWeapon.Send resiliently (re-applies wrapper if remotes reload)
local function protectShootWeaponPacket(packet)
    if not packet then return end
    -- avoid double-wrapping
    if packet.__silentAimPatched then return end

    local origSend = packet.Send or packet.send
    if not origSend then return end

    local function wrapper(data, ...)
        -- safe modify attempt
        local ok, _ = pcall(modifyBullets, data)
        return origSend(data, ...)
    end

    if packet.Send then packet.Send = wrapper end
    if packet.send then packet.send = wrapper end
    packet.__silentAimPatched = true
    packet.__silentAimOriginal = origSend
end

local function setupByteNetHook()
    task.spawn(function()
        while task.wait(1) do
            local ok, err = pcall(function()
                local Database = ReplicatedStorage:FindFirstChild("Database")
                if not Database then return end
                local Security = Database:FindFirstChild("Security")
                if not Security then return end
                local RemotesModule = Security:FindFirstChild("Remotes")
                if not RemotesModule then return end
                local Remotes = require(RemotesModule)
                if not Remotes or not Remotes.Inventory then return end
                local ShootWeapon = Remotes.Inventory.ShootWeapon
                protectShootWeaponPacket(ShootWeapon)
            end)

            if not ok then
                warn("[SilentAim] ByteNet hook loop error: " .. tostring(err))
            end
        end
    end)
end
setupByteNetHook()

-- Backup: Hook __namecall for any fallback remote calls
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(self, ...)
    local args = {...}
    local method = getnamecallmethod()
    
    if SilentAimSettings.Enabled and (method == "FireServer" or method == "InvokeServer") then
        local success, hasData = pcall(function()
            return args[1] and typeof(args[1]) == "table" and args[1].Bullets
        end)
        
        if success and hasData then
            modifyBullets(args[1])
        end
    end
    
    return oldNamecall(self, unpack(args))
end))

-- Cache for silent aim target (reduces lag)
local cachedTarget = nil
local cacheTime = 0
local CACHE_DURATION = 0.05 -- 50ms cache

local function getCachedTarget()
    local now = tick()
    if now - cacheTime > CACHE_DURATION then
        cachedTarget = getClosestPlayerToCrosshair()
        cacheTime = now
    end
    return cachedTarget
end

-- Hook __index for Mouse properties - helps with client-side prediction
local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if not SilentAimSettings.Enabled then
        return oldIndex(self, key)
    end
    
    local isInstance = typeof(self) == "Instance"
    if not isInstance then
        return oldIndex(self, key)
    end
    
    local isMouse = pcall(function() return self:IsA("Mouse") end)
    if isMouse and self:IsA("Mouse") then
        if key == "Hit" or key == "Target" then
            local target = getCachedTarget()
            if target then
                local targetPos, targetPart = getTargetPosition(target)
                if targetPos and targetPart then
                    if key == "Hit" then
                        return CFrame.new(targetPos)
                    elseif key == "Target" then
                        return targetPart
                    end
                end
            end
        end
    end
    
    return oldIndex(self, key)
end))

-- Strong third-person persistence: set camera in Heartbeat and block Camera property changes while active
-- third-person removed: persistence hooks cleaned up

-- Basic FOV circle for silent aim (controlled by SilentAimSettings)
-- Note: The main FOV circle with rainbow/gradient is in the ESP system
local SilentAimFOVCircle = Drawing.new("Circle")
SilentAimFOVCircle.Thickness = 1
SilentAimFOVCircle.NumSides = 64
SilentAimFOVCircle.Filled = false
SilentAimFOVCircle.Transparency = 1
SilentAimFOVCircle.Color = Color3.fromRGB(255, 255, 255)
SilentAimFOVCircle.Visible = false

local SilentAimShowFOV = false -- Toggle for showing silent aim FOV

RunService.RenderStepped:Connect(function()
    local currentCam = Workspace.CurrentCamera or Camera
    if currentCam then
        Camera = currentCam -- update only when valid
    end

    if SilentAimSettings.Enabled and SilentAimShowFOV then
        -- update position if camera available
        if Camera and Camera.ViewportSize then
            SilentAimFOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
            SilentAimFOVCircle.Radius = SilentAimSettings.FOV
        end
        SilentAimFOVCircle.Visible = true
    else
        SilentAimFOVCircle.Visible = false
    end
end)

-- ═══════════════════════════════════════════════════════════════════════════
-- TABS
-- ═══════════════════════════════════════════════════════════════════════════

local Tabs = {
    Legit = Window:AddTab("Legit", "crosshair"),
    Rage = Window:AddTab("Rage", "crosshair"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Modifications = Window:AddTab("Modifications", "wrench"),
    Settings = Window:AddTab("Settings", "settings")
}

-- ═══════════════════════════════════════════════════════════════════════════
-- LEGIT TAB (SILENT AIM)
-- ═══════════════════════════════════════════════════════════════════════════

local SilentAimBox = Tabs.Legit:AddLeftGroupbox("Silent Aim", "crosshair")

SilentAimBox:AddToggle("SilentAimEnabled", {
    Text = "Enable Silent Aim",
    Default = false,
    Tooltip = "Silently aims at enemies",
    Callback = function(v)
        SilentAimSettings.Enabled = v
    end
})

SilentAimBox:AddSlider("SilentAimFOV", {
    Text = "FOV",
    Min = 10,
    Max = 500,
    Default = 100,
    Rounding = 0,
    Tooltip = "Field of view for silent aim",
    Callback = function(v)
        SilentAimSettings.FOV = v
    end
})

SilentAimBox:AddToggle("ShowSilentAimFOV", {
    Text = "Show FOV Circle",
    Default = false,
    Tooltip = "Display FOV circle for silent aim",
    Callback = function(v)
        SilentAimShowFOV = v
    end
})

SilentAimBox:AddDropdown("HitPart", {
    Text = "Hit Part",
    Values = {"Head", "HumanoidRootPart", "UpperTorso", "LowerTorso"},
    Default = "Head",
    Tooltip = "Which body part to target",
    Callback = function(v)
        SilentAimSettings.HitPart = v
    end
})

local TriggerbotBox = Tabs.Legit:AddRightGroupbox("Triggerbot", "zap")

TriggerbotBox:AddToggle("TriggerbotEnabled", {
    Text = "Enable Triggerbot",
    Default = false,
    Tooltip = "Auto-shoot when aiming at enemy",
    Callback = function(v)
        TriggerbotSettings.Enabled = v
    end
})

TriggerbotBox:AddSlider("TriggerbotDelay", {
    Text = "Delay (MS)",
    Min = 0,
    Max = 500,
    Default = 50,
    Rounding = 0,
    Tooltip = "Delay before shooting in milliseconds",
    Callback = function(v)
        TriggerbotSettings.Delay = v
    end
})

-- ═══════════════════════════════════════════════════════════════════════════
-- VISUALS TAB (ESP)
-- ═══════════════════════════════════════════════════════════════════════════

local ESPMainBox = Tabs.Visuals:AddLeftGroupbox("Main", "eye")
-- Consolidated ESP group (contains Boxes, Tracers, Health, Chams, Text)
local ESPGroup = Tabs.Visuals:AddLeftGroupbox("ESP", "eye")
local ESPBoxBox = ESPGroup
local ESPTracerBox = ESPGroup
local ESPHealthBox = ESPGroup
local ESPChamsBox = ESPGroup
local ESPTextBox = ESPGroup
local ESPFOVBox = Tabs.Visuals:AddRightGroupbox("FOV Circle", "circle")

-- ESP Main
ESPMainBox:AddToggle("ESPEnabled", {
    Text = "Enable ESP",
    Default = false,
    Callback = function(v)
        setESPSetting("Enabled", v)
    end
})

ESPMainBox:AddSlider("ESPMaxDistance", {
    Text = "Max Distance",
    Min = 100,
    Max = 5000,
    Default = 1500,
    Rounding = 0,
    Callback = function(v)
        setESPSetting("MaxDistance", v)
    end
})

ESPMainBox:AddToggle("TeamCheck", {
    Text = "Team Check",
    Default = false,
    Callback = function(v)
        setESPSetting("TeamCheckEnabled", v)
    end
})

-- Box Settings
local BoxToggle = ESPBoxBox:AddToggle("ESPBoxes", {
    Text = "Enable Boxes",
    Default = true,
    Callback = function(v)
        setESPSetting("Boxes", v)
    end
})

-- Dependency box for Boxes options (shown when Boxes enabled)
local BoxDep = ESPBoxBox:AddDependencyBox()
BoxDep:SetupDependencies({{BoxToggle, true}})

-- Box gradient pickers (attached to the Boxes toggle)
BoxToggle:AddColorPicker("BoxGradColor1", {
    Title = "Box Color 1",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c)
        setESPSetting("BoxCustomColor1", c)
    end
})
BoxToggle:AddColorPicker("BoxGradColor2", {
    Title = "Box Color 2",
    Default = Color3.fromRGB(255, 165, 0),
    Callback = function(c)
        setESPSetting("BoxCustomColor2", c)
    end
})
BoxToggle:AddColorPicker("BoxGradColor3", {
    Title = "Box Color 3",
    Default = Color3.fromRGB(0, 0, 255),
    Callback = function(c)
        setESPSetting("BoxCustomColor3", c)
    end
})

BoxDep:AddToggle("BoxRainbow", {
    Text = "Rainbow Box",
    Default = false,
    Callback = function(v)
        setESPSetting("BoxRainbow", v)
    end
})

BoxDep:AddDropdown("BoxType", {
    Text = "Box Type",
    Values = {"Square", "Corner"},
    Default = "Square",
    Callback = function(v)
        setESPSetting("BoxType", v)
    end
})

-- Box thickness is now hardcoded to 2
-- Box Fill (independent from Box ESP)
local FillToggle = ESPBoxBox:AddToggle("BoxFill", {
    Text = "Enable Box Fill",
    Default = false,
    Callback = function(v)
        setESPSetting("BoxFill", v)
    end
})

-- Dependency box for Fill options
local FillDep = ESPBoxBox:AddDependencyBox()
FillDep:SetupDependencies({{FillToggle, true}})

-- Fill gradient pickers (separate from box outline colors)
FillToggle:AddColorPicker("FillGradColor1", {
    Title = "Fill Color 1",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c)
        setESPSetting("BoxFillCustomColor1", c)
    end
})
FillToggle:AddColorPicker("FillGradColor2", {
    Title = "Fill Color 2",
    Default = Color3.fromRGB(255, 165, 0),
    Callback = function(c)
        setESPSetting("BoxFillCustomColor2", c)
    end
})
FillToggle:AddColorPicker("FillGradColor3", {
    Title = "Fill Color 3",
    Default = Color3.fromRGB(0, 0, 255),
    Callback = function(c)
        setESPSetting("BoxFillCustomColor3", c)
    end
})

FillDep:AddToggle("BoxFillRainbow", {
    Text = "Rainbow Fill",
    Default = false,
    Callback = function(v)
        setESPSetting("BoxFillRainbow", v)
    end
})

FillDep:AddSlider("BoxFillTransparency", {
    Text = "Fill Transparency",
    Min = 0,
    Max = 1,
    Default = 0.5,
    Rounding = 2,
    Callback = function(v)
        setESPSetting("BoxFillTransparency", v)
    end
})

-- Tracer Settings
local TracerToggle = ESPTracerBox:AddToggle("ESPTracers", {
    Text = "Enable Tracers",
    Default = false,
    Callback = function(v)
        setESPSetting("Tracers", v)
    end
})

-- Tracer color now controlled by the Tracers toggle gradient pickers

-- Dependency box for Tracers options
local TracerDep = ESPTracerBox:AddDependencyBox()
TracerDep:SetupDependencies({{TracerToggle, true}})

-- Tracer gradient pickers (attached to the Tracers toggle)
TracerToggle:AddColorPicker("TracerGradColor1", {
    Title = "Tracer Color 1",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c)
        setESPSetting("TracerCustomColor1", c)
    end
})
TracerToggle:AddColorPicker("TracerGradColor2", {
    Title = "Tracer Color 2",
    Default = Color3.fromRGB(255, 165, 0),
    Callback = function(c)
        setESPSetting("TracerCustomColor2", c)
    end
})
TracerToggle:AddColorPicker("TracerGradColor3", {
    Title = "Tracer Color 3",
    Default = Color3.fromRGB(0, 0, 255),
    Callback = function(c)
        setESPSetting("TracerCustomColor3", c)
    end
})

TracerDep:AddToggle("TracerRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(v)
        setESPSetting("TracerRainbow", v)
    end
})

TracerDep:AddDropdown("TracerFrom", {
    Text = "Tracer Origin",
    Values = {"Bottom", "Top", "Center", "Mouse"},
    Default = "Bottom",
    Callback = function(v)
        setESPSetting("TracerFrom", v)
    end
})

TracerDep:AddSlider("TracerThickness", {
    Text = "Thickness",
    Min = 1,
    Max = 5,
    Default = 2,
    Rounding = 0,
    Callback = function(v)
        setESPSetting("TracerThickness", v)
    end
})

-- Health Bar Settings
local HealthToggle = ESPHealthBox:AddToggle("ESPHealthBar", {
    Text = "Enable Health Bar",
    Default = true,
    Callback = function(v)
        setESPSetting("HealthBarEnabled", v)
    end
})
-- Dependency box for Health Bar options
local HealthDep = ESPHealthBox:AddDependencyBox()
HealthDep:SetupDependencies({{HealthToggle, true}})

HealthDep:AddToggle("HealthBarRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(v)
        setESPSetting("HealthBarRainbow", v)
    end
})

-- Health gradient pickers (attached to the Health toggle)
HealthToggle:AddColorPicker("HealthGradColor1", {
    Title = "Health Color 1",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c)
        setESPSetting("HealthBarCustomColor1", c)
    end
})
HealthToggle:AddColorPicker("HealthGradColor2", {
    Title = "Health Color 2",
    Default = Color3.fromRGB(255, 165, 0),
    Callback = function(c)
        setESPSetting("HealthBarCustomColor2", c)
    end
})
HealthToggle:AddColorPicker("HealthGradColor3", {
    Title = "Health Color 3",
    Default = Color3.fromRGB(0, 0, 255),
    Callback = function(c)
        setESPSetting("HealthBarCustomColor3", c)
    end
})

HealthDep:AddDropdown("HealthBarPosition", {
    Text = "Position",
    Values = {"Left", "Right", "Top", "Bottom"},
    Default = "Left",
    Callback = function(v)
        setESPSetting("HealthBarPosition", v)
    end
})

HealthDep:AddSlider("HealthBarThickness", {
    Text = "Thickness",
    Min = 2,
    Max = 10,
    Default = 3,
    Rounding = 0,
    Callback = function(v)
        setESPSetting("HealthBarThickness", v)
    end
})

local OutlineToggle = HealthDep:AddToggle("HealthBarOutline", {
    Text = "Outline",
    Default = true,
    Callback = function(v)
        setESPSetting("HealthBarOutline", v)
    end
})

-- Outline color (inside dependency)
HealthDep:AddLabel("Outline Color"):AddColorPicker("HealthOutlineColor", {
    Title = "Outline Color",
    Default = Color3.new(0, 0, 0),
    Callback = function(c)
        setESPSetting("HealthBarOutlineColor", c)
    end
})

-- Health text now lives under Health Dep (always positioned above the health fill)
local HealthTextToggle = HealthDep:AddToggle("ShowHealthText", {
    Text = "Enable Health Text",
    Default = true,
    Callback = function(v)
        setESPSetting("ShowHealthText", v)
    end
})

-- Health text gradient pickers
HealthTextToggle:AddColorPicker("HealthTextGradColor1", {
    Title = "Health Text Color 1",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("HealthTextCustomColor1", c)
    end
})
HealthTextToggle:AddColorPicker("HealthTextGradColor2", {
    Title = "Health Text Color 2",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("HealthTextCustomColor2", c)
    end
})
HealthTextToggle:AddColorPicker("HealthTextGradColor3", {
    Title = "Health Text Color 3",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("HealthTextCustomColor3", c)
    end
})

-- Rainbow toggle for health text belongs to dependency box (kept inside HealthDep)
HealthDep:AddToggle("HealthTextRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(v)
        setESPSetting("HealthTextRainbow", v)
    end
})

-- Chams Settings
local ChamsToggle = ESPChamsBox:AddToggle("ESPChams", {
    Text = "Enable Chams",
    Default = false,
    Callback = function(v)
        setESPSetting("Highlight", v)
    end
})

-- Chams color now controlled by the Chams toggle gradient pickers
-- Attach 3-color gradient pickers to the Chams toggle

-- Dependency box for Chams options
local ChamsDep = ESPChamsBox:AddDependencyBox()
ChamsDep:SetupDependencies({{ChamsToggle, true}})

-- Chams gradient pickers (attached to the Chams toggle)
ChamsToggle:AddColorPicker("ChamsGradColor1", {
    Title = "Chams Color 1",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c)
        setESPSetting("ChamsCustomColor1", c)
    end
})
ChamsToggle:AddColorPicker("ChamsGradColor2", {
    Title = "Chams Color 2",
    Default = Color3.fromRGB(255, 165, 0),
    Callback = function(c)
        setESPSetting("ChamsCustomColor2", c)
    end
})
ChamsToggle:AddColorPicker("ChamsGradColor3", {
    Title = "Chams Color 3",
    Default = Color3.fromRGB(0, 0, 255),
    Callback = function(c)
        setESPSetting("ChamsCustomColor3", c)
    end
})

ChamsDep:AddToggle("ChamsRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(v)
        setESPSetting("ChamsRainbow", v)
    end
})

ChamsDep:AddSlider("ChamsFillTransparency", {
    Text = "Fill Transparency",
    Min = 0,
    Max = 1,
    Default = 0.5,
    Rounding = 2,
    Callback = function(v)
        setESPSetting("FillTransparency", v)
    end
})

ChamsDep:AddSlider("ChamsOutlineTransparency", {
    Text = "Outline Transparency",
    Min = 0,
    Max = 1,
    Default = 0,
    Rounding = 2,
    Callback = function(v)
        setESPSetting("OutlineTransparency", v)
    end
})

-- Text ESP Settings - Individual toggles with dependency boxes
local NameToggle = ESPTextBox:AddToggle("ShowName", {
    Text = "Enable Name",
    Default = true,
    Callback = function(v)
        setESPSetting("ShowName", v)
    end
})

-- Name gradient pickers
NameToggle:AddColorPicker("NameGradColor1", {
    Title = "Name Color 1",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("NameCustomColor1", c)
    end
})
NameToggle:AddColorPicker("NameGradColor2", {
    Title = "Name Color 2",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("NameCustomColor2", c)
    end
})
NameToggle:AddColorPicker("NameGradColor3", {
    Title = "Name Color 3",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("NameCustomColor3", c)
    end
})

-- Name dependency box
local NameDep = ESPTextBox:AddDependencyBox()
NameDep:SetupDependencies({{NameToggle, true}})

NameDep:AddDropdown("NamePosition", {
    Text = "Position",
    Values = {"Top", "Bottom", "Left", "Right"},
    Default = "Top",
    Callback = function(v)
        setESPSetting("NamePosition", v)
    end
})

NameDep:AddToggle("NameRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(v)
        setESPSetting("NameRainbow", v)
    end
})

NameDep:AddToggle("UseDisplayName", {
    Text = "Use Display Name",
    Default = false,
    Callback = function(v)
        setESPSetting("UseDisplayName", v)
    end
})

-- Font selection
NameDep:AddDropdown("TextFont", {
    Text = "Font",
    Values = {"Legacy", "Arial", "SourceSans", "ProggyClean"},
    Default = "SourceSans",
    Callback = function(v)
        local fontMap = {Legacy = 0, Arial = 1, SourceSans = 2, ProggyClean = 3}
        setESPSetting("TextFont", fontMap[v] or 2)
    end
})

-- Health text is now part of Health Bar options (moved below)

-- Distance text
local DistanceToggle = ESPTextBox:AddToggle("ShowDistance", {
    Text = "Enable Distance",
    Default = true,
    Callback = function(v)
        setESPSetting("ShowDistance", v)
    end
})

-- Distance gradient pickers
DistanceToggle:AddColorPicker("DistanceGradColor1", {
    Title = "Distance Text Color 1",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("DistanceCustomColor1", c)
    end
})
DistanceToggle:AddColorPicker("DistanceGradColor2", {
    Title = "Distance Text Color 2",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("DistanceCustomColor2", c)
    end
})
DistanceToggle:AddColorPicker("DistanceGradColor3", {
    Title = "Distance Text Color 3",
    Default = Color3.fromRGB(255, 255, 255),
    Callback = function(c)
        setESPSetting("DistanceCustomColor3", c)
    end
})

-- Distance dependency box
local DistanceDep = ESPTextBox:AddDependencyBox()
DistanceDep:SetupDependencies({{DistanceToggle, true}})

DistanceDep:AddDropdown("DistancePosition", {
    Text = "Position",
    Values = {"Top", "Bottom", "Left", "Right"},
    Default = "Top",
    Callback = function(v)
        setESPSetting("DistancePosition", v)
    end
})

DistanceDep:AddToggle("DistanceRainbow", {
    Text = "Rainbow",
    Default = false,
    Callback = function(v)
        setESPSetting("DistanceRainbow", v)
    end
})

-- ═══════════════════════════════════════════════════════════════════════════
-- FOV CIRCLE SETTINGS
-- ═══════════════════════════════════════════════════════════════════════════

local FOVToggle = ESPFOVBox:AddToggle("FOVCircleEnabled", {
    Text = "Enable FOV Circle",
    Default = false,
    Callback = function(v)
        setESPSetting("FOVCircleEnabled", v)
    end
})

-- FOV circle color now controlled by the FOV toggle gradient pickers

-- Attach 3-color gradient pickers to the FOV toggle
FOVToggle:AddColorPicker("FOVGradColor1", {
    Title = "FOV Color 1",
    Default = Color3.fromRGB(255, 0, 0),
    Callback = function(c)
        setESPSetting("FOVCustomColor1", c)
    end
})
FOVToggle:AddColorPicker("FOVGradColor2", {
    Title = "FOV Color 2",
    Default = Color3.fromRGB(255, 165, 0),
    Callback = function(c)
        setESPSetting("FOVCustomColor2", c)
    end
})
FOVToggle:AddColorPicker("FOVGradColor3", {
    Title = "FOV Color 3",
    Default = Color3.fromRGB(0, 0, 255),
    Callback = function(c)
        setESPSetting("FOVCustomColor3", c)
    end
})

ESPFOVBox:AddSlider("FOVCircleRadius", {
    Text = "Radius",
    Min = 10,
    Max = 500,
    Default = 100,
    Rounding = 0,
    Callback = function(v)
        setESPSetting("FOVCircleRadius", v)
    end
})

ESPFOVBox:AddSlider("FOVCircleThickness", {
    Text = "Thickness",
    Min = 1,
    Max = 10,
    Default = 1,
    Rounding = 0,
    Callback = function(v)
        setESPSetting("FOVCircleThickness", v)
    end
})

ESPFOVBox:AddSlider("FOVCircleTransparency", {
    Text = "Transparency",
    Min = 0,
    Max = 1,
    Default = 0,
    Rounding = 2,
    Callback = function(v)
        setESPSetting("FOVCircleTransparency", v)
    end
})

ESPFOVBox:AddToggle("FOVCircleRainbow", {
    Text = "Rainbow Outline",
    Default = false,
    Callback = function(v)
        setESPSetting("FOVCircleRainbow", v)
    end
})

ESPFOVBox:AddDivider()

local FOVFillToggle = ESPFOVBox:AddToggle("FOVCircleFilled", {
    Text = "Enable FOV Fill",
    Default = false,
    Callback = function(v)
        setESPSetting("FOVCircleFilled", v)
    end
})

-- Dependency box for FOV fill options
local FOVFillDep = ESPFOVBox:AddDependencyBox()
FOVFillDep:SetupDependencies({{FOVFillToggle, true}})

FOVFillDep:AddSlider("FOVFillTransparency", {
    Text = "Fill Transparency",
    Min = 0,
    Max = 1,
    Default = 0.8,
    Rounding = 2,
    Callback = function(v)
        setESPSetting("FOVCircleFillTransparency", v)
    end
})

FOVFillDep:AddToggle("FOVFillRainbow", {
    Text = "Rainbow Fill",
    Default = false,
    Callback = function(v)
        setESPSetting("FOVCircleFillRainbow", v)
    end
})

-- ═══════════════════════════════════════════════════════════════════════════
-- MODIFICATIONS TAB
-- ═══════════════════════════════════════════════════════════════════════════

local CharacterBox = Tabs.Modifications:AddLeftGroupbox("Anti-Aim", "user")

CharacterBox:AddDivider()

CharacterBox:AddToggle("AntiAimEnable", {
    Text = "Enable Anti-Aim",
    Default = false,
    Callback = function(v)
        ModificationSettings.AntiAim = v
    end
})

CharacterBox:AddSlider("AntiAimYaw", {
    Text = "Anti Aim Yaw",
    Min = -180,
    Max = 180,
    Default = 0,
    Rounding = 0,
    Tooltip = "Yaw angle in degrees",
    Callback = function(v)
        ModificationSettings.AntiAimYaw = v
    end
})

CharacterBox:AddSlider("AntiAimPitch", {
    Text = "Anti Aim Pitch",
    Min = -90,
    Max = 90,
    Default = 0,
    Rounding = 0,
    Tooltip = "Pitch angle in degrees",
    Callback = function(v)
        ModificationSettings.AntiAimPitch = v
    end
})

CharacterBox:AddSlider("AntiAimRoll", {
    Text = "Anti Aim Roll",
    Min = -180,
    Max = 180,
    Default = 0,
    Rounding = 0,
    Tooltip = "Roll angle in degrees",
    Callback = function(v)
        ModificationSettings.AntiAimRoll = v
    end
})

-- BHop groupbox (moved out of Character)
-- BHop UI removed

-- Rage / Bullet manipulation settings
local BulletBox = Tabs.Rage:AddLeftGroupbox("Wallbang", "tool")
local WallbangToggle = BulletBox:AddToggle("DisableVisibilityCheck", {
    Text = "Enable Wallbang",
    Default = false,
    Callback = function(v)
        SilentAimSettings.DisableVisibilityCheck = v
    end
})

-- ═══════════════════════════════════════════════════════════════════════════
-- SETTINGS TAB
-- ═══════════════════════════════════════════════════════════════════════════

local UISettingsBox = Tabs.Settings:AddLeftGroupbox("UI Settings", "settings")

UISettingsBox:AddToggle("ToggleSound", {
    Text = "Toggle Sound",
    Default = true,
    Callback = function(v)
        if v then
            local s = Instance.new("Sound")
            s.SoundId = "rbxassetid://6895079853"
            s.Volume = 0.3
            s.Parent = SoundService
            s:Play()
            s.Ended:Wait()
            s:Destroy()
        end
    end
})

UISettingsBox:AddToggle("NotifySound", {
    Text = "Notification Sound",
    Default = true,
    Callback = function(v)
        if v then
            local s = Instance.new("Sound")
            s.SoundId = "rbxassetid://9086208311"
            s.Volume = 0.3
            s.Parent = SoundService
            s:Play()
            s.Ended:Wait()
            s:Destroy()
        end
    end
})

UISettingsBox:AddDivider()

UISettingsBox:AddToggle("Watermark", {
    Text = "Watermark",
    Default = Library.Watermark or false,
    Callback = function(v)
        Library.Watermark = v
    end
})

-- ═══════════════════════════════════════════════════════════════════════════
-- MAIN LOOPS
-- ═══════════════════════════════════════════════════════════════════════════

-- Infinite Jump
UserInputService.JumpRequest:Connect(function()
    if InfiniteJump then
        local char = LocalPlayer.Character
        if char then
            local hum = char:FindFirstChildOfClass("Humanoid")
            if hum then hum:ChangeState(Enum.HumanoidStateType.Jumping) end
        end
    end
end)

-- NoClip Loop
RunService.Stepped:Connect(function()
    if NoClip then
        local char = LocalPlayer.Character
        if char then
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end
    end
end)

-- BHop: when enabled and Space held, behave according to selected mode
-- BHop runtime removed

-- ═══════════════════════════════════════════════════════════════════════════
-- THEME MANAGER & SAVE MANAGER
-- ═══════════════════════════════════════════════════════════════════════════

if ThemeManager then 
    pcall(function()
        ThemeManager:SetLibrary(Library)
        ThemeManager:SetDefaultTheme({
            FontColor = Color3.fromRGB(220, 220, 220),
            MainColor = Color3.fromRGB(25, 25, 25),
            AccentColor = Color3.fromRGB(180, 180, 180),
            BackgroundColor = Color3.fromRGB(10, 10, 10),
            OutlineColor = Color3.fromRGB(40, 40, 40),
            FontFace = "Gotham"
        })
        ThemeManager:ApplyToTab(Tabs.Settings)
    end) 
end

if SaveManager then
    pcall(function()
        SaveManager:SetLibrary(Library)
        SaveManager:SetFolder("TrisSploit/BloxStrike")
        SaveManager:BuildConfigSection(Tabs.Settings)
        SaveManager:LoadAutoloadConfig()
    end)
end

-- ═══════════════════════════════════════════════════════════════════════════
-- LOAD NOTIFICATION
-- ═══════════════════════════════════════════════════════════════════════════

Library:Notify("TrisSploit BloxStrike loaded successfully!", 5)
print("[TrisSploit BloxStrike] Loaded - Access ESP via getgenv().TrisESP")
