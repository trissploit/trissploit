--[[
    TrisESP - ScreenGui ESP System
    
    Complete rewrite using ScreenGui instead of Drawing.new
    Includes rotation animation and vertical gradients
    
    Load via: loadstring(game:HttpGet("YOUR_URL_HERE"))()
--]]

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local Teams = game:GetService("Teams")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local renderConn

local ESPObjects = {}
local RotationAngle = -90
-- Persistent state across hot-reloads (if executor preserves getgenv)
getgenv()._TrisESP_Persistent = getgenv()._TrisESP_Persistent or {}
local PERSIST = getgenv()._TrisESP_Persistent
PERSIST.HealthPhase = PERSIST.HealthPhase or {}
PERSIST.GradientAngle = PERSIST.GradientAngle or {}
PERSIST.SpinAngle = PERSIST.SpinAngle or RotationAngle


-- Create ScreenGui holder
local ESPHolder = Instance.new("ScreenGui")
ESPHolder.Name = "TrisESPHolder"
ESPHolder.ResetOnSpawn = false
ESPHolder.IgnoreGuiInset = true
pcall(function()
    ESPHolder.Parent = CoreGui
end)
if not ESPHolder.Parent then
    ESPHolder.Parent = LocalPlayer:WaitForChild("PlayerGui")
end

local ESPSettings = {
    Enabled = true,
    MaxDistance = 1500,
    
    PlayerOverrides = {},
    
    -- Box animation settings
    AnimateBoxRotation = true,
    BoxRotationSpeed = 300,
    
    -- Filtering
    FilterMode = "All",
    WhitelistedPlayers = {},
    BlacklistedPlayers = {},
    TeamCheckEnabled = false,
    -- Custom team filters (strings = team names, objects = Team instances)
    CustomTeams = {},
    CustomTeamObjects = {},
    -- Automatically add players at startup (false = only add explicitly or by team mappings)
    AutoAddPlayers = false,
    -- Team color mappings: list of { ref = <teamRef>, color = Color3 }
    TeamColorMap = {},
    
    -- Display settings
    ShowName = true,
    -- Name display mode: "Name" | "DisplayName" | "Both"
    -- "Name" shows the Roblox username, "DisplayName" shows the player's display name,
    -- "Both" shows `DisplayName (Name)`
    NameMode = "DisplayName",
    ShowHealthText = true,
    ShowDistance = true,
    
    -- Gradient settings (autorotate enabled internally)
    -- NOTE: UI gradient autorotation is handled internally; GUI animation controls removed

    
    -- Custom colors (3-stop gradients)
    BoxCustomColor1 = Color3.fromRGB(255, 0, 0),
    BoxCustomColor2 = Color3.fromRGB(0, 255, 55),
    BoxCustomColor3 = Color3.fromRGB(0, 0, 255),
    
    BoxFillCustomColor1 = Color3.fromRGB(68, 0, 255),
    BoxFillCustomColor2 = Color3.fromRGB(0, 255, 76),
    BoxFillCustomColor3 = Color3.fromRGB(255, 0, 212),
    
    -- Box settings
    Boxes = true,
    BoxType = "Square",
    BoxColor = Color3.fromRGB(0, 170, 255),
    Thickness = 2,
    BoxOutlineColor = Color3.new(0, 0, 0),
    
    -- Box fill
    BoxFill = true,
    BoxFillColor = Color3.fromRGB(0, 170, 255),
    BoxFillTransparency = 0.5,
    
    -- Tracers
    Tracers = false,
    TracerFrom = "Bottom",
    TracerThickness = 2,
    TracerColor = Color3.fromRGB(0, 170, 255),
    
    -- Health bar
    HealthBarEnabled = true,
    HealthBarPosition = "Left",
    HealthBarThickness = 2.5,
    -- Health bar custom gradient (3 stops)
    HealthBarColor1 = Color3.fromRGB(255, 0, 0),
    HealthBarColor2 = Color3.fromRGB(38, 0, 255),
    HealthBarColor3 = Color3.fromRGB(0, 255, 0),
    -- Health gradient animation speed (cycles per second)
    HealthGradientSpeed = 0.5,
    -- Enable animated health gradient
    HealthGradientEnabled = true,
    -- Number of samples used when building the animated gradient (fixed default)
    -- (setting removed; defaults to 12 samples)
    -- Health gradient blending: "linear" | "smooth" | "ease"
    -- "smooth" uses smoothstep, "ease" uses cosine ease in/out
    HealthGradientBlend = "linear",
    -- Whether the healthbar outline thickness scales with the filled height
    HealthOutlineFollow = false,
    
    -- Chams
    Highlight = true,
    GlobalChamColor = Color3.fromRGB(0, 170, 255),
    FillTransparency = 0.5,
    OutlineTransparency = 0,
}

-- Spin integrator & constants
local AUTOROTATE_SPEED = 60 -- degrees per second for fill gradient
local SpinAngle = PERSIST.SpinAngle or RotationAngle -- persistent integrated angle
local MAX_DT = 0.01 -- cap delta to avoid huge single-frame jumps (seconds)

-- Utility functions
-- rainbow removed

local function createGradientSequence(color1, color2, color3)
    return ColorSequence.new{
        ColorSequenceKeypoint.new(0, color1),
        ColorSequenceKeypoint.new(0.5, color2),
        ColorSequenceKeypoint.new(1, color3)
    }
end



local function lerpColor(c1, c2, t)
    return Color3.new(
        c1.R + (c2.R - c1.R) * t,
        c1.G + (c2.G - c1.G) * t,
        c1.B + (c2.B - c1.B) * t
    )
end

local function getHealthColor(ratio)
    if ratio > 0.75 then
        return Color3.fromRGB(0, 255, 0)
    elseif ratio > 0.5 then
        return Color3.fromRGB(255, 255, 0)
    elseif ratio > 0.25 then
        return Color3.fromRGB(255, 170, 0)
    else
        return Color3.fromRGB(255, 0, 0)
    end
end

local function isSameTeam(player1, player2)
    if not player1 or not player2 or player1 == player2 then return false end
    if player1.Team and player2.Team then
        return player1.Team == player2.Team
    end
    return false
end

local function shouldShowPlayer(player)
    if not player or player == LocalPlayer then return false end
    if ESPSettings.TeamCheckEnabled then
        -- hide teammates (standard behaviour)
        if isSameTeam(player, LocalPlayer) then
            return false
        end
        -- hide players on any configured custom team names
        if player.Team then
            for _, tname in ipairs(ESPSettings.CustomTeams or {}) do
                if tostring(player.Team.Name) == tostring(tname) then
                    return false
                end
            end
                -- hide players on any configured team objects (support many types)
                for _, tobj in ipairs(ESPSettings.CustomTeamObjects or {}) do
                    -- direct Team instance
                    if typeof and typeof(tobj) == "Instance" and tobj:IsA("Team") then
                        if player.Team == tobj then return false end
                    end
                    -- if tobj is a Folder/Container with children named after players or containing values
                    if typeof and typeof(tobj) == "Instance" then
                        if tobj:FindFirstChild(player.Name) then return false end
                        -- check for ObjectValue/StringValue children referencing player
                        for _, child in ipairs(tobj:GetChildren()) do
                            if child:IsA("ObjectValue") and child.Value == player then return false end
                            if child:IsA("StringValue") and child.Value == player.Name then return false end
                        end
                    end
                    -- if tobj is a plain table (list of players/names/ids)
                    if type(tobj) == "table" then
                        for _, v in ipairs(tobj) do
                            if v == player or v == player.UserId or v == player.Name then return false end
                        end
                    end
                    -- if tobj is a number (userid)
                    if type(tobj) == "number" and tobj == player.UserId then return false end
                    -- if tobj is a string (team name) handled earlier in CustomTeams loop
                end
        end
    end
    return true
end

-- Helper to match a teamRef (string/Instance/table/number) against a player
local function matchTeamRef(teamRef, player)
    if not teamRef or not player then return false end
    -- Team instance
    if typeof and typeof(teamRef) == "Instance" and teamRef:IsA("Team") then
        return player.Team == teamRef
    end
    -- string team name
    if type(teamRef) == "string" then
        if player.Team and tostring(player.Team.Name) == tostring(teamRef) then return true end
        return false
    end
    -- folder/instance containing player name/value
    if typeof and typeof(teamRef) == "Instance" then
        if teamRef:FindFirstChild(player.Name) then return true end
        for _, child in ipairs(teamRef:GetChildren()) do
            if child:IsA("ObjectValue") and child.Value == player then return true end
            if child:IsA("StringValue") and child.Value == player.Name then return true end
        end
    end
    -- table/list
    if type(teamRef) == "table" then
        for _, v in ipairs(teamRef) do
            if v == player or v == player.UserId or v == player.Name then return true end
        end
    end
    -- number userId
    if type(teamRef) == "number" and teamRef == player.UserId then return true end
    return false
end

-- Return a Color3 if the player matches a TeamColorMap entry
local function getTeamColor(player)
    if not ESPSettings.TeamColorMap then return nil end
    for _, entry in ipairs(ESPSettings.TeamColorMap) do
        local ref = entry.ref
        local col = entry.color
        if matchTeamRef(ref, player) then
            return col
        end
    end
    return nil
end

-- Determine whether we should create an ESP object for this player at startup/add
local function needsESP(player)
    if not player or player == LocalPlayer then return false end
    -- explicit player overrides
    if ESPSettings.PlayerOverrides then
        if ESPSettings.PlayerOverrides[tostring(player.UserId)] or ESPSettings.PlayerOverrides[player.Name] then
            return true
        end
    end
    -- team-based mapping
    for _, tname in ipairs(ESPSettings.CustomTeams or {}) do
        if player.Team and tostring(player.Team.Name) == tostring(tname) then return true end
    end
    for _, tobj in ipairs(ESPSettings.CustomTeamObjects or {}) do
        if matchTeamRef(tobj, player) then return true end
    end
    -- team color mappings
    if getTeamColor(player) then return true end
    -- global auto-add flag
    if ESPSettings.AutoAddPlayers then return true end
    return false
end

local function getScreenRectForCharacter(char)
    if not char then return end
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if hrp then
        local ok, extents = pcall(function() return char:GetExtentsSize() end)
        if ok and extents and extents.Y > 0 then
            local halfH = extents.Y / 2
            local topWorld = hrp.Position + Vector3.new(0, halfH, 0)
            local bottomWorld = hrp.Position - Vector3.new(0, halfH, 0)
            local spTop = Camera:WorldToViewportPoint(topWorld)
            local spBottom = Camera:WorldToViewportPoint(bottomWorld)
            if spTop.Z > 0 and spBottom.Z > 0 then
                local h = math.abs(spBottom.Y - spTop.Y)
                local w = h * 0.55
                local cx = (spTop.X + spBottom.X) / 2
                local x = cx - w / 2
                local y = spTop.Y
                return { x = x, y = y, w = w, h = h, cx = cx, cy = y + h/2 }
            end
        end
    end
    return nil
end

-- Create ESP object
local function createESPObject()
    local container = Instance.new("Frame")
    container.Name = "ESPContainer"
    container.BackgroundTransparency = 1
    container.Size = UDim2.new(1, 0, 1, 0)
    container.Parent = ESPHolder
    
    local espObj = {
        Container = container,
        Player = nil,
    }
    espObj.GradientAngle = nil
    espObj.HealthGradientPhase = nil
    
    -- Name label
    espObj.Name = Instance.new("TextLabel")
    espObj.Name.Name = "NameLabel"
    espObj.Name.BackgroundTransparency = 1
    espObj.Name.Size = UDim2.new(0, 100, 0, 20)
    espObj.Name.AnchorPoint = Vector2.new(0.5, 0.5)
    espObj.Name.Font = Enum.Font.Code
    espObj.Name.TextSize = 13
    espObj.Name.TextColor3 = Color3.fromRGB(255, 255, 255)
    espObj.Name.TextStrokeTransparency = 0
    espObj.Name.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    espObj.Name.RichText = true
    espObj.Name.Visible = false
    espObj.Name.ZIndex = 10
    espObj.Name.Parent = container
    
    -- Distance label
    espObj.Distance = Instance.new("TextLabel")
    espObj.Distance.Name = "DistanceLabel"
    espObj.Distance.BackgroundTransparency = 1
    espObj.Distance.Size = UDim2.new(0, 100, 0, 20)
    espObj.Distance.AnchorPoint = Vector2.new(0.5, 0.5)
    espObj.Distance.Font = Enum.Font.Code
    espObj.Distance.TextSize = 13
    espObj.Distance.TextColor3 = Color3.fromRGB(255, 255, 255)
    espObj.Distance.TextStrokeTransparency = 0
    espObj.Distance.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    espObj.Distance.Visible = false
    espObj.Distance.ZIndex = 10
    espObj.Distance.Parent = container

    -- Custom text entries (external scripts may populate `espObj.CustomTexts`)
    espObj.CustomTexts = {} -- array of strings
    espObj.CustomTextLabels = {} -- generated TextLabel instances
    
    -- Weapon label
    espObj.Weapon = Instance.new("TextLabel")
    espObj.Weapon.Name = "WeaponLabel"
    espObj.Weapon.BackgroundTransparency = 1
    espObj.Weapon.Size = UDim2.new(0, 100, 0, 20)
    espObj.Weapon.AnchorPoint = Vector2.new(0.5, 0.5)
    espObj.Weapon.Font = Enum.Font.Code
    espObj.Weapon.TextSize = 13
    espObj.Weapon.TextColor3 = Color3.fromRGB(255, 255, 255)
    espObj.Weapon.TextStrokeTransparency = 0
    espObj.Weapon.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    espObj.Weapon.Visible = false
    espObj.Weapon.ZIndex = 10
    espObj.Weapon.Parent = container
    
    -- Box fill
    espObj.Box = Instance.new("Frame")
    espObj.Box.Name = "BoxFill"
    espObj.Box.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    espObj.Box.BackgroundTransparency = 0.75
    espObj.Box.BorderSizePixel = 0
    espObj.Box.Visible = false
    espObj.Box.ZIndex = 1
    espObj.Box.Parent = container
    
    -- Box fill gradient
    espObj.BoxGradient = Instance.new("UIGradient")
    espObj.BoxGradient.Name = "FillGradient"
    espObj.BoxGradient.Enabled = true
    espObj.BoxGradient.Rotation = -90
    espObj.BoxGradient.Parent = espObj.Box
    
    -- Box outline (UIStroke)
    espObj.BoxOutline = Instance.new("UIStroke")
    espObj.BoxOutline.Name = "BoxOutline"
    espObj.BoxOutline.Color = Color3.fromRGB(0, 0, 0)
    espObj.BoxOutline.Thickness = 1
    espObj.BoxOutline.Transparency = 0
    espObj.BoxOutline.LineJoinMode = Enum.LineJoinMode.Miter
    espObj.BoxOutline.Parent = espObj.Box
    
    -- Box outline gradient (for colored outlines)
    espObj.OutlineGradient = Instance.new("UIGradient")
    espObj.OutlineGradient.Name = "OutlineGradient"
    espObj.OutlineGradient.Enabled = false
    espObj.OutlineGradient.Rotation = -90
    espObj.OutlineGradient.Parent = espObj.Box
    
    -- Tracer line
    espObj.Tracer = Instance.new("Frame")
    espObj.Tracer.Name = "Tracer"
    espObj.Tracer.AnchorPoint = Vector2.new(0.5, 0.5)
    espObj.Tracer.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    espObj.Tracer.BorderSizePixel = 0
    espObj.Tracer.Visible = false
    espObj.Tracer.ZIndex = 2
    espObj.Tracer.Parent = container
    
    -- Health bar background
    espObj.HealthBarBG = Instance.new("Frame")
    espObj.HealthBarBG.Name = "HealthBarBG"
    espObj.HealthBarBG.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    espObj.HealthBarBG.BackgroundTransparency = 0
    espObj.HealthBarBG.BorderSizePixel = 1
    espObj.HealthBarBG.BorderColor3 = Color3.fromRGB(0, 0, 0)
    espObj.HealthBarBG.Visible = false
    espObj.HealthBarBG.ZIndex = 3
    espObj.HealthBarBG.Parent = container
    
    -- Health bar fill
    espObj.HealthBar = Instance.new("Frame")
    espObj.HealthBar.Name = "HealthBar"
    espObj.HealthBar.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    espObj.HealthBar.BackgroundTransparency = 0
    espObj.HealthBar.BorderSizePixel = 0
    espObj.HealthBar.Visible = false
    espObj.HealthBar.ZIndex = 4
    espObj.HealthBar.Parent = container
    
    -- Health bar gradient
    espObj.HealthBarGradient = Instance.new("UIGradient")
    espObj.HealthBarGradient.Name = "HealthGradient"
    espObj.HealthBarGradient.Enabled = true
    espObj.HealthBarGradient.Rotation = -90
    espObj.HealthBarGradient.Color = createGradientSequence(
        Color3.fromRGB(200, 0, 0),
        Color3.fromRGB(60, 60, 125),
        Color3.fromRGB(119, 120, 255)
    )
    espObj.HealthBarGradient.Parent = espObj.HealthBar
    
    -- Health text
    espObj.HealthText = Instance.new("TextLabel")
    espObj.HealthText.Name = "HealthText"
    espObj.HealthText.BackgroundTransparency = 1
    espObj.HealthText.Size = UDim2.new(0, 50, 0, 20)
    espObj.HealthText.AnchorPoint = Vector2.new(0.5, 0.5)
    espObj.HealthText.Font = Enum.Font.Code
    espObj.HealthText.TextSize = 13
    espObj.HealthText.TextColor3 = Color3.fromRGB(119, 120, 255)
    espObj.HealthText.TextStrokeTransparency = 0
    espObj.HealthText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
    espObj.HealthText.Visible = false
    espObj.HealthText.ZIndex = 10
    espObj.HealthText.Parent = container
    
    -- Corner boxes (8 frames)
    espObj.Corners = {}
    for i = 1, 8 do
        local corner = Instance.new("Frame")
        corner.Name = "Corner" .. i
        corner.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        corner.BorderSizePixel = 0
        corner.Visible = false
        corner.ZIndex = 5
        corner.Parent = container
        espObj.Corners[i] = corner
    end
    
    -- Highlight/Chams
    espObj.Highlight = Instance.new("Highlight")
    espObj.Highlight.Name = "Chams"
    espObj.Highlight.FillTransparency = 0.5
    espObj.Highlight.OutlineTransparency = 0
    espObj.Highlight.FillColor = Color3.fromRGB(0, 170, 255)
    espObj.Highlight.OutlineColor = Color3.fromRGB(0, 170, 255)
    espObj.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    espObj.Highlight.Enabled = false
    espObj.Highlight.Parent = container
    
    return espObj
end

-- Remove ESP
local function removeESP(espObj)
    if not espObj then return end
    if espObj.Container then
        pcall(function() espObj.Container:Destroy() end)
    end
    if espObj.Highlight then
        pcall(function() espObj.Highlight:Destroy() end)
    end
end

-- Hide ESP
local function hideESP(espObj)
    if espObj.Name then espObj.Name.Visible = false end
    if espObj.Distance then espObj.Distance.Visible = false end
    if espObj.Weapon then espObj.Weapon.Visible = false end
    if espObj.Box then espObj.Box.Visible = false end
    if espObj.Tracer then espObj.Tracer.Visible = false end
    if espObj.HealthBar then espObj.HealthBar.Visible = false end
    if espObj.HealthBarBG then espObj.HealthBarBG.Visible = false end
    if espObj.HealthText then espObj.HealthText.Visible = false end
    if espObj.CustomTextLabels then
        for _, lbl in ipairs(espObj.CustomTextLabels) do
            lbl.Visible = false
        end
    end
    if espObj.Corners then
        for _, corner in ipairs(espObj.Corners) do
            corner.Visible = false
        end
    end
    if espObj.Highlight then espObj.Highlight.Enabled = false end
end

-- Position tracer line
local function positionTracer(frame, fromX, fromY, toX, toY, thickness)
    local length = math.sqrt((toX - fromX)^2 + (toY - fromY)^2)
    local angle = math.atan2(toY - fromY, toX - fromX)
    
    frame.Size = UDim2.new(0, length, 0, thickness)
    frame.Position = UDim2.new(0, (fromX + toX) / 2, 0, (fromY + toY) / 2)
    frame.Rotation = math.deg(angle)
end

-- Fade function
local function fadeElement(element, distance, maxDistance)
    local transparency = math.max(0.1, 1 - (distance / maxDistance))
    if element:IsA("TextLabel") then
        element.TextTransparency = 1 - transparency
    elseif element:IsA("Frame") then
        element.BackgroundTransparency = 1 - transparency
    elseif element:IsA("Highlight") then
        element.FillTransparency = 1 - transparency
        element.OutlineTransparency = 1 - transparency
    end
end

-- Main update loop
local function updateESP(deltaTime)
    deltaTime = deltaTime or (1/60)
    -- Rotation animation: integrate SpinAngle using deltaTime (with cap) to guarantee continuous spin
    local dt = math.min(deltaTime or (1/60), MAX_DT)
    local speed = ESPSettings.BoxRotationSpeed or 300 -- degrees per second
    if ESPSettings.AnimateBoxRotation then
        SpinAngle = (SpinAngle + speed * dt) % 360
        RotationAngle = SpinAngle
    else
        RotationAngle = -90
    end
    -- persist spin angle across reloads
    PERSIST.SpinAngle = SpinAngle
    -- Note: gradient autorotation will be integrated per-object below using deltaTime

    for player, espObj in pairs(ESPObjects) do
        pcall(function()
            -- per-player setting accessor: checks ESPSettings.PlayerOverrides by UserId or Name
            local function getSetting(key, default)
                if ESPSettings.PlayerOverrides and player then
                    local idKey = tostring(player.UserId)
                    local nameKey = player.Name
                    local overrides = ESPSettings.PlayerOverrides[idKey] or ESPSettings.PlayerOverrides[nameKey]
                    if overrides and overrides[key] ~= nil then
                        return overrides[key]
                    end
                end
                if ESPSettings[key] ~= nil then return ESPSettings[key] end
                return default
            end

            if not shouldShowPlayer(player) then 
                hideESP(espObj) 
                return 
            end
            
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not char or not hrp or not hum or hum.Health <= 0 then
                hideESP(espObj)
                return
            end

            local distance = (hrp.Position - Camera.CFrame.Position).Magnitude
            if distance > getSetting("MaxDistance", ESPSettings.MaxDistance) then
                hideESP(espObj)
                return
            end

            local rect = getScreenRectForCharacter(char)
            if not rect then
                hideESP(espObj)
                return
            end

            local x, y, w, h = rect.x, rect.y, rect.w, rect.h
            local Dist = distance / 3.5714285714
            
            if getSetting("Enabled", ESPSettings.Enabled) then
                -- Name
                if getSetting("ShowName", ESPSettings.ShowName) and espObj.Name then
                    local nameText = ""
                    if getSetting("NameMode", ESPSettings.NameMode) == "DisplayName" then
                        nameText = (player.DisplayName or player.Name or "")
                    elseif getSetting("NameMode", ESPSettings.NameMode) == "Both" then
                        nameText = string.format("%s (%s)", (player.DisplayName or ""), (player.Name or ""))
                    else
                        nameText = (player.Name or player.DisplayName or "")
                    end
                    espObj.Name.Text = nameText
                    espObj.Name.Position = UDim2.new(0, x + w/2, 0, y - 15)
                    espObj.Name.Visible = true
                end
                
                -- Distance
                if getSetting("ShowDistance", ESPSettings.ShowDistance) and espObj.Distance then
                    espObj.Distance.Text = string.format("[%d st]", math.floor(Dist))
                    espObj.Distance.Position = UDim2.new(0, x + w/2, 0, y + h + 7)
                    espObj.Distance.Visible = true
                end
                
                -- Weapon (placeholder)
                if espObj.Weapon then
                    espObj.Weapon.Text = "none"
                    espObj.Weapon.Position = UDim2.new(0, x + w/2, 0, y + h + 20)
                    espObj.Weapon.Visible = false
                end
                
                -- Box
                if getSetting("Boxes", ESPSettings.Boxes) and espObj.Box then
                    if ESPSettings.BoxType == "Square" then
                        espObj.Box.Position = UDim2.new(0, x, 0, y)
                        espObj.Box.Size = UDim2.new(0, w, 0, h)
                        espObj.Box.Visible = true
                        
                        -- Update gradient + fill
                        local c1 = getSetting("BoxFillCustomColor1", ESPSettings.BoxFillCustomColor1) or getSetting("BoxCustomColor1", ESPSettings.BoxCustomColor1)
                        local c2 = getSetting("BoxFillCustomColor2", ESPSettings.BoxFillCustomColor2) or getSetting("BoxCustomColor2", ESPSettings.BoxCustomColor2)
                        local c3 = getSetting("BoxFillCustomColor3", ESPSettings.BoxFillCustomColor3) or getSetting("BoxCustomColor3", ESPSettings.BoxCustomColor3)
                        local teamCol = getTeamColor(player)
                        if teamCol then
                            c1 = teamCol
                            c2 = teamCol
                            c3 = teamCol
                        end
                        -- Base rotation for the gradient: box rotation (if enabled) plus internal autorotation (time-based)
                        local baseRotation = getSetting("AnimateBoxRotation", ESPSettings.AnimateBoxRotation) and (RotationAngle % 360) or -90
                        -- Compensate gradient angular velocity by the projected perpendicular span
                        -- so travel speed of colors appears uniform across rotations/box shapes.
                        -- Use the box's base rotation for span calculation so the
                        -- span multiplier doesn't vary with the internal gradient angle.
                        local rad = math.rad(baseRotation % 360)
                        local absSin = math.abs(math.sin(rad))
                        local absCos = math.abs(math.cos(rad))
                        local perpSpan = w * absSin + h * absCos

                        -- Exact average span over a full rotation for a rectangle: (2/pi)*(w+h)
                        local averageSpan = (2 / math.pi) * (w + h)
                        if averageSpan == 0 then averageSpan = 1 end

                        local multiplier = perpSpan / averageSpan
                        local effectiveSpeed = AUTOROTATE_SPEED * multiplier

                        espObj.GradientAngle = (espObj.GradientAngle or 0 + 0) -- ensure non-nil
                        espObj.GradientAngle = (espObj.GradientAngle + effectiveSpeed * dt) % 360
                        espObj.BoxGradient.Rotation = (baseRotation + espObj.GradientAngle) % 360
                        -- persist per-player gradient angle
                        if espObj.Player and espObj.Player.UserId then
                            PERSIST.GradientAngle[tostring(espObj.Player.UserId)] = espObj.GradientAngle
                        end

                        -- Three-stop fill gradient â€” restore full custom stops
                        local gc1 = c1 or ESPSettings.BoxFillColor or Color3.new(1,1,1)
                        local gc2 = c2 or ESPSettings.BoxFillColor or gc1
                        local gc3 = c3 or ESPSettings.BoxFillColor or gc2
                        espObj.BoxGradient.Color = createGradientSequence(gc1, gc2, gc3)
                        espObj.BoxGradient.Enabled = (ESPSettings.BoxFill == true)


                        -- Box fill transparency and base color (base color uses middle stop)
                        if ESPSettings.BoxFill then
                            espObj.Box.BackgroundTransparency = math.clamp(ESPSettings.BoxFillTransparency or 0.5, 0, 1)
                            -- Leave BackgroundColor neutral so the UIGradient shows all three stops
                            espObj.Box.BackgroundColor3 = Color3.new(1, 1, 1)
                        else
                            espObj.Box.BackgroundTransparency = 1
                        end
                        
                        -- Outline color (use configured outline color or default)
                        espObj.BoxOutline.Color = getSetting("BoxOutlineColor", ESPSettings.BoxOutlineColor) or Color3.fromRGB(0, 0, 0)
                        espObj.BoxOutline.Thickness = 1
                        -- If an outline gradient is desired, enable and set it to the box custom colors
                        espObj.OutlineGradient.Color = createGradientSequence(
                            ESPSettings.BoxCustomColor1 or ESPSettings.BoxColor,
                            ESPSettings.BoxCustomColor2 or ESPSettings.BoxColor,
                            ESPSettings.BoxCustomColor3 or ESPSettings.BoxColor
                        )
                        espObj.OutlineGradient.Enabled = false
                        
                        -- Hide corners for square mode
                        for _, corner in ipairs(espObj.Corners) do
                            corner.Visible = false
                        end
                    elseif getSetting("BoxType", ESPSettings.BoxType) == "Corner" then
                        espObj.Box.Visible = false
                        
                        -- Corner boxes
                        local cornerLen = math.min(w, h) * 0.25
                        
                        -- Top left
                        espObj.Corners[1].Position = UDim2.new(0, x, 0, y)
                        espObj.Corners[1].Size = UDim2.new(0, cornerLen, 0, 1)
                        espObj.Corners[1].Visible = true
                        
                        espObj.Corners[2].Position = UDim2.new(0, x, 0, y)
                        espObj.Corners[2].Size = UDim2.new(0, 1, 0, cornerLen)
                        espObj.Corners[2].Visible = true
                        
                        -- Top right
                        espObj.Corners[3].Position = UDim2.new(0, x + w - cornerLen, 0, y)
                        espObj.Corners[3].Size = UDim2.new(0, cornerLen, 0, 1)
                        espObj.Corners[3].Visible = true
                        
                        espObj.Corners[4].Position = UDim2.new(0, x + w - 1, 0, y)
                        espObj.Corners[4].Size = UDim2.new(0, 1, 0, cornerLen)
                        espObj.Corners[4].Visible = true
                        
                        -- Bottom left
                        espObj.Corners[5].Position = UDim2.new(0, x, 0, y + h - 1)
                        espObj.Corners[5].Size = UDim2.new(0, cornerLen, 0, 1)
                        espObj.Corners[5].Visible = true
                        
                        espObj.Corners[6].Position = UDim2.new(0, x, 0, y + h - cornerLen)
                        espObj.Corners[6].Size = UDim2.new(0, 1, 0, cornerLen)
                        espObj.Corners[6].Visible = true
                        
                        -- Bottom right
                        espObj.Corners[7].Position = UDim2.new(0, x + w - cornerLen, 0, y + h - 1)
                        espObj.Corners[7].Size = UDim2.new(0, cornerLen, 0, 1)
                        espObj.Corners[7].Visible = true
                        
                        espObj.Corners[8].Position = UDim2.new(0, x + w - 1, 0, y + h - cornerLen)
                        espObj.Corners[8].Size = UDim2.new(0, 1, 0, cornerLen)
                        espObj.Corners[8].Visible = true
                    end
                end
                
                -- Health bar
                    -- Custom text ESP: create/update right-side stacked labels
                    if espObj.CustomTexts and #espObj.CustomTexts > 0 then
                        local startX = x + w + 6 -- place to the right of the box
                        local lineHeight = 16
                        for i, txt in ipairs(espObj.CustomTexts) do
                            local lbl = espObj.CustomTextLabels[i]
                            if not lbl then
                                lbl = Instance.new("TextLabel")
                                lbl.BackgroundTransparency = 1
                                lbl.Font = Enum.Font.Code
                                lbl.TextSize = 13
                                lbl.TextColor3 = Color3.fromRGB(255,255,255)
                                lbl.TextStrokeTransparency = 0
                                lbl.TextStrokeColor3 = Color3.fromRGB(0,0,0)
                                lbl.ZIndex = 11
                                lbl.Parent = espObj.Container
                                espObj.CustomTextLabels[i] = lbl
                            end
                            lbl.Text = tostring(txt or "")
                            lbl.Position = UDim2.new(0, startX, 0, y + (i-1) * lineHeight)
                            lbl.Visible = true
                        end
                        -- hide any surplus labels
                        for j = #espObj.CustomTexts + 1, #espObj.CustomTextLabels do
                            if espObj.CustomTextLabels[j] then espObj.CustomTextLabels[j].Visible = false end
                        end
                    end

                    if getSetting("HealthBarEnabled", ESPSettings.HealthBarEnabled) and espObj.HealthBar then
                    local healthRatio = 1
                    if hum.MaxHealth and hum.MaxHealth > 0 then
                        healthRatio = math.clamp(hum.Health / hum.MaxHealth, 0, 1)
                    end
                    local barHeight = h * healthRatio

                    -- Use neutral background so gradient displays correctly
                    espObj.HealthBar.BackgroundColor3 = Color3.new(1, 1, 1)
                    -- Animate health gradient upward by shifting keypoint positions
                    local speed = getSetting("HealthGradientSpeed", ESPSettings.HealthGradientSpeed) or 0.5 -- cycles per second
                    espObj.HealthGradientPhase = (espObj.HealthGradientPhase or 0)
                    espObj.HealthGradientPhase = (espObj.HealthGradientPhase + speed * dt) % 1
                    if espObj.Player and espObj.Player.UserId then
                        PERSIST.HealthPhase[tostring(espObj.Player.UserId)] = espObj.HealthGradientPhase
                    end

                    -- Health gradient colors
                    local hc1 = getSetting("HealthBarColor1", ESPSettings.HealthBarColor1) or Color3.fromRGB(255, 0, 0)
                    local hc2 = getSetting("HealthBarColor2", ESPSettings.HealthBarColor2) or Color3.fromRGB(255, 170, 0)
                    local hc3 = getSetting("HealthBarColor3", ESPSettings.HealthBarColor3) or Color3.fromRGB(0, 255, 0)
                    local teamCol = getTeamColor(player)
                    if teamCol then
                        hc1 = teamCol
                        hc2 = teamCol
                        hc3 = teamCol
                    end

                    -- Setup blending/sampling helper (used by static and animated modes)
                    local blendMode = ESPSettings.HealthGradientBlend or "linear"
                    local function applyBlend(t)
                        t = math.clamp(t, 0, 1)
                        if blendMode == "smooth" then
                            return t * t * (3 - 2 * t)
                        elseif blendMode == "ease" then
                            return 0.5 * (1 - math.cos(math.pi * t))
                        else
                            return t
                        end
                    end

                    local function sampleBase(u)
                        u = (u % 1 + 1) % 1
                        if u < (1/3) then
                            local t2 = u / (1/3)
                            return lerpColor(hc1, hc2, applyBlend(t2))
                        elseif u < (2/3) then
                            local t2 = (u - (1/3)) / (1/3)
                            return lerpColor(hc2, hc3, applyBlend(t2))
                        else
                            local t2 = (u - (2/3)) / (1/3)
                            return lerpColor(hc3, hc1, applyBlend(t2))
                        end
                    end

                    -- If animation is disabled, use a static 3-stop sequence
                    if not ESPSettings.HealthGradientEnabled then
                        espObj.HealthBarGradient.Color = createGradientSequence(hc1, hc2, hc3)
                    else
                        -- fixed sample density for blending/smoothness (12 samples)
                        local sampleCount = 12
                        local samples = {}
                        for i = 0, (sampleCount - 1) do
                            local basePos = i / (sampleCount - 1)
                            -- subtract phase so sampled colors appear to move upward
                            local samplePos = (basePos - espObj.HealthGradientPhase) % 1
                            samples[i+1] = { pos = basePos, color = sampleBase(samplePos) }
                        end
                        local cs = {}
                        for _, s in ipairs(samples) do
                            table.insert(cs, ColorSequenceKeypoint.new(s.pos, s.color))
                        end
                        espObj.HealthBarGradient.Color = ColorSequence.new(cs)
                    end

                    -- Determine a color sample for the health text (match gradient at filled/top position)
                    local samplePhase = ESPSettings.HealthGradientEnabled and (espObj.HealthGradientPhase or 0) or 0
                    local samplePosForText = (healthRatio - samplePhase) % 1
                    local healthTextColor = sampleBase(samplePosForText)
                    -- Force health bar outline to 1px black (do not change)
                    espObj.HealthBarBG.BorderSizePixel = 1
                    espObj.HealthBarBG.BorderColor3 = Color3.fromRGB(0, 0, 0)

                    local thickness = ESPSettings.HealthBarThickness or 2
                    local padding = 4

                    -- Position background/fill based on configured side
                    if ESPSettings.HealthBarPosition == "Right" then
                        local bgX = x + w + padding
                        espObj.HealthBarBG.Position = UDim2.new(0, bgX, 0, y)
                        espObj.HealthBar.Position = UDim2.new(0, bgX, 0, y + h - barHeight)
                    else
                        -- Default to Left
                        local bgX = x - (thickness + padding)
                        espObj.HealthBarBG.Position = UDim2.new(0, bgX, 0, y)
                        espObj.HealthBar.Position = UDim2.new(0, bgX, 0, y + h - barHeight)
                    end

                    espObj.HealthBarBG.Size = UDim2.new(0, thickness, 0, h)
                    espObj.HealthBar.Size = UDim2.new(0, thickness, 0, barHeight)
                    espObj.HealthBarBG.Visible = true
                    espObj.HealthBar.Visible = true

                    -- Health text: place near the top of the filled portion and match gradient
                    if ESPSettings.ShowHealthText and espObj.HealthText then
                        local healthPercent = math.floor((healthRatio or 0) * 100)
                        espObj.HealthText.Text = string.format("%d%%", healthPercent)
                        if ESPSettings.HealthBarPosition == "Right" then
                            espObj.HealthText.Position = UDim2.new(0, x + w + padding, 0, y + h - barHeight + 3)
                        else
                            espObj.HealthText.Position = UDim2.new(0, x - (thickness + padding), 0, y + h - barHeight + 3)
                        end
                        espObj.HealthText.TextColor3 = healthTextColor or espObj.HealthText.TextColor3
                        espObj.HealthText.Visible = true
                    end
                end
                
                -- Tracer
                if ESPSettings.Tracers and espObj.Tracer then
                    local tracerFrom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                    if ESPSettings.TracerFrom == "Top" then
                        tracerFrom = Vector2.new(Camera.ViewportSize.X / 2, 0)
                    elseif ESPSettings.TracerFrom == "Center" then
                        tracerFrom = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    end
                    
                    local tracerTo = Vector2.new(x + w/2, y + h/2)
                    positionTracer(espObj.Tracer, tracerFrom.X, tracerFrom.Y, tracerTo.X, tracerTo.Y, ESPSettings.TracerThickness)
                    espObj.Tracer.BackgroundColor3 = ESPSettings.TracerColor
                    espObj.Tracer.Visible = true
                end
                
                -- Chams
                if ESPSettings.Highlight and espObj.Highlight then
                    espObj.Highlight.Adornee = char
                    espObj.Highlight.FillColor = ESPSettings.GlobalChamColor
                    espObj.Highlight.OutlineColor = ESPSettings.GlobalChamColor
                    espObj.Highlight.FillTransparency = ESPSettings.FillTransparency
                    espObj.Highlight.OutlineTransparency = ESPSettings.OutlineTransparency
                    espObj.Highlight.Enabled = true
                end
            else
                hideESP(espObj)
            end
        end)
    end
end

-- Add ESP for player
local function addESP(player)
    if ESPObjects[player] then return end
    local espObj = createESPObject()
    espObj.Player = player
    -- Restore persistent phases/angles if available
    if player and player.UserId then
        local id = tostring(player.UserId)
        espObj.HealthGradientPhase = PERSIST.HealthPhase[id] or math.random()
        espObj.GradientAngle = PERSIST.GradientAngle[id] or 0
    else
        espObj.HealthGradientPhase = espObj.HealthGradientPhase or math.random()
        espObj.GradientAngle = espObj.GradientAngle or 0
    end
    ESPObjects[player] = espObj
end

-- Remove ESP for player
local function removePlayerESP(player)
    local espObj = ESPObjects[player]
    if espObj then
        hideESP(espObj)
        removeESP(espObj)
        ESPObjects[player] = nil
    end
end

-- Initialize ESP for all players
for _, player in ipairs(Players:GetPlayers()) do
    if needsESP(player) then
        addESP(player)
    end
end

-- Player added/removed events
Players.PlayerAdded:Connect(function(player)
    if needsESP(player) then
        addESP(player)
    end
end)

Players.PlayerRemoving:Connect(function(player)
    removePlayerESP(player)
end)

-- Main render loop
renderConn = RunService.RenderStepped:Connect(function(delta)
    updateESP(delta)
end)

-- Global API
getgenv().TrisESP = {
    Settings = ESPSettings,
    Unload = function()
        if renderConn then renderConn:Disconnect() end
        for player, espObj in pairs(ESPObjects) do
            removeESP(espObj)
        end
        ESPObjects = {}
        if ESPHolder then ESPHolder:Destroy() end
    end,

    -- Helper to resolve a player reference (player object, userId number, or player name)
    _resolvePlayer = function(ref)
        if not ref then return nil end
        if type(ref) == "table" and ref.UserId then return ref end
        if type(ref) == "number" then
            for _,p in ipairs(Players:GetPlayers()) do
                if p.UserId == ref then return p end
            end
            return nil
        elseif type(ref) == "string" then
            return Players:FindFirstChild(ref)
        end
        return nil
    end,

    AddCustomText = function(playerRef, text)
        local p = getgenv().TrisESP._resolvePlayer(playerRef)
        if not p then return false end
        if not ESPObjects[p] then addESP(p) end
        local esp = ESPObjects[p]
        esp.CustomTexts = esp.CustomTexts or {}
        -- sanitize and limit external input to avoid UI overflow or malicious strings
        local s = tostring(text or "")
        if #s > 200 then
            s = string.sub(s, 1, 200)
        end
        -- trim leading/trailing whitespace
        s = s:gsub("^%s+", ""):gsub("%s+$", "")
        table.insert(esp.CustomTexts, s)
        return true
    end,

    RemoveCustomText = function(playerRef, idxOrText)
        local p = getgenv().TrisESP._resolvePlayer(playerRef)
        if not p or not ESPObjects[p] then return false end
        local esp = ESPObjects[p]
        esp.CustomTexts = esp.CustomTexts or {}
        if type(idxOrText) == "number" then
            if idxOrText >= 1 and idxOrText <= #esp.CustomTexts then
                table.remove(esp.CustomTexts, idxOrText)
                return true
            end
            return false
        else
            for i, v in ipairs(esp.CustomTexts) do
                if v == tostring(idxOrText) then
                    table.remove(esp.CustomTexts, i)
                    return true
                end
            end
            return false
        end
    end,

    ClearCustomText = function(playerRef)
        local p = getgenv().TrisESP._resolvePlayer(playerRef)
        if not p or not ESPObjects[p] then return false end
        local esp = ESPObjects[p]
        esp.CustomTexts = {}
        return true
    end,

    -- Team utilities
    _resolveTeam = function(ref)
        if not ref then return nil end
        if typeof and typeof(ref) == "Instance" then
            return ref
        end
        if type(ref) == "table" then
            return ref
        end
        if type(ref) == "string" then
            -- try to find a Team by name first
            for _, t in ipairs(Teams:GetTeams()) do
                if t.Name == ref then return t end
            end
            return ref -- fallback to name string
        end
        if type(ref) == "number" then
            return ref
        end
        return nil
    end,

    AddCustomTeam = function(teamRef, color)
        local t = getgenv().TrisESP._resolveTeam(teamRef)
        if not t then return false end
        if type(t) == "string" then
            ESPSettings.CustomTeams = ESPSettings.CustomTeams or {}
            for _, v in ipairs(ESPSettings.CustomTeams) do if v == t then return true end end
            table.insert(ESPSettings.CustomTeams, t)
        else
            ESPSettings.CustomTeamObjects = ESPSettings.CustomTeamObjects or {}
            for _, v in ipairs(ESPSettings.CustomTeamObjects) do if v == t then return true end end
            table.insert(ESPSettings.CustomTeamObjects, t)
        end
        -- store optional team color mapping
        if color then
            ESPSettings.TeamColorMap = ESPSettings.TeamColorMap or {}
            table.insert(ESPSettings.TeamColorMap, { ref = t, color = color })
        end
        -- ensure ESP created for existing players matching this team
        for _, p in ipairs(Players:GetPlayers()) do
            if matchTeamRef(t, p) then
                if not ESPObjects[p] then addESP(p) end
            end
        end
        return true
    end,

    RemoveCustomTeam = function(teamRef)
        local t = getgenv().TrisESP._resolveTeam(teamRef)
        if not t then return false end
        local found = false
        ESPSettings.CustomTeams = ESPSettings.CustomTeams or {}
        for i, v in ipairs(ESPSettings.CustomTeams) do
            if v == t then table.remove(ESPSettings.CustomTeams, i) found = true break end
        end
        ESPSettings.CustomTeamObjects = ESPSettings.CustomTeamObjects or {}
        for i, v in ipairs(ESPSettings.CustomTeamObjects) do
            if v == t then table.remove(ESPSettings.CustomTeamObjects, i) found = true break end
        end
        -- remove team color mappings referencing this ref
        if ESPSettings.TeamColorMap then
            for i = #ESPSettings.TeamColorMap, 1, -1 do
                local entry = ESPSettings.TeamColorMap[i]
                if entry and entry.ref == t then
                    table.remove(ESPSettings.TeamColorMap, i)
                    found = true
                end
            end
        end
        return found
    end,

    ClearCustomTeams = function()
        ESPSettings.CustomTeams = {}
        ESPSettings.CustomTeamObjects = {}
        return true
    end,
    -- Add per-player ESP with optional color (Color3) or settings table
    AddPlayerESP = function(playerRef, colorOrSettings)
        local p = getgenv().TrisESP._resolvePlayer(playerRef)
        if not p then return false end
        ESPSettings.PlayerOverrides = ESPSettings.PlayerOverrides or {}
        local key = tostring(p.UserId)
        local entry = {}
        if type(colorOrSettings) == "table" then
            entry = colorOrSettings
        elseif typeof and typeof(colorOrSettings) == "Color3" then
            entry.BoxCustomColor1 = colorOrSettings
            entry.BoxCustomColor2 = colorOrSettings
            entry.BoxCustomColor3 = colorOrSettings
            entry.HealthBarColor1 = colorOrSettings
            entry.HealthBarColor2 = colorOrSettings
            entry.HealthBarColor3 = colorOrSettings
        elseif type(colorOrSettings) == "userdata" then
            -- attempt to treat as Color3-like
            entry.BoxCustomColor1 = colorOrSettings
            entry.HealthBarColor1 = colorOrSettings
        end
        entry.Enabled = true
        ESPSettings.PlayerOverrides[key] = entry
        if not ESPObjects[p] then addESP(p) end
        return true
    end,

    RemovePlayerESP = function(playerRef)
        local p = getgenv().TrisESP._resolvePlayer(playerRef)
        if not p then return false end
        ESPSettings.PlayerOverrides = ESPSettings.PlayerOverrides or {}
        ESPSettings.PlayerOverrides[tostring(p.UserId)] = nil
        ESPSettings.PlayerOverrides[p.Name] = nil
        removePlayerESP(p)
        return true
    end,
}

print("TrisESP (ScreenGui) loaded successfully!")
