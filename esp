--[[
    TrisESP - Pure API ESP System
    
    No UI - Controlled entirely via getgenv().TrisESP
    
    Load via: loadstring(game:HttpGet("YOUR_URL_HERE"))()
    
    Quick Start:
        getgenv().TrisESP.Settings.Enabled = true
        getgenv().TrisESP.Settings.Boxes = true
        getgenv().TrisESP.TrackObjectsByName("Diamond")
    
    See bottom of file for full API documentation.
--]]

local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = Workspace.CurrentCamera
local renderConn

local ESPObjects = {}
local RainbowHue = 0

local ESPSettings = {
    Enabled = true,
    MaxDistance = 1500,
    
    -- Filtering settings
    FilterMode = "All", -- "All", "Whitelist", "Blacklist"
    WhitelistedPlayers = {}, -- Player names to show when FilterMode = "Whitelist"
    BlacklistedPlayers = {}, -- Player names to hide when FilterMode = "Blacklist"
    -- Extended whitelist/blacklist that can store Instances (folders, models) or tables
    WhitelistedEntities = {}, -- keys can be Instances or nested tables
    BlacklistedEntities = {},
    
    -- Team ESP settings
    -- When TeamCheckEnabled = true, teammates are automatically hidden (no separate toggle)
    TeamCheckEnabled = false, -- When enabled, auto-hides teammates
    TeamDetectionMode = "Auto", -- "Auto", "RobloxTeams", "Folder", "Custom"
    CustomTeamFolder = nil, -- Folder instance for folder-based teams
    CustomTeamFunction = nil, -- Custom function(player1, player2) -> boolean (same team?)
    
    -- Modular text entries (easy to add more)
    TextEntries = {
        Name = { Enabled = true, Order = 1 },
        Health = { Enabled = true, Order = 2 },
        Distance = { Enabled = true, Order = 3 },
        -- Add more here: Weapon = { Enabled = false, Order = 4 }, etc.
    },
    
    -- Equipped tool display
    EquippedEnabled = false,
    EquippedMode = "Text", -- "Text" or "Image"
    EquippedPosition = "Inline", -- "Inline" or "Bottom"
    EquippedImage = "", -- image data or asset id for image mode
    
    -- Legacy compatibility
    ShowName = true,
    ShowHealthText = true,
    ShowDistance = true,
    NamePosition = "Top",
    HealthTextPosition = "Top",
    DistancePosition = "Top",
    -- Individual rainbow toggles for text elements
    NameRainbow = false,
    HealthTextRainbow = false,
    DistanceRainbow = false,
    
    -- Custom text entry builder: add entries to TextEntries table
    -- Example: TextEntries.Armor = { Enabled = true, Order = 4, GetText = function(player, char, hum, dist) return "Armor: 100" end }
    
    -- Rainbow settings (per element)
    RainbowSpeed = 1,
    GradientBlending = 0.5, -- 0 = sharp transitions, 1 = smooth blending

    -- Custom gradient colors for rainbow (instead of HSV rainbow)
    -- Global toggle: when true, use per-element custom 3-color gradients
    UseCustomGradient = false,
    -- Global fallback 3 colors
    CustomGradientColor1 = Color3.fromRGB(255, 0, 0),
    CustomGradientColor2 = Color3.fromRGB(255, 165, 0),
    CustomGradientColor3 = Color3.fromRGB(0, 0, 255),
    -- Per-element custom 3-color sets (Boxes, Tracers, HealthBar, Chams, Name, FOV, Objects)
    BoxCustomColor1 = Color3.fromRGB(255, 0, 0), BoxCustomColor2 = Color3.fromRGB(255, 165, 0), BoxCustomColor3 = Color3.fromRGB(0, 0, 255),
    BoxFillCustomColor1 = Color3.fromRGB(255, 0, 0), BoxFillCustomColor2 = Color3.fromRGB(255, 165, 0), BoxFillCustomColor3 = Color3.fromRGB(0, 0, 255),
    -- Per-color transparency for box fill gradient
    BoxFillTransparency1 = 0.5, BoxFillTransparency2 = 0.5, BoxFillTransparency3 = 0.5,
    TracerCustomColor1 = Color3.fromRGB(255, 0, 0), TracerCustomColor2 = Color3.fromRGB(255, 165, 0), TracerCustomColor3 = Color3.fromRGB(0, 0, 255),
    HealthBarCustomColor1 = Color3.fromRGB(255, 0, 0), HealthBarCustomColor2 = Color3.fromRGB(255, 165, 0), HealthBarCustomColor3 = Color3.fromRGB(0, 0, 255),
    ChamsCustomColor1 = Color3.fromRGB(255, 0, 0), ChamsCustomColor2 = Color3.fromRGB(255, 165, 0), ChamsCustomColor3 = Color3.fromRGB(0, 0, 255),
    NameCustomColor1 = Color3.fromRGB(255, 0, 0), NameCustomColor2 = Color3.fromRGB(255, 165, 0), NameCustomColor3 = Color3.fromRGB(0, 0, 255),
    FOVCustomColor1 = Color3.fromRGB(255, 0, 0), FOVCustomColor2 = Color3.fromRGB(255, 165, 0), FOVCustomColor3 = Color3.fromRGB(0, 0, 255),
    ObjectCustomColor1 = Color3.fromRGB(255, 0, 0), ObjectCustomColor2 = Color3.fromRGB(255, 165, 0), ObjectCustomColor3 = Color3.fromRGB(0, 0, 255),

    -- Text-specific custom gradients (for Name/Health/Distance separate gradients)
    HealthTextCustomColor1 = Color3.fromRGB(255, 255, 255), HealthTextCustomColor2 = Color3.fromRGB(255, 255, 255), HealthTextCustomColor3 = Color3.fromRGB(255, 255, 255),
    DistanceCustomColor1 = Color3.fromRGB(255, 255, 255), DistanceCustomColor2 = Color3.fromRGB(255, 255, 255), DistanceCustomColor3 = Color3.fromRGB(255, 255, 255),
    
    -- FOV Circle settings
    FOVCircleEnabled = false,
    FOVCircleRadius = 100,
    FOVCircleColor = Color3.fromRGB(255, 255, 255),
    FOVCircleThickness = 1,
    FOVCircleTransparency = 0,
    FOVCircleRainbow = false,
    FOVCircleFilled = false,
    FOVCircleFillColor = Color3.fromRGB(255, 255, 255),
    FOVCircleFillTransparency = 0.8,
    FOVCircleFillRainbow = false,
    FOVCircleSegments = 128,
    
    -- Box settings
    Boxes = true,
    BoxType = "Square",
    BoxColor = Color3.fromRGB(0, 170, 255),
    BoxRainbow = false,
    Thickness = 2,
    BoxOutlineColor = Color3.new(0, 0, 0),
    
    -- Box fill settings
    BoxFill = false,
    BoxFillColor = Color3.fromRGB(0, 170, 255),
    BoxFillTransparency = 0.5,
    BoxFillRainbow = false,
    
    -- Tracer settings
    Tracers = false,
    TracerFrom = "Bottom",
    TracerThickness = 2,
    TracerColor = Color3.fromRGB(0, 170, 255),
    TracerRainbow = false,
    
    -- Health bar settings
    HealthBarEnabled = true,
    HealthBarPosition = "Left",
    HealthBarThickness = 3,
    HealthBarOutline = true,
    HealthBarOutlineColor = Color3.new(0, 0, 0),
    HealthBarRainbow = false,
    
    -- Text settings
    TextFont = 2, -- 0=Legacy, 1=Arial, 2=SourceSans, 3=RobotoMono
    UseDisplayName = false, -- true = display name, false = username
    
    -- Chams settings
    Highlight = true,
    GlobalChamColor = Color3.fromRGB(0, 170, 255),
    FillTransparency = 0.5,
    OutlineTransparency = 0,
    ChamDepthMode = "AlwaysOnTop",
    ChamsRainbow = false,
    
    -- Name settings
    NameRainbow = false,
    NameColor = Color3.fromRGB(255, 255, 255)
}

-- Object ESP configurations (for non-players)
local ObjectESPConfigs = {}

local AllowedParts = {
    Head = true, HumanoidRootPart = true,
    Torso = true, ["Left Arm"] = true, ["Right Arm"] = true, ["Left Leg"] = true, ["Right Leg"] = true,
    UpperTorso = true, LowerTorso = true,
    LeftUpperArm = true, LeftLowerArm = true, LeftHand = true,
    RightUpperArm = true, RightLowerArm = true, RightHand = true,
    LeftUpperLeg = true, LeftLowerLeg = true, LeftFoot = true,
    RightUpperLeg = true, RightLowerLeg = true, RightFoot = true
}

-- Utility functions
local function getRainbowColor(offset, element)
    offset = offset or 0
    element = element or ""

    -- Use per-element 3-color gradient (stops always = 3)
    local stops = 3

    local function pickColorsForElement(el)
        if el == "Box" then
            return {ESPSettings.BoxCustomColor1, ESPSettings.BoxCustomColor2, ESPSettings.BoxCustomColor3}
        elseif el == "BoxFill" then
            return {ESPSettings.BoxFillCustomColor1, ESPSettings.BoxFillCustomColor2, ESPSettings.BoxFillCustomColor3}
        elseif el == "Tracer" then
            return {ESPSettings.TracerCustomColor1, ESPSettings.TracerCustomColor2, ESPSettings.TracerCustomColor3}
        elseif el == "HealthBar" then
            return {ESPSettings.HealthBarCustomColor1, ESPSettings.HealthBarCustomColor2, ESPSettings.HealthBarCustomColor3}
        elseif el == "HealthText" or el == "Health" then
            return {ESPSettings.HealthTextCustomColor1, ESPSettings.HealthTextCustomColor2, ESPSettings.HealthTextCustomColor3}
        elseif el == "Chams" then
            return {ESPSettings.ChamsCustomColor1, ESPSettings.ChamsCustomColor2, ESPSettings.ChamsCustomColor3}
        elseif el == "Name" then
            return {ESPSettings.NameCustomColor1, ESPSettings.NameCustomColor2, ESPSettings.NameCustomColor3}
        elseif el == "FOV" then
            return {ESPSettings.FOVCustomColor1, ESPSettings.FOVCustomColor2, ESPSettings.FOVCustomColor3}
        elseif el == "Distance" then
            return {ESPSettings.DistanceCustomColor1, ESPSettings.DistanceCustomColor2, ESPSettings.DistanceCustomColor3}
        elseif el == "Object" then
            return {ESPSettings.ObjectCustomColor1, ESPSettings.ObjectCustomColor2, ESPSettings.ObjectCustomColor3}
        else
            return {ESPSettings.CustomGradientColor1, ESPSettings.CustomGradientColor2, ESPSettings.CustomGradientColor3}
        end
    end

    local colors = pickColorsForElement(element)

    -- Use absolute time + offset for smooth animation through stops
    local t = ((RainbowHue + offset) % 1) * stops
    local idx = math.floor(t) % stops
    local frac = t - math.floor(t)

    local c1 = colors[idx + 1]
    local c2 = colors[(idx + 1) % stops + 1]

    -- Blending: 0 = sharp bands, 1 = smooth gradient
    -- Use smoothstep with blending factor to control sharpness
    local blend = ESPSettings.GradientBlending or 0.5
    if blend >= 1 then
        -- Full smoothstep for smooth blending
        frac = frac * frac * (3 - 2 * frac)
    elseif blend > 0 then
        -- Mix between linear (sharp) and smoothstep (smooth)
        local smooth = frac * frac * (3 - 2 * frac)
        frac = frac + (smooth - frac) * blend
    end
    -- blend = 0 uses linear frac (sharp color bands)

    return Color3.new(
        c1.R + (c2.R - c1.R) * frac,
        c1.G + (c2.G - c1.G) * frac,
        c1.B + (c2.B - c1.B) * frac
    )
end

-- Get custom gradient color (for non-rainbow gradients with custom colors)
local function getCustomGradientColor(t, color1, color2)
    t = math.clamp(t, 0, 1)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local function lerpColor(c1, c2, t)
    t = math.clamp(t, 0, 1)
    return Color3.new(
        c1.R + (c2.R - c1.R) * t,
        c1.G + (c2.G - c1.G) * t,
        c1.B + (c2.B - c1.B) * t
    )
end

-- Get static gradient color for text (not time-based, uses baseOffset for per-player uniqueness)
-- This creates a smooth gradient across the 3 colors without animation
local function getStaticGradientColor(baseOffset, element)
    local stops = 3
    
    local function pickColorsForElement(el)
        if el == "Name" then
            return {ESPSettings.NameCustomColor1, ESPSettings.NameCustomColor2, ESPSettings.NameCustomColor3}
        elseif el == "HealthText" or el == "Health" or el == "HealthBar" then
            return {ESPSettings.HealthTextCustomColor1, ESPSettings.HealthTextCustomColor2, ESPSettings.HealthTextCustomColor3}
        elseif el == "Distance" then
            return {ESPSettings.DistanceCustomColor1, ESPSettings.DistanceCustomColor2, ESPSettings.DistanceCustomColor3}
        else
            return {ESPSettings.CustomGradientColor1, ESPSettings.CustomGradientColor2, ESPSettings.CustomGradientColor3}
        end
    end
    
    local colors = pickColorsForElement(element)
    
    -- Use ONLY baseOffset (no RainbowHue) for static gradient
    local t = (baseOffset % 1) * stops
    local idx = math.floor(t) % stops
    local frac = t - math.floor(t)
    
    local c1 = colors[idx + 1]
    local c2 = colors[(idx + 1) % stops + 1]
    
    -- Smoothstep interpolation
    frac = frac * frac * (3 - 2 * frac)
    
    return Color3.new(
        c1.R + (c2.R - c1.R) * frac,
        c1.G + (c2.G - c1.G) * frac,
        c1.B + (c2.B - c1.B) * frac
    )
end

local function getHealthColor(ratio)
    if ratio > 0.5 then
        return lerpColor(Color3.fromRGB(255, 255, 0), Color3.fromRGB(0, 255, 0), (ratio - 0.5) * 2)
    else
        return lerpColor(Color3.fromRGB(255, 0, 0), Color3.fromRGB(255, 255, 0), ratio * 2)
    end
end

local function isSameTeam(player1, player2)
    if not player1 or not player2 or player1 == player2 then return false end
    
    local mode = ESPSettings.TeamDetectionMode
    
    -- Custom function takes priority
    if mode == "Custom" and ESPSettings.CustomTeamFunction then
        return ESPSettings.CustomTeamFunction(player1, player2)
    end
    
    -- Folder-based teams
    if mode == "Folder" and ESPSettings.CustomTeamFolder then
        local folder = ESPSettings.CustomTeamFolder
        if folder and folder:IsA("Folder") then
            local char1 = player1.Character
            local char2 = player2.Character
            if char1 and char2 then
                -- Check if both characters are in the same child folder
                for _, teamFolder in ipairs(folder:GetChildren()) do
                    if teamFolder:IsA("Folder") then
                        local has1 = teamFolder:IsAncestorOf(char1)
                        local has2 = teamFolder:IsAncestorOf(char2)
                        if has1 and has2 then return true end
                    end
                end
            end
        end
        return false
    end
    
    -- Roblox built-in Teams or Auto mode
    if mode == "RobloxTeams" or mode == "Auto" then
        if player1.Team and player2.Team then
            return player1.Team == player2.Team
        end
    end
    
    return false
end

local function shouldShowPlayer(player)
    if not player or player == LocalPlayer then return false end
    
    -- Team check - when enabled, automatically hide teammates
    if ESPSettings.TeamCheckEnabled then
        if isSameTeam(player, LocalPlayer) then
            return false -- Hide teammates
        end
    end
    
    local function matchesEntityList(list)
        -- list contains keys that may be strings or Instances
        if not list then return false end
        -- name match
        if list[player.Name] then return true end
        -- instance matches (folders/models/players)
        for ent, _ in pairs(list) do
            if typeof(ent) == "Instance" then
                -- direct player instance
                if ent:IsA("Player") and ent == player then return true end
                -- character/model/folder containment: check if player's character is descendant
                if player.Character and ent:IsAncestorOf(player.Character) then return true end
            end
        end
        return false
    end

    local filterMode = ESPSettings.FilterMode
    if filterMode == "Whitelist" then
        -- whitelist must explicitly match by name or instance/folder
        if matchesEntityList(ESPSettings.WhitelistedPlayers) then return true end
        if matchesEntityList(ESPSettings.WhitelistedEntities) then return true end
        return false
    elseif filterMode == "Blacklist" then
        -- blacklist hides any match
        if matchesEntityList(ESPSettings.BlacklistedPlayers) then return false end
        if matchesEntityList(ESPSettings.BlacklistedEntities) then return false end
        return true
    end
    return true -- "All" mode
end

local function getScreenRectForCharacter(char)
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local any = false
    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    for _, part in ipairs(char:GetChildren()) do
        if part:IsA("BasePart") and AllowedParts[part.Name] then
            local sx, sy, sz = part.Size.X/2, part.Size.Y/2, part.Size.Z/2
            local corners = {
                Vector3.new( sx,  sy,  sz), Vector3.new(-sx,  sy,  sz),
                Vector3.new( sx, -sy,  sz), Vector3.new(-sx, -sy,  sz),
                Vector3.new( sx,  sy, -sz), Vector3.new(-sx,  sy, -sz),
                Vector3.new( sx, -sy, -sz), Vector3.new(-sx, -sy, -sz),
            }
            for _, off in ipairs(corners) do
                local worldPos = (part.CFrame * CFrame.new(off)).Position
                local sp = Camera:WorldToViewportPoint(worldPos)
                if sp.Z > 0 and sp.X >= 0 and sp.X <= vw and sp.Y >= 0 and sp.Y <= vh then
                    any = true
                    minX = math.min(minX, sp.X)
                    maxX = math.max(maxX, sp.X)
                    minY = math.min(minY, sp.Y)
                    maxY = math.max(maxY, sp.Y)
                end

                
            end
        end
    end
    if not any or minX == math.huge then return end
    local w = math.max(1, (maxX - minX))
    local h = math.max(1, (maxY - minY))
    
    -- Only filter out extreme edge cases, not valid close-up boxes
    if w < 2 or h < 2 then return end
    if w > vw * 0.95 or h > vh * 0.95 then return end
    
    local aspect = h / math.max(1, w)
    if aspect > 6.0 or aspect < 0.1 then return end
    return { x = minX, y = minY, w = w, h = h, cx = (minX + maxX)/2, cy = (minY + maxY)/2 }
end

local function getFallbackRect(char)
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local head = char:FindFirstChild("Head")
    if not hrp or not head then return end
    local hrpPos = Camera:WorldToViewportPoint(hrp.Position)
    local headPos = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 0.5, 0))
    if hrpPos.Z <= 0 or headPos.Z <= 0 then return end
    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    if hrpPos.X < 0 or hrpPos.X > vw or headPos.X < 0 or headPos.X > vw then return end
    if hrpPos.Y < 0 or hrpPos.Y > vh or headPos.Y < 0 or headPos.Y > vh then return end
    local topY = math.min(headPos.Y, hrpPos.Y) - 12
    local bottomY = math.max(headPos.Y, hrpPos.Y) + 12
    local h = math.max(2, bottomY - topY)
    local w = math.max(2, (h * 0.6))
    
    -- Only filter out if taking up almost entire screen
    if w > vw * 0.95 or h > vh * 0.95 then return end
    
    local x = hrpPos.X - w / 2
    local y = topY
    return { x = x, y = y, w = w, h = h, cx = x + w/2, cy = y + h/2 }
end

local function getObjectRect(obj)
    if not obj or not obj:IsA("BasePart") and not obj:IsA("Model") then return end
    local pos
    if obj:IsA("Model") then
        local primary = obj.PrimaryPart or obj:FindFirstChildWhichIsA("BasePart")
        if not primary then return end
        pos = primary.Position
    else
        pos = obj.Position
    end
    local sp = Camera:WorldToViewportPoint(pos)
    if sp.Z <= 0 then return end
    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
    if sp.X < 0 or sp.X > vw or sp.Y < 0 or sp.Y > vh then return end
    local distance = (pos - Camera.CFrame.Position).Magnitude
    local size = math.clamp(800 / distance, 20, 100)
    return { x = sp.X - size/2, y = sp.Y - size/2, w = size, h = size, cx = sp.X, cy = sp.Y, distance = distance, worldPos = pos }
end

-- NOTE: Drawing library does NOT support native gradients. Segments are the ONLY way.
-- Optimized gradient system: dynamically allocate segments based on box size
-- to minimize drawing calls while maintaining smooth appearance.
-- Segments are precisely positioned with NO overlap to prevent transparency artifacts.
local MAX_GRADIENT_SEGMENTS = 500  -- Reduced from 2000 for better performance
local MIN_GRADIENT_SEGMENTS = 10   -- Minimum segments for very small boxes
local BOX_LINE_SEGMENTS = 300      -- Enough for typical box dimensions

local function createESPObject()
    local espObj = {
        Name = Drawing.new("Text"),
        Tracer = Drawing.new("Line"),
        BoxLines = {},  -- 4 sides with gradient segments
        BoxFill = Drawing.new("Square"),
        GradientSegments = {},
        Corners = {
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")},
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")},
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")},
            {Line1 = Drawing.new("Line"), Line2 = Drawing.new("Line")}
        },
        HealthBar = Drawing.new("Square"),
        HealthBarOutline = Drawing.new("Square"),
        HealthBarGradient = {},  -- For rainbow gradient on health bar
        Highlight = nil,
        Player = nil,
        IsObject = false
    }
    
    -- Create health bar gradient segments (for rainbow)
    local HEALTH_GRADIENT_SEGS = 500
    for i = 1, HEALTH_GRADIENT_SEGS do
        local seg = Drawing.new("Square")
        seg.Filled = true
        seg.Visible = false
        seg.ZIndex = 0
        espObj.HealthBarGradient[i] = seg
    end
    
    -- Create box line segments for rainbow gradient on box edges
    for side = 1, 4 do
        espObj.BoxLines[side] = {}
        for seg = 1, BOX_LINE_SEGMENTS do
            local line = Drawing.new("Line")
            line.Thickness = 1
            line.Visible = false
            line.ZIndex = 3
            espObj.BoxLines[side][seg] = line
        end
    end
    
    -- Create gradient segments for fill (optimized pool size)
    for i = 1, MAX_GRADIENT_SEGMENTS do
        espObj.GradientSegments[i] = Drawing.new("Square")
        espObj.GradientSegments[i].Filled = true
        espObj.GradientSegments[i].Visible = false
        espObj.GradientSegments[i].ZIndex = 0
    end
    
    
            -- Equipped tool display (text + optional image if supported)
            espObj.EquippedText = Drawing.new("Text")
            espObj.EquippedText.Center = true
            espObj.EquippedText.Outline = true
            espObj.EquippedText.OutlineColor = Color3.new(0,0,0)
            espObj.EquippedText.Size = 13
            espObj.EquippedText.Font = ESPSettings.TextFont or 2
            espObj.EquippedText.Visible = false
            espObj.EquippedText.ZIndex = 999
    
            local okImg, img = pcall(function() return Drawing.new("Image") end)
            if okImg and img then
                espObj.EquippedImage = img
                espObj.EquippedImage.Visible = false
            else
                espObj.EquippedImage = nil
            end
    -- Outline square for crisp non-rainbow box rendering
    espObj.OutlineSquare = Drawing.new("Square")
    espObj.OutlineSquare.Filled = false
    espObj.OutlineSquare.Visible = false
    espObj.OutlineSquare.Thickness = ESPSettings.Thickness or 3
    espObj.OutlineSquare.Color = ESPSettings.BoxColor or Color3.fromRGB(0,170,255)
    espObj.OutlineSquare.ZIndex = 3
    espObj.Name.Center = true
    espObj.Name.Outline = true
    espObj.Name.OutlineColor = Color3.new(0,0,0)
    espObj.Name.Size = 13
    espObj.Name.Font = ESPSettings.TextFont or 2
    espObj.Name.Visible = false
    espObj.Name.ZIndex = 999
    -- Separate text objects for Name / Health / Distance (so they can be positioned independently)
    espObj.HealthText = Drawing.new("Text")
    espObj.HealthText.Center = true
    espObj.HealthText.Outline = true
    espObj.HealthText.OutlineColor = Color3.new(0,0,0)
    espObj.HealthText.Size = 13
    espObj.HealthText.Font = ESPSettings.TextFont or 2
    espObj.HealthText.Visible = false
    espObj.HealthText.ZIndex = 999

    espObj.DistanceText = Drawing.new("Text")
    espObj.DistanceText.Center = true
    espObj.DistanceText.Outline = true
    espObj.DistanceText.OutlineColor = Color3.new(0,0,0)
    espObj.DistanceText.Size = 13
    espObj.DistanceText.Font = ESPSettings.TextFont or 2
    espObj.DistanceText.Visible = false
    espObj.DistanceText.ZIndex = 999
    
    espObj.Tracer.Thickness = ESPSettings.TracerThickness
    espObj.Tracer.Visible = false
    espObj.Tracer.ZIndex = 2
    
    espObj.BoxFill.Filled = true
    espObj.BoxFill.Visible = false
    espObj.BoxFill.ZIndex = 1
    
    for _, c in ipairs(espObj.Corners) do
        c.Line1.Thickness = ESPSettings.Thickness or 1
        c.Line2.Thickness = ESPSettings.Thickness or 1
        c.Line1.Visible = false
        c.Line2.Visible = false
        c.Line1.ZIndex = 3
        c.Line2.ZIndex = 3
    end
    
    espObj.HealthBar.Filled = true
    espObj.HealthBar.Visible = false
    espObj.HealthBar.ZIndex = 1
    
    espObj.HealthBarOutline.Filled = false
    espObj.HealthBarOutline.Thickness = 2
    espObj.HealthBarOutline.Visible = false
    espObj.HealthBarOutline.ZIndex = 3
    
    return espObj
end

local function removeESP(espObj)
    if not espObj then return end
    pcall(function() espObj.Name:Remove() end)
    pcall(function() if espObj.HealthText then espObj.HealthText:Remove() end end)
    pcall(function() if espObj.DistanceText then espObj.DistanceText:Remove() end end)
    pcall(function() espObj.Tracer:Remove() end)
    for side = 1, 4 do
        for _, line in ipairs(espObj.BoxLines[side] or {}) do pcall(function() line:Remove() end) end
    end
    pcall(function() espObj.BoxFill:Remove() end)
    for _, seg in ipairs(espObj.GradientSegments or {}) do
        pcall(function() seg:Remove() end)
    end
    pcall(function() espObj.HealthBar:Remove() end)
    pcall(function() espObj.HealthBarOutline:Remove() end)
    for _, seg in ipairs(espObj.HealthBarGradient or {}) do
        pcall(function() seg:Remove() end)
    end
    for _, c in ipairs(espObj.Corners) do
        pcall(function() c.Line1:Remove() end)
        pcall(function() c.Line2:Remove() end)
    end
    if espObj.Highlight then pcall(function() espObj.Highlight:Destroy() end) end
    pcall(function() if espObj.EquippedText then espObj.EquippedText:Remove() end end)
    pcall(function() if espObj.EquippedImage then espObj.EquippedImage:Remove() end end)
    pcall(function() if espObj.OutlineSquare then espObj.OutlineSquare:Remove() end end)
end

local function hideESP(espObj)
    espObj.Name.Visible = false
    if espObj.HealthText then espObj.HealthText.Visible = false end
    if espObj.DistanceText then espObj.DistanceText.Visible = false end
    espObj.Tracer.Visible = false
    for side = 1, 4 do
        for _, line in ipairs(espObj.BoxLines[side] or {}) do line.Visible = false end
    end
    espObj.BoxFill.Visible = false
    for _, seg in ipairs(espObj.GradientSegments or {}) do seg.Visible = false end
    for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
    espObj.HealthBar.Visible = false
    espObj.HealthBarOutline.Visible = false
    for _, seg in ipairs(espObj.HealthBarGradient or {}) do seg.Visible = false end
    if espObj.Highlight then espObj.Highlight.Enabled = false end
    if espObj.EquippedText then espObj.EquippedText.Visible = false end
    if espObj.EquippedImage then espObj.EquippedImage.Visible = false end
    if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
end

-- SIMPLIFIED GRADIENT SYSTEM
-- Principle: Gradients are IDENTICAL to normal ESP, just with color variation

-- Helper to interpolate transparency across 3 stops for box fill
local function getGradientTransparency(t, element)
    if element == "BoxFill" then
        local t1 = ESPSettings.BoxFillTransparency1 or 0.5
        local t2 = ESPSettings.BoxFillTransparency2 or 0.5
        local t3 = ESPSettings.BoxFillTransparency3 or 0.5
        -- 3-stop interpolation: 0-0.5 = t1->t2, 0.5-1 = t2->t3
        if t < 0.5 then
            local frac = t * 2
            return t1 + (t2 - t1) * frac
        else
            local frac = (t - 0.5) * 2
            return t2 + (t3 - t2) * frac
        end
    end
    return ESPSettings.BoxFillTransparency or 0.5
end

-- Draw a filled rectangle with vertical gradient (same size/position as normal fill)
local function drawGradientFill(espObj, x, y, w, h, transparency, baseOffset, element)
    local segments = espObj.GradientSegments
    local maxSegs = #segments
    
    local ix, iy, iw, ih = math.floor(x), math.floor(y), math.floor(w), math.floor(h)
    if ih <= 0 or iw <= 0 then
        for i = 1, maxSegs do segments[i].Visible = false end
        return
    end

    -- Use as many segments as available when close (up to MAX_GRADIENT_SEGMENTS)
    -- This prevents the gradient from collapsing into very few large bands
    local desiredSegs = math.min(maxSegs, ih)
    local segCount = math.max(1, desiredSegs)

    -- Calculate segment heights - distribute evenly with 2px overlap
    local baseH = math.max(1, math.floor(ih / segCount))
    if baseH <= 0 then baseH = 1 end
    segCount = math.min(maxSegs, math.ceil(ih / baseH))

    for i = 1, segCount do
        local segTop = iy + (i - 1) * baseH
        local segBottom = math.min(iy + ih, segTop + baseH + 2) -- 2px overlap
        local segHeight = math.max(1, segBottom - segTop)
        
        -- Color based on segment center position
        local segCenter = segTop + segHeight * 0.5
        local t = (segCenter - iy) / math.max(1, ih)
        local segColor = getRainbowColor(baseOffset + t * 0.5, element)
        
        -- Get interpolated transparency for this position
        local segTransparency = getGradientTransparency(t, element)

        segments[i].Size = Vector2.new(iw, segHeight)
        segments[i].Position = Vector2.new(ix, segTop)
        segments[i].Color = segColor
        segments[i].Transparency = segTransparency
        segments[i].Visible = true
    end

    for i = segCount + 1, maxSegs do
        segments[i].Visible = false
    end
end

-- Draw box outline with gradient (same thickness/position as normal outline)
local function drawGradientBox(espObj, x, y, w, h, thickness, baseOffset)
    -- 4 sides: top, right, bottom, left - each drawn as segments
    local ix, iy, iw, ih = math.floor(x), math.floor(y), math.floor(w), math.floor(h)
    local th = thickness or 2

    -- Use inclusive pixel coordinates for edges (right/bottom are -1 from size)
    local right = ix + math.max(0, iw - 1)
    local bottom = iy + math.max(0, ih - 1)

    -- Side definitions: {startX, startY, endX, endY, isVertical}
    local sides = {
        {ix, iy, right, iy, false},           -- top
        {right, iy, right, bottom, true},     -- right
        {right, bottom, ix, bottom, false},   -- bottom
        {ix, bottom, ix, iy, true}            -- left
    }
    
    for sideIdx, side in ipairs(sides) do
        local sx, sy, ex, ey, isVert = side[1], side[2], side[3], side[4], side[5]
        local lineSegs = espObj.BoxLines[sideIdx]
        local segCount = #lineSegs
        
        if isVert then
            -- Vertical line: inclusive length
            local startY = math.min(sy, ey)
            local lineLen = math.abs(ey - sy) + 1
            local actualSegs = math.min(lineSegs and #lineSegs or 0, math.max(1, lineLen))
            if actualSegs == 0 then
                for i = 1, #lineSegs do lineSegs[i].Visible = false end
            else
                local baseLen = math.floor(lineLen / actualSegs)
                local rem = lineLen - baseLen * actualSegs
                local cur = startY
                for i = 1, actualSegs do
                    local thisLen = baseLen + (i <= rem and 1 or 0)
                    local segTop = cur
                    local segBottom = cur + thisLen - 1
                    local segCenter = (segTop + segBottom) * 0.5
                    local t = (segCenter - iy) / math.max(1, ih)

                    -- overlap vertically to avoid 1px gaps
                    local fromY = segTop - (i > 1 and 1 or 0)
                    local toY = segBottom + (i < actualSegs and 1 or 0)

                    lineSegs[i].From = Vector2.new(sx, fromY)
                    lineSegs[i].To = Vector2.new(sx, toY)
                    lineSegs[i].Thickness = th
                    lineSegs[i].Color = getRainbowColor(baseOffset + t * 0.5, "Box")
                    lineSegs[i].Transparency = 1
                    lineSegs[i].Visible = true

                    cur = cur + thisLen
                end

                for i = actualSegs + 1, #lineSegs do lineSegs[i].Visible = false end
            end
        else
            -- Horizontal line: inclusive length
            local startX = math.min(sx, ex)
            local lineLen = math.abs(ex - sx) + 1
            local actualSegs = math.min(lineSegs and #lineSegs or 0, math.max(1, lineLen))
            if actualSegs == 0 then
                for i = 1, #lineSegs do lineSegs[i].Visible = false end
            else
                local baseLen = math.floor(lineLen / actualSegs)
                local rem = lineLen - baseLen * actualSegs
                local cur = startX
                for i = 1, actualSegs do
                    local thisLen = baseLen + (i <= rem and 1 or 0)
                    local segLeft = cur
                    local segRight = cur + thisLen - 1
                    local segCenter = (segLeft + segRight) * 0.5
                    local t = (sy - iy) / math.max(1, ih)

                    local fromX = segLeft - (i > 1 and 1 or 0)
                    local toX = segRight + (i < actualSegs and 1 or 0)

                    lineSegs[i].From = Vector2.new(fromX, sy)
                    lineSegs[i].To = Vector2.new(toX, sy)
                    lineSegs[i].Thickness = th
                    lineSegs[i].Color = getRainbowColor(baseOffset + t * 0.5, "Box")
                    lineSegs[i].Transparency = 1
                    lineSegs[i].Visible = true

                    cur = cur + thisLen
                end

                for i = actualSegs + 1, #lineSegs do lineSegs[i].Visible = false end
            end
        end
    end
end

-- Draw health bar fill with gradient (same size/position as normal fill)
local function drawGradientHealthBar(espObj, fillX, fillY, fillW, fillH, isVertical, baseOffset)
    local segs = espObj.HealthBarGradient
    local maxSegs = #segs
    
    local ix, iy = math.floor(fillX), math.floor(fillY)
    local iw, ih = math.floor(fillW), math.floor(fillH)
    
    if iw <= 0 or ih <= 0 then
        for i = 1, maxSegs do segs[i].Visible = false end
        return
    end
    
    if isVertical then
        -- Vertical bar: allow segmentation to cover entire height even when iw/ih > pool
        local totalRows = ih
        local segCount = math.min(maxSegs, totalRows)
        local baseH = math.floor(totalRows / segCount)
        local remainder = totalRows - baseH * segCount
        local curY = iy
        for i = 1, segCount do
            local thisH = baseH + (i <= remainder and 1 or 0)
            local segTop = curY
            local segBottom = curY + thisH - 1
            local segCenter = (segTop + segBottom) * 0.5
            local t = ((segCenter - iy) + 0.5) / math.max(1, totalRows)

            segs[i].Size = Vector2.new(iw, segBottom - segTop + 1)
            segs[i].Position = Vector2.new(ix, segTop)
            segs[i].Color = getRainbowColor(baseOffset + t * 0.5, "HealthBar")
            segs[i].Transparency = 1
            segs[i].Visible = true

            curY = curY + thisH
        end

        for i = segCount + 1, maxSegs do segs[i].Visible = false end
    else
        -- Horizontal bar: allow segmentation to cover entire width
        local totalCols = iw
        local segCount = math.min(maxSegs, totalCols)
        local baseW = math.floor(totalCols / segCount)
        local remainder = totalCols - baseW * segCount
        local curX = ix
        for i = 1, segCount do
            local thisW = baseW + (i <= remainder and 1 or 0)
            local segLeft = curX
            local segRight = curX + thisW - 1
            local segCenter = (segLeft + segRight) * 0.5
            local t = ((segCenter - ix) + 0.5) / math.max(1, totalCols)

            segs[i].Size = Vector2.new(segRight - segLeft + 1, ih)
            segs[i].Position = Vector2.new(segLeft, iy)
            segs[i].Color = getRainbowColor(baseOffset + t * 0.5, "HealthBar")
            segs[i].Transparency = 1
            segs[i].Visible = true

            curX = curX + thisW
        end

        for i = segCount + 1, maxSegs do segs[i].Visible = false end
    end
end

local function hideGradient(espObj)
    for _, seg in ipairs(espObj.GradientSegments or {}) do seg.Visible = false end
end

local function hideBoxLines(espObj)
    for side = 1, 4 do
        for _, line in ipairs(espObj.BoxLines[side] or {}) do line.Visible = false end
    end
end

local function updateESP()

    for player, espObj in pairs(ESPObjects) do
        pcall(function()
            if not shouldShowPlayer(player) then 
                hideESP(espObj) 
                return 
            end
            
            local char = player and player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            
            if not char or not hrp or not hum or hum.Health <= 0 then
                hideESP(espObj)
                return
            end

            local distance = (hrp.Position - Camera.CFrame.Position).Magnitude
            if distance > ESPSettings.MaxDistance then
                hideESP(espObj)
                return
            end

            local rect = getScreenRectForCharacter(char) or getFallbackRect(char)
            if not rect then
                hideESP(espObj)
                return
            end

            -- Calculate colors with individual rainbow settings
            -- Use world-space Y position for camera-independent gradient (doesn't shift when camera moves)
            local worldY = 0
            if char and char.PrimaryPart then
                worldY = char.PrimaryPart.Position.Y
            elseif char and char:FindFirstChild("HumanoidRootPart") then
                worldY = char.HumanoidRootPart.Position.Y
            end
            
            -- Normalize world Y to 0-1 range (assuming typical world height 0-500)
            local baseOffset = (worldY % 500) / 500
            
            -- For non-box elements, use their Y position relative to box
            local topColor = getRainbowColor(baseOffset, "Box")                    -- Top of box
            local centerColor = getRainbowColor(baseOffset + 0.25, "Chams")          -- Center of box
            local bottomColor = getRainbowColor(baseOffset + 0.5, "Tracer")           -- Bottom of box
            
            local boxColor = ESPSettings.BoxRainbow and topColor or (ESPSettings.BoxCustomColor1 or ESPSettings.BoxColor)
            -- Tracer ends at bottom of box, so use bottom color
            local tracerColor = ESPSettings.TracerRainbow and bottomColor or (ESPSettings.TracerCustomColor1 or ESPSettings.TracerColor)
            -- Chams use center color
            local chamColor = ESPSettings.ChamsRainbow and centerColor or (ESPSettings.ChamsCustomColor1 or ESPSettings.GlobalChamColor)
            -- Name is above box; when using rainbow, use Name element colors
            local nameColor = ESPSettings.NameRainbow and getRainbowColor(baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)

            -- precompute box coordinates so healthbar/chams can render even when ESP visuals are disabled
            local x, y, w, h = rect.x, rect.y, rect.w, rect.h

            if ESPSettings.Enabled then
                -- Hide all text objects first to prevent leftover visibility
                espObj.Name.Visible = false
                espObj.HealthText.Visible = false
                espObj.DistanceText.Visible = false
                
                -- Text: render Name, Health and Distance as separate Drawing.Text objects so
                -- each can be positioned independently and receive per-element rainbow colors.
                local topList, bottomList, leftList, rightList = {}, {}, {}, {}

                if ESPSettings.ShowName then
                    local nameText = ESPSettings.UseDisplayName and player.DisplayName or player.Name
                    table.insert((ESPSettings.NamePosition or "Top") == "Top" and topList or (ESPSettings.NamePosition == "Bottom" and bottomList or (ESPSettings.NamePosition == "Left" and leftList or rightList)), {key = "Name", text = nameText})
                end
                -- Health text is now positioned relative to the health bar (handled below)
                if ESPSettings.ShowDistance then
                    table.insert((ESPSettings.DistancePosition or "Top") == "Top" and topList or (ESPSettings.DistancePosition == "Bottom" and bottomList or (ESPSettings.DistancePosition == "Left" and leftList or rightList)), {key = "Distance", text = math.floor(distance) .. "m"})
                end

                -- Collect simple custom text entries and append to top by default
                local customTopConcat
                for entryName, entry in pairs(ESPSettings.TextEntries) do
                    if entry.Enabled and entry.GetText then
                        local customText = entry.GetText(player, char, hum, distance)
                        if customText then
                            customTopConcat = customTopConcat and (customTopConcat .. " | " .. customText) or customText
                        end
                    end
                end

                -- Positioning helpers
                local lineHeight = 17 -- Fixed line height for consistent spacing

                -- Helper to detect collisions of multiple items in same anchor; when multiple
                -- items share the same anchor use the | combined system for clean display
                local function shouldCombine(list, anchor)
                    -- Use combined single-line for Top and Bottom anchors (cleaner UX)
                    return (anchor == "Top" or anchor == "Bottom") and list and #list > 1
                end

                local function renderCombined(list, anchor)
                    if not list or #list == 0 then return end
                    local texts = {}
                    for _, item in ipairs(list) do table.insert(texts, item.text) end
                    local combined = table.concat(texts, " | ")
                    local x = math.floor(rect.cx)
                    local y
                    if anchor == "Top" then
                        y = math.floor(rect.y - 18)
                        if ESPSettings.HealthBarEnabled and ESPSettings.HealthBarPosition == "Top" then
                            y = y - ESPSettings.HealthBarThickness - 4
                        end
                    elseif anchor == "Bottom" then
                        y = math.floor(rect.y + rect.h + 12)
                    elseif anchor == "Left" then
                        y = math.floor(rect.cy)
                        x = math.floor(rect.x - 6)
                    else
                        y = math.floor(rect.cy)
                        x = math.floor(rect.x + rect.w + 6)
                    end
                    espObj.Name.Center = (anchor == "Top" or anchor == "Bottom")
                    espObj.Name.Size = 13
                    espObj.Name.Font = ESPSettings.TextFont or 2
                    espObj.Name.Text = combined
                    espObj.Name.Position = Vector2.new(x, y)
                    espObj.Name.Color = ESPSettings.NameColor
                    espObj.Name.Visible = true
                    -- hide individual texts when combined
                    if espObj.HealthText then espObj.HealthText.Visible = false end
                    if espObj.DistanceText then espObj.DistanceText.Visible = false end
                end

                local function renderList(list, anchor)
                    if not list or #list == 0 then return end
                    if shouldCombine(list, anchor) then
                        renderCombined(list, anchor)
                        return
                    end

                    if anchor == "Top" then
                        -- stack upward: first item just above box (matching previous default)
                        for i, item in ipairs(list) do
                            local y = math.floor(rect.y - 18 - (i - 1) * lineHeight)
                            if ESPSettings.HealthBarEnabled and ESPSettings.HealthBarPosition == "Top" then
                                y = y - ESPSettings.HealthBarThickness - 4
                            end
                            local x = math.floor(rect.cx)
                            local col
                            if item.key == "Name" then
                                col = ESPSettings.NameRainbow and getStaticGradientColor(baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)
                                espObj.Name.Center = true
                                espObj.Name.Size = 13
                                espObj.Name.Font = ESPSettings.TextFont or 2
                                espObj.Name.Text = item.text
                                espObj.Name.Position = Vector2.new(x, y)
                                espObj.Name.Color = col
                                espObj.Name.Visible = true
                            elseif item.key == "Health" then
                                col = ESPSettings.HealthTextRainbow and getStaticGradientColor(baseOffset, "HealthText") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.HealthText.Center = true
                                espObj.HealthText.Size = 13
                                espObj.HealthText.Font = ESPSettings.TextFont or 2
                                espObj.HealthText.Text = item.text
                                espObj.HealthText.Position = Vector2.new(x, y)
                                espObj.HealthText.Color = col
                                espObj.HealthText.Visible = true
                            elseif item.key == "Distance" then
                                col = ESPSettings.DistanceRainbow and getStaticGradientColor(baseOffset, "Distance") or (ESPSettings.DistanceCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.DistanceText.Center = true
                                espObj.DistanceText.Size = 13
                                espObj.DistanceText.Font = ESPSettings.TextFont or 2
                                espObj.DistanceText.Text = item.text
                                espObj.DistanceText.Position = Vector2.new(x, y)
                                espObj.DistanceText.Color = col
                                espObj.DistanceText.Visible = true
                            end
                        end
                    elseif anchor == "Bottom" then
                        for i, item in ipairs(list) do
                            local y = math.floor(rect.y + rect.h + 12 + (i - 1) * lineHeight)
                            local x = math.floor(rect.cx)
                            local col
                            if item.key == "Name" then
                                col = ESPSettings.NameRainbow and getStaticGradientColor(baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)
                                espObj.Name.Center = true
                                espObj.Name.Size = 13
                                espObj.Name.Font = ESPSettings.TextFont or 2
                                espObj.Name.Text = item.text
                                espObj.Name.Position = Vector2.new(x, y)
                                espObj.Name.Color = col
                                espObj.Name.Visible = true
                            elseif item.key == "Health" then
                                col = ESPSettings.HealthTextRainbow and getStaticGradientColor(baseOffset, "HealthText") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.HealthText.Center = true
                                espObj.HealthText.Size = 13
                                espObj.HealthText.Font = ESPSettings.TextFont or 2
                                espObj.HealthText.Text = item.text
                                espObj.HealthText.Position = Vector2.new(x, y)
                                espObj.HealthText.Color = col
                                espObj.HealthText.Visible = true
                            elseif item.key == "Distance" then
                                col = ESPSettings.DistanceRainbow and getStaticGradientColor(baseOffset, "Distance") or (ESPSettings.DistanceCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.DistanceText.Center = true
                                espObj.DistanceText.Size = 13
                                espObj.DistanceText.Font = ESPSettings.TextFont or 2
                                espObj.DistanceText.Text = item.text
                                espObj.DistanceText.Position = Vector2.new(x, y)
                                espObj.DistanceText.Color = col
                                espObj.DistanceText.Visible = true
                            end
                        end
                    else
                        -- Left/Right: vertically centered stacking
                        local startY = rect.cy - ((#list - 1) / 2) * lineHeight
                        for i, item in ipairs(list) do
                            local y = math.floor(startY + (i - 1) * lineHeight)
                            local x
                            if anchor == "Left" then x = math.floor(rect.x - 6) else x = math.floor(rect.x + rect.w + 6) end
                            local col
                            if item.key == "Name" then
                                col = ESPSettings.NameRainbow and getStaticGradientColor(baseOffset, "Name") or (ESPSettings.NameCustomColor1 or ESPSettings.NameColor)
                                espObj.Name.Center = false
                                espObj.Name.Size = 13
                                espObj.Name.Font = ESPSettings.TextFont or 2
                                espObj.Name.Text = item.text
                                espObj.Name.Position = Vector2.new(x, y)
                                espObj.Name.Color = col
                                espObj.Name.Visible = true
                            elseif item.key == "Health" then
                                col = ESPSettings.HealthTextRainbow and getStaticGradientColor(baseOffset, "HealthText") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.HealthText.Center = false
                                espObj.HealthText.Size = 13
                                espObj.HealthText.Font = ESPSettings.TextFont or 2
                                espObj.HealthText.Text = item.text
                                espObj.HealthText.Position = Vector2.new(x, y)
                                espObj.HealthText.Color = col
                                espObj.HealthText.Visible = true
                            elseif item.key == "Distance" then
                                col = ESPSettings.DistanceRainbow and getStaticGradientColor(baseOffset, "Distance") or (ESPSettings.DistanceCustomColor1 or Color3.fromRGB(255,255,255))
                                espObj.DistanceText.Center = false
                                espObj.DistanceText.Size = 13
                                espObj.DistanceText.Font = ESPSettings.TextFont or 2
                                espObj.DistanceText.Text = item.text
                                espObj.DistanceText.Position = Vector2.new(x, y)
                                espObj.DistanceText.Color = col
                                espObj.DistanceText.Visible = true
                            end
                        end
                    end
                end

                renderList(topList, "Top")
                renderList(bottomList, "Bottom")
                renderList(leftList, "Left")
                renderList(rightList, "Right")

                -- Render any collected custom text entries as a single top line (if present)
                if customTopConcat and customTopConcat ~= "" then
                    local y = math.floor(rect.y - 18 - (#topList) * lineHeight)
                    if ESPSettings.HealthBarEnabled and ESPSettings.HealthBarPosition == "Top" then
                        y = y - ESPSettings.HealthBarThickness - 4
                    end
                    espObj.Name.Center = true
                    espObj.Name.Size = 13
                    espObj.Name.Font = ESPSettings.TextFont or 2
                    espObj.Name.Text = customTopConcat
                    espObj.Name.Position = Vector2.new(math.floor(rect.cx), y)
                    espObj.Name.Color = ESPSettings.NameColor
                    espObj.Name.Visible = true
                end

                -- Equipped display (Bottom / Image handling)
                if ESPSettings.EquippedEnabled then
                    -- If image mode and image support exists, try to show image; otherwise fall back to text showing tool name or 'None'
                    local showImage = (ESPSettings.EquippedMode == "Image") and espObj.EquippedImage ~= nil
                    local mappedImage = nil
                    if showImage then
                        local toolKey = equippedName and equippedName:lower() or nil
                        if toolKey and getgenv().TrisESP then
                            -- check place-specific mapping first
                            local placeMap = getgenv().TrisESP.PlaceToolImages and getgenv().TrisESP.PlaceToolImages[tostring(game.PlaceId)]
                            if placeMap and placeMap[toolKey] then
                                mappedImage = placeMap[toolKey]
                            end
                            -- then global mapping
                            if not mappedImage and getgenv().TrisESP.ToolImages then
                                mappedImage = getgenv().TrisESP.ToolImages[toolKey]
                            end
                        end
                        -- fallback to global EquippedImage setting
                        if not mappedImage and ESPSettings.EquippedImage and ESPSettings.EquippedImage ~= "" then mappedImage = ESPSettings.EquippedImage end
                    end

                    if ESPSettings.EquippedMode == "Image" and showImage and mappedImage then
                        -- Hide text and show image
                        espObj.EquippedText.Visible = false
                        espObj.EquippedImage.Data = mappedImage
                        espObj.EquippedImage.Size = Vector2.new(32, 32)
                        if ESPSettings.EquippedPosition == "Inline" then
                            espObj.EquippedImage.Position = Vector2.new(rect.cx, rect.y - 32)
                        else
                            espObj.EquippedImage.Position = Vector2.new(rect.cx, rect.y + rect.h + 6)
                        end
                        espObj.EquippedImage.Visible = true
                    else
                        -- show text (tool name or 'None') in the chosen position
                        espObj.EquippedImage.Visible = false
                        local txt = equippedName or "None"
                        espObj.EquippedText.Text = txt
                        if ESPSettings.EquippedPosition == "Inline" then
                            -- inline already included in name, hide separate equipped text
                            espObj.EquippedText.Visible = false
                        else
                            espObj.EquippedText.Position = Vector2.new(math.floor(rect.cx), math.floor(rect.y + rect.h + 12))
                            espObj.EquippedText.Color = nameColor
                            espObj.EquippedText.Size = 13
                            espObj.EquippedText.Font = ESPSettings.TextFont or 2
                            espObj.EquippedText.Visible = true
                        end
                    end
                else
                    if espObj.EquippedImage then espObj.EquippedImage.Visible = false end
                    if espObj.EquippedText then espObj.EquippedText.Visible = false end
                end

                -- Tracers
                if ESPSettings.Tracers then
                    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
                    local fromPos
                    if ESPSettings.TracerFrom == "Bottom" then
                        fromPos = Vector2.new(vw/2, vh)
                    elseif ESPSettings.TracerFrom == "Top" then
                        fromPos = Vector2.new(vw/2, 0)
                    elseif ESPSettings.TracerFrom == "Mouse" then
                        fromPos = UserInputService:GetMouseLocation()
                    else
                        fromPos = Vector2.new(vw/2, vh/2)
                    end
                    espObj.Tracer.From = fromPos
                    espObj.Tracer.To = Vector2.new(rect.cx, rect.y + rect.h)
                    espObj.Tracer.Color = tracerColor
                    espObj.Tracer.Thickness = ESPSettings.TracerThickness
                    espObj.Tracer.Visible = true
                else
                    espObj.Tracer.Visible = false
                end

                -- Box fill (independent from Box ESP)
                if ESPSettings.BoxFill then
                    local ix, iy, iw, ih = math.floor(x), math.floor(y), math.floor(w), math.floor(h)
                    
                    if ESPSettings.BoxFillRainbow then
                        -- Rainbow fill: use gradient segments with SAME size as normal fill
                        drawGradientFill(espObj, ix, iy, iw, ih, 1 - ESPSettings.BoxFillTransparency, baseOffset, "BoxFill")
                        espObj.BoxFill.Visible = false
                    else
                        -- Normal fill: single colored square
                        hideGradient(espObj)
                        local fillColor = ESPSettings.BoxFillCustomColor1 or ESPSettings.BoxFillColor
                        espObj.BoxFill.Size = Vector2.new(iw, ih)
                        espObj.BoxFill.Position = Vector2.new(ix, iy)
                        espObj.BoxFill.Color = fillColor
                        espObj.BoxFill.Transparency = 1 - ESPSettings.BoxFillTransparency
                        espObj.BoxFill.Visible = true
                    end
                else
                    espObj.BoxFill.Visible = false
                    hideGradient(espObj)
                end

                -- Boxes (outline)
                if ESPSettings.Boxes then
                    local ix, iy, iw, ih = math.floor(x), math.floor(y), math.floor(w), math.floor(h)
                    local thickness = ESPSettings.Thickness or 2
                    
                    if ESPSettings.BoxType == "Square" then
                        if ESPSettings.BoxRainbow then
                            -- Rainbow box: use line segments with SAME position/thickness as normal outline
                            drawGradientBox(espObj, ix, iy, iw, ih, thickness, baseOffset)
                            if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                        else
                            -- Normal box: single square outline
                            hideBoxLines(espObj)
                            if espObj.OutlineSquare then
                                espObj.OutlineSquare.Size = Vector2.new(iw, ih)
                                espObj.OutlineSquare.Position = Vector2.new(ix, iy)
                                espObj.OutlineSquare.Color = boxColor
                                espObj.OutlineSquare.Thickness = thickness
                                espObj.OutlineSquare.Visible = true
                            end
                        end
                        for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
                    else
                        -- Corner box
                        if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                        hideBoxLines(espObj)
                        
                        local L = math.clamp(math.floor(math.min(w, h) * 0.25), 2, 50)
                        local fx, fy, fw, fh = math.floor(x), math.floor(y), math.floor(w), math.floor(h)
                        local corners = {
                            {fx, fy, fx + L, fy, fx, fy + L},
                            {fx + fw, fy, fx + fw - L, fy, fx + fw, fy + L},
                            {fx, fy + fh, fx + L, fy + fh, fx, fy + fh - L},
                            {fx + fw, fy + fh, fx + fw - L, fy + fh, fx + fw, fy + fh - L}
                        }
                        
                        local cornerYs = {0, 0, 1, 1}
                        
                        for i, corner in ipairs(corners) do
                            local c = espObj.Corners[i]
                            c.Line1.From = Vector2.new(corner[1], corner[2])
                            c.Line1.To = Vector2.new(corner[3], corner[4])
                            c.Line2.From = Vector2.new(corner[1], corner[2])
                            c.Line2.To = Vector2.new(corner[5], corner[6])
                            if ESPSettings.BoxRainbow then
                                local yProgress = cornerYs[i]
                                c.Line1.Color = getRainbowColor(baseOffset + yProgress * 0.5, "Box")
                                c.Line2.Color = getRainbowColor(baseOffset + yProgress * 0.5, "Box")
                            else
                                c.Line1.Color, c.Line2.Color = boxColor, boxColor
                            end
                            c.Line1.Thickness = thickness
                            c.Line2.Thickness = thickness
                            c.Line1.Visible, c.Line2.Visible = true, true
                        end
                    end
                else
                    -- Hide box outlines when Boxes disabled
                    hideBoxLines(espObj)
                    if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                    for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
                end
                
            else
                -- ESP disabled - hide all visuals
                espObj.Name.Visible = false
                espObj.Tracer.Visible = false
                hideBoxLines(espObj)
                espObj.BoxFill.Visible = false
                hideGradient(espObj)
                for _, c in ipairs(espObj.Corners) do c.Line1.Visible, c.Line2.Visible = false, false end
                if espObj.OutlineSquare then espObj.OutlineSquare.Visible = false end
                if espObj.EquippedText then espObj.EquippedText.Visible = false end
                if espObj.EquippedImage then espObj.EquippedImage.Visible = false end
            end

            -- Health bar
            if ESPSettings.Enabled and ESPSettings.HealthBarEnabled and rect then
                local maxHealth = math.max(1, hum.MaxHealth or 100)
                local ratio = math.clamp(hum.Health / maxHealth, 0, 1)
                local thickness = ESPSettings.HealthBarThickness or 6
                local pos = ESPSettings.HealthBarPosition
                local isVertical = (pos == "Left" or pos == "Right")
                
                -- Calculate bar and fill dimensions
                local barX, barY, barW, barH, fillX, fillY, fillW, fillH
                
                if pos == "Left" then
                    barX, barY = x - thickness - 4, y
                    barW, barH = thickness, h
                    fillW, fillH = thickness, math.max(1, math.floor(h * ratio))
                    fillX, fillY = barX, y + h - fillH
                elseif pos == "Right" then
                    barX, barY = x + w + 4, y
                    barW, barH = thickness, h
                    fillW, fillH = thickness, math.max(1, math.floor(h * ratio))
                    fillX, fillY = barX, y + h - fillH
                elseif pos == "Top" then
                    barX, barY = x, y - thickness - 4
                    barW, barH = w, thickness
                    fillW, fillH = math.max(1, math.floor(w * ratio)), thickness
                    fillX, fillY = x, barY
                else -- Bottom
                    barX, barY = x, y + h + 4
                    barW, barH = w, thickness
                    fillW, fillH = math.max(1, math.floor(w * ratio)), thickness
                    fillX, fillY = x, barY
                end
                
                -- Floor all values
                barX, barY = math.floor(barX), math.floor(barY)
                barW, barH = math.floor(barW), math.floor(barH)
                fillX, fillY = math.floor(fillX), math.floor(fillY)
                fillW, fillH = math.floor(fillW), math.floor(fillH)

                -- Outline: follow the filled portion so it moves with health
                if ESPSettings.HealthBarOutline then
                    local outlineX = fillX - 1
                    local outlineY = fillY - 1
                    local outlineW = math.max(1, fillW + 2)
                    local outlineH = math.max(1, fillH + 2)
                    espObj.HealthBarOutline.Size = Vector2.new(outlineW, outlineH)
                    espObj.HealthBarOutline.Position = Vector2.new(outlineX, outlineY)
                    espObj.HealthBarOutline.Color = ESPSettings.HealthBarOutlineColor
                    espObj.HealthBarOutline.Visible = true
                else
                    espObj.HealthBarOutline.Visible = false
                end

                -- Health bar fill
                if ESPSettings.HealthBarRainbow then
                    -- Rainbow: use gradient with EXACT same dimensions as normal fill
                    espObj.HealthBar.Visible = false
                    drawGradientHealthBar(espObj, fillX, fillY, fillW, fillH, isVertical, baseOffset)
                else
                    -- Normal: single colored fill
                    for _, seg in ipairs(espObj.HealthBarGradient) do seg.Visible = false end
                    espObj.HealthBar.Size = Vector2.new(fillW, fillH)
                    espObj.HealthBar.Position = Vector2.new(fillX, fillY)
                    espObj.HealthBar.Color = getHealthColor(ratio)
                    espObj.HealthBar.Visible = true
                end

                -- Health text: positioned above the filled portion and moves with health
                if ESPSettings.ShowHealthText and espObj.HealthText then
                    local txt = tostring(math.floor(hum.Health))
                    espObj.HealthText.Text = txt
                    local tx = math.floor(fillX + (fillW / 2))
                    local ty = math.floor(fillY - 6)
                    espObj.HealthText.Center = true
                    espObj.HealthText.Size = 13
                    espObj.HealthText.Font = ESPSettings.TextFont or 2
                    espObj.HealthText.Position = Vector2.new(tx, ty)
                    local col = ESPSettings.HealthTextRainbow and getStaticGradientColor(baseOffset, "HealthText") or (ESPSettings.HealthTextCustomColor1 or Color3.fromRGB(255,255,255))
                    espObj.HealthText.Color = col
                    espObj.HealthText.Visible = true
                else
                    if espObj.HealthText then espObj.HealthText.Visible = false end
                end
            else
                espObj.HealthBar.Visible = false
                espObj.HealthBarOutline.Visible = false
                for _, seg in ipairs(espObj.HealthBarGradient) do seg.Visible = false end
            end

            -- Chams/Highlight
            if ESPSettings.Enabled and ESPSettings.Highlight then
                if not espObj.Highlight or espObj.Highlight.Parent ~= char then
                    if espObj.Highlight then pcall(function() espObj.Highlight:Destroy() end) end
                    espObj.Highlight = Instance.new("Highlight")
                    espObj.Highlight.Adornee = char
                    espObj.Highlight.Parent = char
                end
                espObj.Highlight.FillColor = chamColor
                espObj.Highlight.OutlineColor = chamColor
                espObj.Highlight.FillTransparency = ESPSettings.FillTransparency
                espObj.Highlight.OutlineTransparency = ESPSettings.OutlineTransparency
                espObj.Highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                espObj.Highlight.Enabled = true
            elseif espObj.Highlight then
                espObj.Highlight.Enabled = false
            end
        end)
    end
end

local function addESP(player)
    if not player or player == LocalPlayer or ESPObjects[player] then return end
    local espObj = createESPObject()
    espObj.Player = player
    ESPObjects[player] = espObj
    
    local function onCharAdded(char)
        task.wait(0.2)
        if ESPSettings.Highlight and char then
            if espObj.Highlight then pcall(function() espObj.Highlight:Destroy() end) end
            espObj.Highlight = Instance.new("Highlight")
            espObj.Highlight.Adornee = char
            espObj.Highlight.Parent = char
            espObj.Highlight.FillTransparency = ESPSettings.FillTransparency
            espObj.Highlight.OutlineTransparency = ESPSettings.OutlineTransparency
        end
    end
    
    player.CharacterAdded:Connect(onCharAdded)
    if player.Character then onCharAdded(player.Character) end
end

local function removePlayerESP(player)
    local espObj = ESPObjects[player]
    if not espObj then return end
    removeESP(espObj)
    ESPObjects[player] = nil
end

-- Object ESP System (for non-players)
local function createObjectESPConfig(name, options)
    options = options or {}
    local config = {
        Name = name,
        Enabled = options.Enabled or false,
        Color = options.Color or Color3.fromRGB(255, 255, 0),
        ShowName = options.ShowName ~= false,
        ShowDistance = options.ShowDistance ~= false,
        ShowBox = options.ShowBox ~= false,
        ShowTracer = options.ShowTracer or false,
        MaxDistance = options.MaxDistance or 500,
        Rainbow = options.Rainbow or false,
        Objects = {},
        ESPInstances = {},
        FindFunction = options.FindFunction -- Custom function to find objects
    }
    ObjectESPConfigs[name] = config
    return config
end

local function addObjectToESP(configName, obj, displayName)
    local config = ObjectESPConfigs[configName]
    if not config or not obj then return end
    if config.Objects[obj] then return end
    
    config.Objects[obj] = displayName or obj.Name
    
    local espObj = {
        Name = Drawing.new("Text"),
        Box = Drawing.new("Square"),
        BoxOutline = Drawing.new("Square"),
        Tracer = Drawing.new("Line")
    }
    
    espObj.Name.Center = true
    espObj.Name.Outline = true
    espObj.Name.OutlineColor = Color3.new(0, 0, 0)
    espObj.Name.Size = 13
    espObj.Name.Font = ESPSettings.TextFont or 2
    espObj.Name.Visible = false
    espObj.Name.ZIndex = 999
    
    espObj.Box.Thickness = 1
    espObj.Box.Filled = false
    espObj.Box.Visible = false
    
    espObj.BoxOutline.Thickness = 3
    espObj.BoxOutline.Filled = false
    espObj.BoxOutline.Color = Color3.new(0, 0, 0)
    espObj.BoxOutline.Visible = false
    
    espObj.Tracer.Thickness = 2
    espObj.Tracer.Visible = false
    
    config.ESPInstances[obj] = espObj
end

local function removeObjectFromESP(configName, obj)
    local config = ObjectESPConfigs[configName]
    if not config then return end
    
    config.Objects[obj] = nil
    local espObj = config.ESPInstances[obj]
    if espObj then
        pcall(function() espObj.Name:Remove() end)
        pcall(function() espObj.Box:Remove() end)
        pcall(function() espObj.BoxOutline:Remove() end)
        pcall(function() espObj.Tracer:Remove() end)
    end
    config.ESPInstances[obj] = nil
end

local function updateObjectESP()
    for configName, config in pairs(ObjectESPConfigs) do
        if config.Enabled and config.FindFunction then
            -- Auto-find objects using custom function
            local foundObjects = config.FindFunction()
            for _, obj in ipairs(foundObjects) do
                if not config.Objects[obj] then
                    addObjectToESP(configName, obj)
                end
            end
        end
        
        for obj, displayName in pairs(config.Objects) do
            local espObj = config.ESPInstances[obj]
            if not espObj then continue end
            
            pcall(function()
                if not config.Enabled or not obj or not obj.Parent then
                    espObj.Name.Visible = false
                    espObj.Box.Visible = false
                    espObj.BoxOutline.Visible = false
                    espObj.Tracer.Visible = false
                    if not obj or not obj.Parent then
                        removeObjectFromESP(configName, obj)
                    end
                    return
                end
                
                local rect = getObjectRect(obj)
                if not rect or rect.distance > config.MaxDistance then
                    espObj.Name.Visible = false
                    espObj.Box.Visible = false
                    espObj.BoxOutline.Visible = false
                    espObj.Tracer.Visible = false
                    return
                end
                
                local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
                local baseOffset = 0
                if rect and vh and vh > 0 then baseOffset = (rect.cy / vh) end
                local color = config.Rainbow and getRainbowColor(baseOffset, "Object") or config.Color
                
                -- Name
                if config.ShowName or config.ShowDistance then
                    local text = {}
                    if config.ShowName then table.insert(text, displayName) end
                    if config.ShowDistance then table.insert(text, math.floor(rect.distance) .. "m") end
                    espObj.Name.Text = table.concat(text, " | ")
                    espObj.Name.Position = Vector2.new(rect.cx, rect.y - 18)
                    espObj.Name.Color = color
                    espObj.Name.Visible = true
                else
                    espObj.Name.Visible = false
                end
                
                -- Box
                if config.ShowBox then
                    espObj.BoxOutline.Size = Vector2.new(rect.w + 2, rect.h + 2)
                    espObj.BoxOutline.Position = Vector2.new(rect.x - 1, rect.y - 1)
                    espObj.BoxOutline.Visible = true
                    
                    espObj.Box.Size = Vector2.new(rect.w, rect.h)
                    espObj.Box.Position = Vector2.new(rect.x, rect.y)
                    espObj.Box.Color = color
                    espObj.Box.Visible = true
                else
                    espObj.Box.Visible = false
                    espObj.BoxOutline.Visible = false
                end
                
                -- Tracer
                if config.ShowTracer then
                    local vw, vh = Camera.ViewportSize.X, Camera.ViewportSize.Y
                    espObj.Tracer.From = Vector2.new(vw/2, vh)
                    espObj.Tracer.To = Vector2.new(rect.cx, rect.y + rect.h)
                    espObj.Tracer.Color = color
                    espObj.Tracer.Visible = true
                else
                    espObj.Tracer.Visible = false
                end
            end)
        end
    end
end

-- Main render loop
-- FOV Circle drawing objects
local FOVCircleOutline = Drawing.new("Circle")
FOVCircleOutline.Thickness = 1
FOVCircleOutline.NumSides = 64
FOVCircleOutline.Filled = false
FOVCircleOutline.Transparency = 1
FOVCircleOutline.Color = Color3.new(0, 0, 0)
FOVCircleOutline.Visible = false

local FOVCircle = Drawing.new("Circle")
FOVCircle.Thickness = 1
FOVCircle.NumSides = 64
FOVCircle.Filled = false
FOVCircle.Transparency = 1
FOVCircle.Color = Color3.fromRGB(255, 255, 255)
FOVCircle.Visible = false

local FOVCircleFill = Drawing.new("Circle")
FOVCircleFill.Thickness = 1
FOVCircleFill.NumSides = 64
FOVCircleFill.Filled = true
FOVCircleFill.Transparency = 0.2
FOVCircleFill.Color = Color3.fromRGB(255, 255, 255)
FOVCircleFill.Visible = false

-- Gradient circle segments for FOV (for gradient/rainbow circle outline)
local FOV_GRADIENT_SEGMENTS = 128
local FOVGradientSegments = {}
for i = 1, FOV_GRADIENT_SEGMENTS do
    local seg = Drawing.new("Line")
    seg.Thickness = 1
    seg.Visible = false
    FOVGradientSegments[i] = seg
end

-- Gradient fill segments for FOV circle fill
local FOVFillGradientSegments = {}
for i = 1, FOV_GRADIENT_SEGMENTS do
    local seg = Drawing.new("Triangle")
    seg.Filled = true
    seg.Visible = false
    FOVFillGradientSegments[i] = seg
end

local function updateFOVCircle()
    if not ESPSettings.FOVCircleEnabled then
        FOVCircle.Visible = false
        FOVCircleOutline.Visible = false
        FOVCircleFill.Visible = false
        for _, seg in ipairs(FOVGradientSegments) do seg.Visible = false end
        for _, seg in ipairs(FOVFillGradientSegments) do seg.Visible = false end
        return
    end
    
    local center = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
    local radius = ESPSettings.FOVCircleRadius or 100
    local segments = math.min(ESPSettings.FOVCircleSegments or 128, FOV_GRADIENT_SEGMENTS)
    local thickness = ESPSettings.FOVCircleThickness or 1
    
    -- Determine if we need rainbow for outline
    local useRainbowOutline = ESPSettings.FOVCircleRainbow
    
    if useRainbowOutline then
        -- Hide solid circle, use rainbow segments with improved blending
        FOVCircle.Visible = false
        FOVCircleOutline.Visible = false
        
        for i = 1, segments do
            -- Smooth angle transitions with slight overlap for perfect blending
            local angle1 = ((i - 1) / segments) * math.pi * 2
            local angle2 = (i / segments) * math.pi * 2
            
            local p1 = center + Vector2.new(math.cos(angle1) * radius, math.sin(angle1) * radius)
            local p2 = center + Vector2.new(math.cos(angle2) * radius, math.sin(angle2) * radius)
            
            local seg = FOVGradientSegments[i]
            seg.From = p1
            seg.To = p2
            seg.Thickness = thickness + 0.5  -- Slight thickness increase for better blending
            seg.Transparency = 1 - (ESPSettings.FOVCircleTransparency or 0)
            
            -- Use time-based gradient with smoothstep for clean blending
            local t = i / segments
            seg.Color = getRainbowColor(t, "FOV")
            seg.Visible = true
        end
        
        -- Hide unused segments
        for i = segments + 1, FOV_GRADIENT_SEGMENTS do
            FOVGradientSegments[i].Visible = false
        end
    else
        -- Use solid circle
        for _, seg in ipairs(FOVGradientSegments) do seg.Visible = false end
        
        -- Outline
        FOVCircleOutline.Position = center
        FOVCircleOutline.Radius = radius + 1
        FOVCircleOutline.Thickness = thickness + 2
        FOVCircleOutline.NumSides = segments
        FOVCircleOutline.Color = Color3.new(0, 0, 0)
        FOVCircleOutline.Transparency = 1 - (ESPSettings.FOVCircleTransparency or 0)
        FOVCircleOutline.Visible = true
        
        -- Main circle
        FOVCircle.Position = center
        FOVCircle.Radius = radius
        FOVCircle.Thickness = thickness
        FOVCircle.NumSides = segments
        FOVCircle.Color = ESPSettings.FOVCircleColor
        FOVCircle.Transparency = 1 - (ESPSettings.FOVCircleTransparency or 0)
        FOVCircle.Visible = true
    end
    
    -- Fill circle with improved rendering
    if ESPSettings.FOVCircleFilled then
        if ESPSettings.FOVCircleFillRainbow then
            -- For rainbow fill: Use a solid base circle + gradient ring overlay
            -- This avoids the cross/triangle overlap artifacts
            
            -- First, draw a solid fill as the base (no transparency issues)
            FOVCircleFill.Position = center
            FOVCircleFill.Radius = radius
            FOVCircleFill.NumSides = segments
            -- Use the average/middle color of the gradient as base
            FOVCircleFill.Color = getRainbowColor(0.5, "FOV")
            FOVCircleFill.Transparency = 1 - (ESPSettings.FOVCircleFillTransparency or 0.8)
            FOVCircleFill.Filled = true
            FOVCircleFill.Visible = true
            
            -- Now overlay thin ring segments for gradient effect at the edge
            local ringWidth = math.max(radius * 0.3, 10) -- Inner ring for gradient
            local innerR = radius - ringWidth
            local outerR = radius + 1
            
            for i = 1, segments do
                local angle1 = ((i - 1) / segments) * math.pi * 2
                local angle2 = (i / segments) * math.pi * 2
                -- Slight overlap to avoid seams
                local overlapAngle = 0.02
                angle1 = angle1 - overlapAngle
                angle2 = angle2 + overlapAngle

                -- Create quad-like shape using inner/outer radius (not center)
                local outerP1 = center + Vector2.new(math.cos(angle1) * outerR, math.sin(angle1) * outerR)
                local outerP2 = center + Vector2.new(math.cos(angle2) * outerR, math.sin(angle2) * outerR)
                local innerP1 = center + Vector2.new(math.cos(angle1) * innerR, math.sin(angle1) * innerR)

                local seg = FOVFillGradientSegments[i]
                seg.PointA = innerP1
                seg.PointB = outerP1
                seg.PointC = outerP2
                seg.Filled = true
                seg.Transparency = 1 - (ESPSettings.FOVCircleFillTransparency or 0.8)

                local t = (i - 0.5) / segments
                seg.Color = getRainbowColor(t, "FOV")
                seg.Visible = true
            end
            
            -- Hide unused
            for i = segments + 1, FOV_GRADIENT_SEGMENTS do
                FOVFillGradientSegments[i].Visible = false
            end
        else
            -- Solid fill
            for _, seg in ipairs(FOVFillGradientSegments) do seg.Visible = false end
            
            FOVCircleFill.Position = center
            FOVCircleFill.Radius = radius
            FOVCircleFill.NumSides = segments
            FOVCircleFill.Color = ESPSettings.FOVCircleFillColor
            FOVCircleFill.Transparency = 1 - (ESPSettings.FOVCircleFillTransparency or 0.8)
            FOVCircleFill.Filled = true
            FOVCircleFill.Visible = true
        end
    else
        FOVCircleFill.Visible = false
        for _, seg in ipairs(FOVFillGradientSegments) do seg.Visible = false end
    end
end

local function mainUpdate()
    -- advance shared rainbow hue so all rainbow toggles stay in sync
    RainbowHue = (RainbowHue + (ESPSettings.RainbowSpeed or 1) * 0.001) % 1
    updateESP()
    updateObjectESP()
    updateFOVCircle()
end

if renderConn then renderConn:Disconnect() end
renderConn = RunService.RenderStepped:Connect(mainUpdate)

for _, p in ipairs(Players:GetPlayers()) do addESP(p) end
Players.PlayerAdded:Connect(addESP)
Players.PlayerRemoving:Connect(removePlayerESP)

-- ==================== HELPER FUNCTIONS ====================
-- Helper to enable/disable all player ESP visuals immediately
local function setGlobalESPEnabled(enabled)
    ESPSettings.Enabled = enabled
    for player, espObj in pairs(ESPObjects) do
        pcall(function()
            if not enabled then
                hideESP(espObj)
            end
        end)
    end
end

-- Expose API globally for external scripts
getgenv().TrisESP = {
    -- Direct access to settings table - modify any setting directly
    -- Example: getgenv().TrisESP.Settings.Boxes = true
    Settings = ESPSettings,
    
    -- Direct access to object ESP configs
    -- Example: getgenv().TrisESP.ObjectConfigs["Diamond"].Enabled = false
    ObjectConfigs = ObjectESPConfigs,
    
    -- Enable/disable all ESP immediately
    SetEnabled = setGlobalESPEnabled,
    
    -- === PLAYER FILTERING ===
    -- Whitelist a player (only show whitelisted players)
    -- Usage: TrisESP.WhitelistPlayer("PlayerName")
    WhitelistPlayer = function(playerName)
        -- Accept string, Instance (Player/Folder/Model), or table of such
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.WhitelistPlayer(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.WhitelistedEntities[playerName] = true
            return
        end
        if type(playerName) == "string" then
            ESPSettings.WhitelistedPlayers[playerName] = true
            return
        end
    end,
    
    -- Blacklist a player (hide specific players)
    -- Usage: TrisESP.BlacklistPlayer("PlayerName")
    BlacklistPlayer = function(playerName)
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.BlacklistPlayer(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.BlacklistedEntities[playerName] = true
            return
        end
        if type(playerName) == "string" then
            ESPSettings.BlacklistedPlayers[playerName] = true
            return
        end
    end,
    
    -- Remove from whitelist
    RemoveWhitelist = function(playerName)
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.RemoveWhitelist(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.WhitelistedEntities[playerName] = nil
            return
        end
        ESPSettings.WhitelistedPlayers[playerName] = nil
    end,
    
    -- Remove from blacklist
    RemoveBlacklist = function(playerName)
        if type(playerName) == "table" then
            for _, v in ipairs(playerName) do getgenv().TrisESP.RemoveBlacklist(v) end
            return
        end
        if typeof(playerName) == "Instance" then
            ESPSettings.BlacklistedEntities[playerName] = nil
            return
        end
        ESPSettings.BlacklistedPlayers[playerName] = nil
    end,
    
    -- Set filter mode: "All", "Whitelist", "Blacklist"
    -- Usage: TrisESP.SetFilterMode("Whitelist")
    SetFilterMode = function(mode)
        ESPSettings.FilterMode = mode
    end,
    
    -- === TEAM CONFIGURATION ===
    -- Enable/disable team check (when enabled, teammates are auto-hidden)
    -- Usage: TrisESP.EnableTeamCheck(true)
    EnableTeamCheck = function(enabled)
        ESPSettings.TeamCheckEnabled = enabled
    end,
    
    -- Set team detection mode: "Auto", "RobloxTeams", "Folder", "Custom"
    -- Usage: TrisESP.SetTeamMode("Folder")
    SetTeamMode = function(mode)
        ESPSettings.TeamDetectionMode = mode
    end,
    
    -- Set custom team folder (for folder-based team detection)
    -- Usage: TrisESP.SetTeamFolder(workspace.Teams)
    SetTeamFolder = function(folder)
        if typeof(folder) == "Instance" and folder:IsA("Folder") then
            ESPSettings.CustomTeamFolder = folder
            ESPSettings.TeamDetectionMode = "Folder"
        end
    end,
    
    -- Set custom team detection function
    -- Usage: TrisESP.SetCustomTeamFunction(function(player1, player2) return player1:GetAttribute("Team") == player2:GetAttribute("Team") end)
    SetCustomTeamFunction = function(func)
        if type(func) == "function" then
            ESPSettings.CustomTeamFunction = func
            ESPSettings.TeamDetectionMode = "Custom"
        end
    end,
    
    -- === TEXT CUSTOMIZATION ===
    -- Add custom text to ESP (super easy!)
    -- Usage: TrisESP.AddTextEntry("Weapon", function(player, char, hum, dist) return "AK-47" end, 4)
    -- Order: 1=Name, 2=Health, 3=Distance, 4+=Custom
    AddTextEntry = function(name, getTextFunc, order)
        ESPSettings.TextEntries[name] = {
            Enabled = true,
            Order = order or 99,
            GetText = getTextFunc  -- function(player, char, humanoid, distance) -> string or nil
        }
    end,
    
    RemoveTextEntry = function(name)
        ESPSettings.TextEntries[name] = nil
    end,
    
    SetTextEntryEnabled = function(name, enabled)
        if ESPSettings.TextEntries[name] then
            ESPSettings.TextEntries[name].Enabled = enabled
        end
    end,
    
    -- Toggle built-in text elements
    -- Usage: TrisESP.ShowName(false)
    ShowName = function(enabled)
        ESPSettings.ShowName = enabled
    end,
    
    ShowHealth = function(enabled)
        ESPSettings.ShowHealthText = enabled
    end,
    
    ShowDistance = function(enabled)
        ESPSettings.ShowDistance = enabled
    end,
    
    -- === OBJECT ESP (SIMPLIFIED) ===
    -- Quick add single object with optional custom name
    -- Usage: TrisESP.AddSimpleObjectESP(workspace.Diamond, "Diamond", {Color = Color3.new(0,1,1), Rainbow = true})
    AddSimpleObjectESP = function(object, displayName, options)
        options = options or {}
        local configName = displayName or object.Name
        
        if not ObjectESPConfigs[configName] then
            createObjectESPConfig(configName, {
                Enabled = true,
                Color = options.Color or Color3.fromRGB(255, 255, 0),
                Rainbow = options.Rainbow or false,
                ShowName = options.ShowName ~= false,
                ShowDistance = options.ShowDistance ~= false,
                ShowBox = options.ShowBox ~= false,
                ShowTracer = options.ShowTracer or false,
                MaxDistance = options.MaxDistance or 500
            })
        end
        
        addObjectToESP(configName, object, displayName)
    end,
    
    -- Remove single object from ESP
    RemoveSimpleObjectESP = function(object, configName)
        removeObjectFromESP(configName, object)
    end,
    
    -- Auto-track objects by name in workspace (super easy!)
    -- Usage: TrisESP.TrackObjectsByName("Diamond", {Color = Color3.new(0,1,1), Rainbow = true})
    TrackObjectsByName = function(objectName, options)
        options = options or {}
        createObjectESPConfig(objectName, {
            Enabled = true,
            Color = options.Color or Color3.fromRGB(255, 255, 0),
            Rainbow = options.Rainbow or false,
            ShowName = options.ShowName ~= false,
            ShowDistance = options.ShowDistance ~= false,
            ShowBox = options.ShowBox ~= false,
            ShowTracer = options.ShowTracer or false,
            MaxDistance = options.MaxDistance or 500,
            FindFunction = function()
                local items = {}
                for _, obj in ipairs(Workspace:GetDescendants()) do
                    if obj.Name == objectName and (obj:IsA("BasePart") or obj:IsA("Model")) then
                        table.insert(items, obj)
                    end
                end
                return items
            end
        })
    end,
    
    -- Track objects in a specific folder
    -- Usage: TrisESP.TrackFolder(workspace.Items, "Items", {Color = Color3.new(1,1,0)})
    TrackFolder = function(folder, configName, options)
        options = options or {}
        configName = configName or folder.Name
        createObjectESPConfig(configName, {
            Enabled = true,
            Color = options.Color or Color3.fromRGB(255, 255, 0),
            Rainbow = options.Rainbow or false,
            ShowName = options.ShowName ~= false,
            ShowDistance = options.ShowDistance ~= false,
            ShowBox = options.ShowBox ~= false,
            ShowTracer = options.ShowTracer or false,
            MaxDistance = options.MaxDistance or 500,
            FindFunction = function()
                local items = {}
                if folder and folder.Parent then
                    for _, obj in ipairs(folder:GetChildren()) do
                        if obj:IsA("BasePart") or obj:IsA("Model") then
                            table.insert(items, obj)
                        end
                    end
                end
                return items
            end
        })
    end,
    
    -- Enable/disable object category
    EnableObjectCategory = function(configName, enabled)
        if ObjectESPConfigs[configName] then
            ObjectESPConfigs[configName].Enabled = enabled
        end
    end,
    
    -- === PER-PLAYER ESP (EASY API) ===
    -- Store per-player custom settings
    PlayerCustomSettings = {},
    
    -- Add ESP to a specific player with custom settings
    -- Usage: TrisESP.AddPlayerESP("PlayerName", {BoxColor = Color3.new(1,0,0), Rainbow = true, ShowName = true})
    -- Options: BoxColor, BoxRainbow, TracerColor, TracerRainbow, ShowName, ShowDistance, ShowHealthBar, Highlight, HighlightColor
    AddPlayerESP = function(playerNameOrInstance, options)
        options = options or {}
        local playerName
        local player
        
        if typeof(playerNameOrInstance) == "Instance" and playerNameOrInstance:IsA("Player") then
            player = playerNameOrInstance
            playerName = player.Name
        else
            playerName = tostring(playerNameOrInstance)
            player = Players:FindFirstChild(playerName)
        end
        
        if not playerName then return end
        
        -- Store custom settings for this player
        getgenv().TrisESP.PlayerCustomSettings[playerName] = {
            BoxColor = options.BoxColor,
            BoxRainbow = options.BoxRainbow,
            TracerColor = options.TracerColor,
            TracerRainbow = options.TracerRainbow,
            ShowName = options.ShowName,
            ShowDistance = options.ShowDistance,
            ShowHealthBar = options.ShowHealthBar,
            Highlight = options.Highlight,
            HighlightColor = options.HighlightColor,
            CustomText = options.CustomText
        }
        
        -- Whitelist this player so they show even in whitelist mode
        if options.Whitelist ~= false then
            ESPSettings.WhitelistedPlayers[playerName] = true
        end
        
        return getgenv().TrisESP.PlayerCustomSettings[playerName]
    end,
    
    -- Remove per-player custom ESP settings
    RemovePlayerESP = function(playerNameOrInstance)
        local playerName
        if typeof(playerNameOrInstance) == "Instance" and playerNameOrInstance:IsA("Player") then
            playerName = playerNameOrInstance.Name
        else
            playerName = tostring(playerNameOrInstance)
        end
        getgenv().TrisESP.PlayerCustomSettings[playerName] = nil
        ESPSettings.WhitelistedPlayers[playerName] = nil
    end,
    
    -- Get custom settings for a player
    GetPlayerSettings = function(playerNameOrInstance)
        local playerName
        if typeof(playerNameOrInstance) == "Instance" and playerNameOrInstance:IsA("Player") then
            playerName = playerNameOrInstance.Name
        else
            playerName = tostring(playerNameOrInstance)
        end
        return getgenv().TrisESP.PlayerCustomSettings[playerName]
    end,
    
    -- Update custom settings for a player
    UpdatePlayerESP = function(playerNameOrInstance, options)
        local playerName
        if typeof(playerNameOrInstance) == "Instance" and playerNameOrInstance:IsA("Player") then
            playerName = playerNameOrInstance.Name
        else
            playerName = tostring(playerNameOrInstance)
        end
        
        if not getgenv().TrisESP.PlayerCustomSettings[playerName] then
            return getgenv().TrisESP.AddPlayerESP(playerNameOrInstance, options)
        end
        
        for k, v in pairs(options or {}) do
            getgenv().TrisESP.PlayerCustomSettings[playerName][k] = v
        end
        
        return getgenv().TrisESP.PlayerCustomSettings[playerName]
    end,
    
    -- === QUICK OBJECT ESP ===
    -- Add ESP to any BasePart or Model instantly
    -- Usage: TrisESP.AddObjectESP(workspace.Diamond, {Color = Color3.new(1,1,0), Name = "Diamond", Rainbow = true})
    AddObjectESP = function(object, options)
        if not object or typeof(object) ~= "Instance" then return end
        options = options or {}
        
        local displayName = options.Name or object.Name
        local configName = options.Category or displayName
        
        -- Create config if needed
        if not ObjectESPConfigs[configName] then
            createObjectESPConfig(configName, {
                Enabled = true,
                Color = options.Color or Color3.fromRGB(255, 255, 0),
                Rainbow = options.Rainbow or false,
                ShowName = options.ShowName ~= false,
                ShowDistance = options.ShowDistance ~= false,
                ShowBox = options.ShowBox ~= false,
                ShowTracer = options.ShowTracer or false,
                MaxDistance = options.MaxDistance or 500
            })
        end
        
        addObjectToESP(configName, object, displayName)
        return configName
    end,
    
    -- Remove object ESP
    RemoveObjectESP = function(object, category)
        if not object then return end
        local configName = category or object.Name
        removeObjectFromESP(configName, object)
    end,

    -- Advanced API (for custom configs)
    CreateObjectConfig = createObjectESPConfig,
    AddObject = addObjectToESP,
    RemoveObject = removeObjectFromESP,
    GetConfigs = function() return ObjectESPConfigs end
}

-- Per-tool image map and helper API
getgenv().TrisESP.ToolImages = {}
getgenv().TrisESP.PlaceToolImages = {}
-- Global tool image
getgenv().TrisESP.SetToolImage = function(toolName, imageData)
    if not toolName then return end
    getgenv().TrisESP.ToolImages[toolName:lower()] = imageData
end
getgenv().TrisESP.RemoveToolImage = function(toolName)
    if not toolName then return end
    getgenv().TrisESP.ToolImages[toolName:lower()] = nil
end
-- Per-place tool images
getgenv().TrisESP.SetToolImageForPlace = function(placeId, toolName, imageData)
    if not placeId or not toolName then return end
    placeId = tostring(placeId)
    getgenv().TrisESP.PlaceToolImages[placeId] = getgenv().TrisESP.PlaceToolImages[placeId] or {}
    getgenv().TrisESP.PlaceToolImages[placeId][toolName:lower()] = imageData
end
getgenv().TrisESP.RemoveToolImageForPlace = function(placeId, toolName)
    if not placeId or not toolName then return end
    placeId = tostring(placeId)
    if getgenv().TrisESP.PlaceToolImages[placeId] then
        getgenv().TrisESP.PlaceToolImages[placeId][toolName:lower()] = nil
    end
end

--[[
    ====================== TrisESP API DOCUMENTATION ======================
    
    QUICK START:
        local ESP = getgenv().TrisESP
        ESP.Settings.Enabled = true
        ESP.Settings.Boxes = true
        ESP.Settings.BoxRainbow = true
    
    SETTINGS (access via ESP.Settings.SETTING_NAME):
        Enabled = true/false                    -- Master toggle
        MaxDistance = 1500                      -- Max render distance
        TextFont = 2                            -- Font (0=Legacy, 1=Arial, 2=SourceSans, 3=RobotoMono)
        UseDisplayName = false                  -- Use display name instead of username
        
        -- Boxes
        Boxes = true/false                      -- Enable boxes
        BoxType = "Square" / "Corner"           -- Box type
        BoxColor = Color3                       -- Box color
        BoxRainbow = true/false                 -- Rainbow boxes
        Thickness = 2                           -- Box line thickness (hardcoded)
        BoxFill = true/false                    -- Enable fill
        BoxFillColor = Color3                   -- Fill color
        BoxFillRainbow = true/false             -- Rainbow fill
        BoxFillGradient = true/false            -- Gradient fill
        BoxFillGradientColor1 = Color3          -- Gradient start
        BoxFillGradientColor2 = Color3          -- Gradient end
        BoxFillTransparency = 0.5               -- Fill transparency (0-1)
        
        -- Tracers
        Tracers = true/false                    -- Enable tracers
        TracerColor = Color3                    -- Tracer color
        TracerRainbow = true/false              -- Rainbow tracers
        TracerFrom = "Bottom"/"Top"/"Center"/"Mouse"
        TracerThickness = 2                     -- Tracer thickness
        
        -- Health Bar
        HealthBarEnabled = true/false           -- Enable health bar
        HealthBarPosition = "Left"/"Right"/"Top"/"Bottom"
        HealthBarThickness = 6                  -- Bar thickness (hardcoded)
        HealthBarRainbow = true/false           -- Rainbow health bar
        HealthBarOutline = true/false           -- Show outline
        HealthBarOutlineColor = Color3          -- Outline color
        
        -- Chams
        Highlight = true/false                  -- Enable chams
        GlobalChamColor = Color3                -- Chams color
        ChamsRainbow = true/false               -- Rainbow chams
        FillTransparency = 0.5                  -- Fill transparency
        OutlineTransparency = 0                 -- Outline transparency
        
        -- Text
        ShowName = true/false                   -- Show player names
        ShowHealthText = true/false             -- Show health text
        ShowDistance = true/false               -- Show distance
        NameColor = Color3                      -- Name color
        NameRainbow = true/false                -- Rainbow names
        
        -- Equipped Tool
        EquippedEnabled = true/false            -- Show equipped tool
        EquippedMode = "Text" / "Image"         -- Display mode
        EquippedPosition = "Inline" / "Bottom"  -- Position
        
        -- Team (when TeamCheckEnabled = true, teammates are auto-hidden)
        TeamCheckEnabled = true/false           -- Enable team check
        TeamDetectionMode = "Auto"/"RobloxTeams"/"Folder"/"Custom"
        CustomTeamFolder = Folder Instance      -- For Folder mode
        CustomTeamFunction = function(p1, p2)   -- For Custom mode
        
        -- Filtering
        FilterMode = "All" / "Whitelist" / "Blacklist"
        
    OBJECT ESP (access via ESP.ObjectConfigs["name"]):
        ESP.TrackObjectsByName("Diamond", {Color = Color3.new(1,1,0), Rainbow = true})
        ESP.TrackFolder(workspace.Items, "Items", {ShowTracer = true})
        ESP.AddSimpleObjectESP(workspace.Diamond, "Diamond")
        ESP.ObjectConfigs["Diamond"].Enabled = false  -- Disable category
    
    HELPER FUNCTIONS:
        ESP.SetEnabled(true/false)              -- Toggle all ESP
        ESP.EnableTeamCheck(true/false)         -- Toggle team check
        ESP.SetTeamMode("RobloxTeams")          -- Set team detection
        ESP.SetTeamFolder(folder)               -- Set team folder
        ESP.SetCustomTeamFunction(func)         -- Set custom team check
        ESP.WhitelistPlayer("Name")             -- Add to whitelist
        ESP.BlacklistPlayer("Name")             -- Add to blacklist
        ESP.SetFilterMode("Whitelist")          -- Set filter mode
        ESP.AddTextEntry("Label", func, order)  -- Add custom text
    
    =========================================================================
--]]

print("[TrisESP] Loaded successfully - Access via getgenv().TrisESP")
