--// Services
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

--// Player / Camera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

--// Common constructors (worth localizing)
local Vector2 = Vector2
local Vector3 = Vector3
local CFrame = CFrame
local Color3 = Color3
local Enum = Enum
local Instance = Instance
local Drawing = Drawing



-- Create folders for custom combos
if not isfolder("TrisSploit") then
    makefolder("TrisSploit")
end
if not isfolder("TrisSploit/combos") then
    makefolder("TrisSploit/combos")
end

-- Remote library loading
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local success, Library = pcall(function() return loadstring(game:HttpGet("https://raw.githubusercontent.com/trissploit/trissploit/refs/heads/main/library.lua"))() end)
if not success or not Library then error("Failed to load Obsidian Library: " .. tostring(Library)) return end

-- Load TrisESP
local ESPSuccess, ESPError = pcall(function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/trissploit/trissploit/refs/heads/main/esp"))()
end)
if not ESPSuccess then
    warn("Failed to load TrisESP: " .. tostring(ESPError))
end
Library.ForceCheckbox = true
local success2, ThemeManager = pcall(function() return loadstring(game:HttpGet("https://raw.githubusercontent.com/trissploit/trissploit/refs/heads/main/thememanager.lua"))() end)
if not success2 then ThemeManager = nil end



local success3, SaveManager = pcall(function() return loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))() end)
if not success3 then SaveManager = nil end

local Window = Library:CreateWindow({
    Title = "tris.sip",
    Footer = "tris.sip | testing | version: 0.0",
    Icon = "rbxassetid://85419017315177",
    CornerRadius = 0,
    Size = UDim2.fromOffset(580, 460),
    NotifySide = "Right",
    ShowCustomCursor = false,
    Compact = true,
    
})

local Tabs = {
    Home = Window:AddTab("Home", "boxes", "Overview & status"),
    Combat = Window:AddTab("Combat", "sword"),
    Mods = Window:AddTab("Mods", "wrench"),
    Visuals = Window:AddTab("Visuals", "eye"),
    Rage = Window:AddTab("Rage", "angry"),
    Settings = Window:AddTab("Settings", "cog"),
}

Tabs.Home:UpdateWarningBox({
    Title = "Development Notice",
    Text = "SCRIPT IS IN DEVELOPMENT! Script may have bugs or things may not function properly",
    IsNormal = false,
    Visible = true,
    LockSize = true
})

-- Status box removed per user request

local ChangelogsBox = Tabs.Home:AddLeftGroupbox("Changelogs", "scroll")
ChangelogsBox:AddLabel("Updates posted in Discord server.", true)

local CreditsBox = Tabs.Home:AddRightGroupbox("Credits", "award")
CreditsBox:AddLabel("<font color='rgb(255,0,255)'>worldwide</font> - founder & developer", true)
CreditsBox:AddLabel("<font color='rgb(0,255,255)'>nebula</font> - developer", true)

local SocialBox = Tabs.Home:AddRightGroupbox("Socials", "users")
SocialBox:AddLabel("Join Discord for updates & support!", true)
SocialBox:AddButton("Join Discord", function()
    if safeSetClipboard("https://pornhub.com") then
        Library:Notify("Discord invite copied!", 3)
        local s = Instance.new("Sound"); s.SoundId = "rbxassetid://9086208311"; s.Volume = 0.3; s.Parent = SoundService; s:Play(); s.Ended:Wait(); s:Destroy()
    else
        Library:Notify("Clipboard not supported!", 3)
    end
end)

-- === Modules ===

-- AntiDebuff Module
local AntiDebuff = {
    Enabled = false,
    Connection = nil :: RBXScriptConnection?,
    Blacklist = {} :: { [string]: boolean },
}

do
    local blacklistNames = {
        "InSkil", "NoSprint", "Block", "Stun", "Knockback",
        "Hold", "Wakeup", "Counter", "NoNue", "WorldSlash",
        "Drill", "DiSWeapon", "DisableChase"
    }
    for _, name in blacklistNames do
        AntiDebuff.Blacklist[name] = true
    end
end

function AntiDebuff.StartListener()
    if AntiDebuff.Connection and AntiDebuff.Connection.Connected then return end
    AntiDebuff.Connection = Workspace.Characters.DescendantAdded:Connect(function(obj: Instance)
        if not AntiDebuff.Enabled then return end
        task.spawn(function()
            task.wait()
            if not (obj and obj.Parent and obj.Parent.Parent) then return end
            if not AntiDebuff.Blacklist[obj.Name] then return end
            local character = LocalPlayer.Character
            if not character then return end
            if obj.Parent.Parent == character then
                obj:Destroy()
            end
        end)
    end)
end

function AntiDebuff.StopListener()
    if AntiDebuff.Connection and AntiDebuff.Connection.Connected then
        AntiDebuff.Connection:Disconnect()
        AntiDebuff.Connection = nil
    end
end

-- Custom Sequences
local CustomSequences = {} :: { [string]: { any } }

-- Load custom sequences
local function LoadCustomSequences()
    for k in CustomSequences do
        CustomSequences[k] = nil
    end
    if isfolder("TrisSploit/combos") then
        for _, file in listfiles("TrisSploit/combos") do
            if file:match("%.txt$") then
                local content = readfile(file)
                local loader = loadstring("return {" .. content .. "}")
                if loader then
                    local success, seq = pcall(loader)
                    if success and type(seq) == "table" then
                        local name = file:match("([^/\\]+)%.txt$")
                        CustomSequences[name] = seq
                    else
                        warn("Failed to execute sequence from " .. file .. ": " .. tostring(seq))
                    end
                else
                    warn("Failed to load sequence from " .. file)
                end
            end
        end
    end
end

-- Load initially
LoadCustomSequences()

-- Shared Range Settings
local RangeCheck = {
    AutoEnabled = false,
    CustomEnabled = false,
    Range = 20,
    ShowVisualizer = false,
}

-- Range Visualizer (perfect flat circle with nice border)
local visualizerPart: Part
local visualizerMesh: SpecialMesh?
do
    visualizerPart = Instance.new("Part")
    visualizerPart.Shape = Enum.PartType.Block
    visualizerPart.Size = Vector3.new(1, 0.2, 1)
    visualizerPart.Anchored = true
    visualizerPart.CanCollide = false
    visualizerPart.Transparency = 0.6
    visualizerPart.Material = Enum.Material.Neon
    visualizerPart.Color = Color3.new(0, 1, 0)
    visualizerPart.Name = "RangeVisualizer"

    visualizerMesh = Instance.new("SpecialMesh")
    visualizerMesh.MeshType = Enum.MeshType.Cylinder
    visualizerMesh.Scale = Vector3.new(RangeCheck.Range * 2, 0.2, RangeCheck.Range * 2)
    visualizerMesh.Parent = visualizerPart
end

local visualizerConnection: RBXScriptConnection?
local function UpdateVisualizer()
    if visualizerConnection then visualizerConnection:Disconnect() end
    visualizerConnection = RunService.Heartbeat:Connect(function()
        if not RangeCheck.ShowVisualizer then
            visualizerPart.Parent = nil
            return
        end
        local character = LocalPlayer.Character
        if not character then
            visualizerPart.Parent = nil
            return
        end
        local hrp = character:FindFirstChild("HumanoidRootPart") :: BasePart?
        if not hrp then
            visualizerPart.Parent = nil
            return
        end
        -- Place visualizer at the bottom of the character's feet (not world ground)
        local bottomY = nil
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                local partBottom = part.Position.Y - part.Size.Y / 2
                if not bottomY or partBottom < bottomY then
                    bottomY = partBottom
                end
            end
        end
        if not bottomY then bottomY = hrp.Position.Y - hrp.Size.Y / 2 end
        local meshThickness = 1.0
        -- use a flattened sphere mesh (reliable circular disc appearance)
        visualizerMesh.MeshType = Enum.MeshType.Sphere
        visualizerMesh.Scale = Vector3.new(RangeCheck.Range * 2, meshThickness, RangeCheck.Range * 2)
        local placePos = Vector3.new(hrp.Position.X, bottomY + meshThickness / 2 + 0.05, hrp.Position.Z)
        -- place flat on feet (no rotation required for flattened sphere)
        visualizerPart.CFrame = CFrame.new(placePos)
        visualizerPart.Parent = Workspace
    end)
end

-- Target System
local Target = {
    Enabled = false,
    CurrentTarget = nil :: Player?,
    NoDamageThreshold = 0.5,
    TargetKey = Enum.KeyCode.E,
    AimlockEnabled = false,
    AimlockMethod = "CameraLock",
    ChamsEnabled = true,
}

-- Camera lock state
local _cameraLockActive = false
local _savedCameraType = nil
local _savedCameraCFrame = nil
local _cameraLockConnection: RBXScriptConnection?

local function EnableCameraLock()
    if _cameraLockActive then return end
    if not Camera then return end
    -- Use mouse-locking: move the mouse cursor to the target's HumanoidRootPart screen
    _cameraLockActive = true
    if _cameraLockConnection and _cameraLockConnection.Connected then
        _cameraLockConnection:Disconnect()
        _cameraLockConnection = nil
    end
    _cameraLockConnection = RunService.RenderStepped:Connect(function()
        if not _cameraLockActive then return end
        local target = Target.CurrentTarget
        if not target or not target.Character then return end
        local hrp = target.Character:FindFirstChild("HumanoidRootPart") :: BasePart?
        if not hrp then return end
        local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        if onScreen then
            pcall(function()
                VirtualInputManager:SendMouseMoveEvent(screenPos.X, screenPos.Y, game)
            end)
        end
    end)
end

local function DisableCameraLock()
    if not _cameraLockActive then return end
    if not Camera then _cameraLockActive = false; return end
    if _cameraLockConnection and _cameraLockConnection.Connected then
        pcall(function() _cameraLockConnection:Disconnect() end)
        _cameraLockConnection = nil
    end
    _cameraLockActive = false
    _savedCameraType = nil
    _savedCameraCFrame = nil
end

local _hitoMacroStop: (() -> ())?
local _hitoMacroDelayMs: number = 100

local function _startHitoMacro(): (() -> ())
    -- Services
    local Players = game:GetService("Players")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local RunService = game:GetService("RunService")

    -- Local player and GUI
    local player = Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")

    local alive = true
    local activeHandlers = {}

    local function safeDisconnect(conn)
        if conn then
            pcall(function()
                conn:Disconnect()
            end)
        end
    end

    -- Helper to get KeyCode from letter
    local function getKeyCodeFromLetter(letter)
        local upper = tostring(letter):upper()
        return Enum.KeyCode[upper]
    end

    -- Handles one QTE instance
    local function handleQTE(qteGui)
        if not alive then return end
        local qtePC = qteGui:WaitForChild("QTE_PC", 5)
        if not alive or not qtePC or not qtePC:IsA("TextLabel") then return end

        local state = {
            qteGui = qteGui,
            qtePC = qtePC,
            currentLetter = qtePC.Text,
            stopLoop = false,
            keyPressLoopRunning = false,
            conns = {},
        }
        table.insert(activeHandlers, state)

        -- Repeatedly press the current key
        local function startKeyPressLoop()
            if state.keyPressLoopRunning then return end
            state.keyPressLoopRunning = true

            coroutine.wrap(function()
                while alive and not state.stopLoop and state.currentLetter do
                    local keyCode = getKeyCodeFromLetter(state.currentLetter)
                    if keyCode then
                        VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
                        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
                    end

                    -- Delay (0..1000ms). If 0, still yield to avoid freezing.
                    local delayMs = tonumber(_hitoMacroDelayMs) or 0
                    delayMs = math.clamp(delayMs, 0, 1000)
                    if delayMs > 0 then
                        task.wait(delayMs / 1000)
                    else
                        RunService.Heartbeat:Wait()
                    end
                end
                state.keyPressLoopRunning = false
            end)()
        end

        -- Watch for Text changes
        state.conns.textConn = qtePC:GetPropertyChangedSignal("Text"):Connect(function()
            if not alive then return end
            local newLetter = qtePC.Text
            if newLetter ~= state.currentLetter then
                state.currentLetter = newLetter
                state.stopLoop = true
                task.wait()
                state.stopLoop = false
                startKeyPressLoop()
            end
        end)

        -- Watch for QTE GUI being removed
        state.conns.ancestryConn = qteGui.AncestryChanged:Connect(function()
            if not qteGui:IsDescendantOf(playerGui) then
                state.stopLoop = true
                safeDisconnect(state.conns.textConn)
                safeDisconnect(state.conns.ancestryConn)
                state.currentLetter = nil
            end
        end)

        -- Start loop if there's already a letter
        if state.currentLetter ~= "" then
            startKeyPressLoop()
        end
    end

    -- Listen for QTE GUI being added
    local descendantConn = playerGui.DescendantAdded:Connect(function(descendant)
        if not alive then return end
        if descendant.Name == "QTE" then
            task.spawn(handleQTE, descendant)
        end
    end)

    -- Return cleanup function for toggling off
    return function()
        if not alive then return end
        alive = false
        safeDisconnect(descendantConn)
        for _, state in ipairs(activeHandlers) do
            state.stopLoop = true
            if state.conns then
                safeDisconnect(state.conns.textConn)
                safeDisconnect(state.conns.ancestryConn)
            end
            state.currentLetter = nil
        end
    end
end

local function StartHitoMacro()
    if _hitoMacroStop then return end
    _hitoMacroStop = _startHitoMacro()
end

local function StopHitoMacro()
    local stopFn = _hitoMacroStop
    _hitoMacroStop = nil
    if stopFn then
        pcall(stopFn)
    end
end

local PlayerESPConfig = {
    Kills = {
        Enabled = false,
        Position = "Bottom",
        Color = Color3.new(1,1,1),
        OutlineEnabled = true,
        OutlineColor = Color3.new(0,0,0),
        Size = 13,
    },
}

local playerESPs = {}
local wasPlayingAnim = {}

local function getCorners(cf: CFrame, size: Vector3)
    local hx, hy, hz = size.X/2, size.Y/2, size.Z/2
    local corners = {
        cf * Vector3.new(-hx, -hy, -hz),
        cf * Vector3.new(-hx, -hy, hz),
        cf * Vector3.new(-hx, hy, -hz),
        cf * Vector3.new(-hx, hy, hz),
        cf * Vector3.new(hx, -hy, -hz),
        cf * Vector3.new(hx, -hy, hz),
        cf * Vector3.new(hx, hy, -hz),
        cf * Vector3.new(hx, hy, hz),
    }
    return corners
end

local function get2DBoxFromCorners(corners)
    local minX, minY = math.huge, math.huge
    local maxX, maxY = -math.huge, -math.huge
    local anyOnScreen = false
    for _, pos in corners do
        local screen, onScreen = Camera:WorldToViewportPoint(pos)
        if onScreen then anyOnScreen = true end
        minX = math.min(minX, screen.X)
        maxX = math.max(maxX, screen.X)
        minY = math.min(minY, screen.Y)
        maxY = math.max(maxY, screen.Y)
    end
    if not anyOnScreen then return nil end
    return Vector2.new(minX, minY), Vector2.new(maxX - minX, maxY - minY)
end

local function getTextPosition(position: string, boxPos: Vector2, boxSize: Vector2, textBounds: Vector2)
    local width, height = textBounds.X, textBounds.Y
    local boxCenterX = boxPos.X + boxSize.X / 2
    local boxCenterY = boxPos.Y + boxSize.Y / 2
    local textX, textY
    if position == "Top" then
        textX = boxCenterX - width / 2
        textY = boxPos.Y - height
    elseif position == "Bottom" then
        textX = boxCenterX - width / 2
        textY = boxPos.Y + boxSize.Y
    elseif position == "Left" then
        textX = boxPos.X - width
        textY = boxCenterY - height / 2
    elseif position == "Right" then
        textX = boxPos.X + boxSize.X
        textY = boxCenterY - height / 2
    end
    return Vector2.new(textX, textY)
end

local function createESP(player)
    if playerESPs[player] then return end
    local esp = {
        -- Use TrisESP custom text instead of Drawing.Text to avoid persistent drawings
        _lastKillsText = nil,
        -- placeholder for any future per-player state
    }
    playerESPs[player] = esp
end

local function AddESPToPlayer(player)
    if player == LocalPlayer then return end
    createESP(player)
end

local function SetupPlayerESP()
    for _, player in ipairs(Players:GetPlayers()) do
        AddESPToPlayer(player)
    end

    Players.PlayerAdded:Connect(AddESPToPlayer)

    Players.PlayerRemoving:Connect(function(player)
        local esp = playerESPs[player]
        if esp then
            -- remove any custom text we added via TrisESP
            pcall(function()
                if getgenv().TrisESP and esp._lastKillsText then
                    getgenv().TrisESP.RemoveCustomText(player, esp._lastKillsText)
                end
            end)
            playerESPs[player] = nil
        end
        wasPlayingAnim[player] = nil
    end)
end

SetupPlayerESP()

local function SetTarget()
    local targetInstance = Mouse.Target
    if not targetInstance then 
        Target.CurrentTarget = nil
        Library:Notify("Target cleared")
        TargetLabel:SetText("Current Target: None")
        TargetHPLabel:SetText("HP: N/A")
        pcall(function()
            RefreshTargetPlayerDropdown()
            if TargetPlayerDropdown and TargetPlayerDropdown.SetValue then TargetPlayerDropdown:SetValue(nil) end
        end)
        return 
    end
    local char = targetInstance:FindFirstAncestorWhichIsA("Model")
    if not char or char.Parent ~= Workspace.Characters then 
        Target.CurrentTarget = nil
        Library:Notify("Target cleared")
        TargetLabel:SetText("Current Target: None")
        TargetHPLabel:SetText("HP: N/A")
        pcall(function()
            RefreshTargetPlayerDropdown()
            if TargetPlayerDropdown and TargetPlayerDropdown.SetValue then TargetPlayerDropdown:SetValue(nil) end
        end)
        return 
    end
    local player = Players:GetPlayerFromCharacter(char)
    if not player or player == LocalPlayer then return end
    if Target.CurrentTarget == player then
        Target.CurrentTarget = nil
        Library:Notify("Target cleared")
        TargetLabel:SetText("Current Target: None")
        TargetHPLabel:SetText("HP: N/A")
        pcall(function()
            RefreshTargetPlayerDropdown()
            if TargetPlayerDropdown and TargetPlayerDropdown.SetValue then TargetPlayerDropdown:SetValue(nil) end
        end)
    else
        Target.CurrentTarget = player
        Library:Notify("Targeted: " .. player.DisplayName)
        TargetLabel:SetText("Current Target: " .. player.DisplayName .. " (@" .. player.Name .. ")")
        pcall(function()
            RefreshTargetPlayerDropdown()
            if TargetPlayerDropdown and TargetPlayerDropdown.SetValue then
                TargetPlayerDropdown:SetValue(player.DisplayName .. " (@" .. player.Name .. ")")
            end
        end)
    end
end

local targetKeyConnection: RBXScriptConnection?
local playerRemovingConnection = Players.PlayerRemoving:Connect(function(player: Player)
    if Target.CurrentTarget == player then
        Target.CurrentTarget = nil
        Target.AimlockEnabled = false
        Library:Notify("Target left the game")
        TargetLabel:SetText("Current Target: None")
        TargetHPLabel:SetText("HP: N/A")
    end
end)

-- Function to get activation distance (target if set, else nearest)
local function GetActivationDistance(): number
    local lpChar = LocalPlayer.Character
    if not lpChar then return math.huge end
    local lpHrp = lpChar:FindFirstChild("HumanoidRootPart") :: BasePart?
    if not lpHrp then return math.huge end
    local lpPos = lpHrp.Position
    if Target.CurrentTarget then
        local p = Target.CurrentTarget
        local pChar = p.Character
        if pChar then
            local pHrp = pChar:FindFirstChild("HumanoidRootPart") :: BasePart?
            if pHrp then
                local pHum = pChar:FindFirstChild("Humanoid") :: Humanoid?
                if pHum and pHum.Health > 0 then
                    return (pHrp.Position - lpPos).Magnitude
                end
            end
        end
        return math.huge
    else
        local minDist = math.huge
        for _, p in Players:GetPlayers() do
            if p ~= LocalPlayer then
                local pChar = p.Character
                if pChar then
                    local pHrp = pChar:FindFirstChild("HumanoidRootPart") :: BasePart?
                    if pHrp then
                        local pHum = pChar:FindFirstChild("Humanoid") :: Humanoid?
                        if pHum and pHum.Health > 0 then
                            local dist = (pHrp.Position - lpPos).Magnitude
                            if dist < minDist then
                                minDist = dist
                            end
                        end
                    end
                end
            end
        end
        return minDist
    end
end

-- CustomCombo Module
local CustomCombo = {
    Config = {
        PressReleaseDelay = 0.05,
        DefaultDelayAfter = 0.1,
        DelayMultiplier = 1.0
    },
    Sequences = CustomSequences,
    SelectedCombo = nil :: string?,
    Enabled = false,
    TriggerKey = Enum.KeyCode.Q,
    CurrentThread = nil :: thread?,
}

function CustomCombo.PressKey(keyCode: Enum.KeyCode)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    task.wait(CustomCombo.Config.PressReleaseDelay)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

function CustomCombo.HoldKey(keyCode: Enum.KeyCode, duration: number?)
    VirtualInputManager:SendKeyEvent(true, keyCode, false, game)
    if duration then
        task.wait(duration)
        VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
    end
end

function CustomCombo.ReleaseKey(keyCode: Enum.KeyCode)
    VirtualInputManager:SendKeyEvent(false, keyCode, false, game)
end

function CustomCombo.LeftClick(x: number?, y: number?)
    x = x or Mouse.X
    y = y or Mouse.Y
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
    task.wait(CustomCombo.Config.PressReleaseDelay)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
end

function CustomCombo.ClickWithKeyHold(keyCode: Enum.KeyCode, x: number?, y: number?)
    CustomCombo.HoldKey(keyCode)
    task.wait(CustomCombo.Config.PressReleaseDelay)
    CustomCombo.LeftClick(x, y)
end

function CustomCombo.MoveMouseTo(x: number, y: number)
    VirtualInputManager:SendMouseMoveEvent(x, y, game)
end

function CustomCombo.ExecuteSequence(sequenceName: string)
    local seq = CustomCombo.Sequences[sequenceName]
    if not seq then
        warn("Custom sequence '" .. sequenceName .. "' not found!")
        return
    end
    local delayMultiplier = CustomCombo.Config.DelayMultiplier
    local hum: Humanoid? = nil
    if Target.CurrentTarget then
        local targetChar = Target.CurrentTarget.Character
        if targetChar then
            hum = targetChar:FindFirstChild("Humanoid") :: Humanoid?
        end
    end
    for _, action in seq do
        local preHealth: number? = nil
        if hum and action.nodmg_stop then
            preHealth = hum.Health
        end
        if action.type == "click" then
            CustomCombo.LeftClick(action.x, action.y)
        elseif action.type == "key" then
            CustomCombo.PressKey(action.key)
        elseif action.type == "clickHold" then
            CustomCombo.ClickWithKeyHold(action.key, action.x, action.y)
        elseif action.type == "holdKey" then
            CustomCombo.HoldKey(action.key, action.duration)
        elseif action.type == "releaseKey" then
            CustomCombo.ReleaseKey(action.key)
        elseif action.type == "mouseMove" then
            CustomCombo.MoveMouseTo(action.x, action.y)
        elseif action.type == "waitAnim" then
            -- Wait until the local player's humanoid finishes playing the given animation(s).
            -- action.animId: string or nil
            -- action.timeout: number (seconds) optional, defaults to 5
            local animSet = {}
            if action.animId then
                animSet[tostring(action.animId)] = true
            end
            -- If no animId provided, capture the local player's currently-playing animations
            -- so we only wait on the user's own animations (do NOT fallback to AutoBlock list).
            if next(animSet) == nil then
                local lpChar = LocalPlayer.Character
                local lpHum = lpChar and lpChar:FindFirstChild("Humanoid") :: Humanoid?
                if lpHum then
                    for _, track in ipairs(lpHum:GetPlayingAnimationTracks()) do
                        local anim = track and track.Animation
                        if anim and track.IsPlaying then
                            animSet[tostring(anim.AnimationId)] = true
                        end
                    end
                end
            end
            local timeout = action.timeout or 5
            local elapsed = 0
            while elapsed < timeout do
                local lpChar = LocalPlayer.Character
                local hum = lpChar and lpChar:FindFirstChild("Humanoid") :: Humanoid?
                local stillPlaying = false
                if hum then
                    for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                        if not track or not track.IsPlaying then continue end
                        local anim = track.Animation
                        if anim and animSet[tostring(anim.AnimationId)] then
                            stillPlaying = true
                            break
                        end
                    end
                end
                if not stillPlaying then break end
                task.wait(0.05)
                elapsed = elapsed + 0.05
            end
        end
        -- Support numeric delays or replaceable wait instructions.
        local function doWait(waitArg)
            if type(waitArg) == "number" then
                task.wait(waitArg * delayMultiplier)
                return
            end
            if type(waitArg) == "table" then
                -- table may contain { animId = <string|nil>, timeout = <seconds> }
                local timeout = waitArg.timeout or 5
                local elapsed = 0
                if waitArg.animId then
                    -- wait for specific animation id to stop on local player
                    while elapsed < timeout do
                        local lpChar = LocalPlayer.Character
                        local hum = lpChar and lpChar:FindFirstChild("Humanoid") :: Humanoid?
                        local stillPlaying = false
                        if hum then
                            for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                                if not track or not track.IsPlaying then continue end
                                local anim = track.Animation
                                if anim and tostring(anim.AnimationId) == tostring(waitArg.animId) then
                                    stillPlaying = true
                                    break
                                end
                            end
                        end
                        if not stillPlaying then break end
                        task.wait(0.05)
                        elapsed = elapsed + 0.05
                    end
                else
                    -- capture currently-playing local animations and wait for them to finish
                    local animSet = {}
                    do
                        local lpChar = LocalPlayer.Character
                        local hum = lpChar and lpChar:FindFirstChild("Humanoid") :: Humanoid?
                        if hum then
                            for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                                local anim = track and track.Animation
                                if anim and track.IsPlaying then
                                    animSet[tostring(anim.AnimationId)] = true
                                end
                            end
                        end
                    end
                    if next(animSet) == nil then
                        return
                    end
                    while elapsed < timeout do
                        local lpChar = LocalPlayer.Character
                        local hum = lpChar and lpChar:FindFirstChild("Humanoid") :: Humanoid?
                        local stillPlaying = false
                        if hum then
                            for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                                if not track or not track.IsPlaying then continue end
                                local anim = track.Animation
                                if anim and animSet[tostring(anim.AnimationId)] then
                                    stillPlaying = true
                                    break
                                end
                            end
                        end
                        if not stillPlaying then break end
                        task.wait(0.05)
                        elapsed = elapsed + 0.05
                    end
                end
                return
            end
            -- default fallback
            task.wait(CustomCombo.Config.DefaultDelayAfter * delayMultiplier)
        end

        -- choose how to wait: `action.delay_after` may be a number or a table describing an anim wait.
        if action.delay_after ~= nil then
            doWait(action.delay_after)
        else
            doWait(CustomCombo.Config.DefaultDelayAfter)
        end
        if preHealth and hum then
            local postHealth = hum.Health
            if postHealth >= preHealth then
                CustomCombo.CurrentThread = nil
                return
            end
        end
    end
    CustomCombo.CurrentThread = nil
end

function CustomCombo.ReleaseAllKeys()
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
end

-- Get names functions
local function GetSequenceNames(sequences: { [string]: any }): { string }
    local names = {}
    for name in sequences do
        table.insert(names, name)
    end
    table.sort(names)
    return names
end

local AutoBlock = {
    Enabled = false,
    Range = 10,
    -- Add or remove ability animation IDs here (strings as returned by Animation.AnimationId)
AbilityAnimationIds = {
    "rbxassetid://137865634124104", -- Lapse Blue
    "rbxassetid://137654778575373", -- Reversal Red
    "rbxassetid://77200218033775",  -- Cursed Strike
    "rbxassetid://82541714192027",  -- Reverse Ball
    "rbxassetid://72063002791216",  -- Shutter Door
    "rbxassetid://79619765411660",  -- Fever Breaker
    "rbxassetid://132653290201368", -- Rabbit Escape
    "rbxassetid://116432619539029", -- Toad
    "rbxassetid://81112033595734",  -- Divine Dog: Totality
    "rbxassetid://89092734635186",  -- Soul Fire
    "rbxassetid://115234621584704", -- Focus Strike
    "rbxassetid://127171275866632", -- Piercing Blood
    "rbxassetid://84039122607068",  -- Flowing Red Scale
    "rbxassetid://85569553424083",  -- Supernova
    "rbxassetid://100446064103831", -- Blood Edge
    "rbxassetid://111720035828971", -- Pebble Throw
    "rbxassetid://94720627091769",  -- Swift Kick
    "rbxassetid://89652378115594",  -- Extended Swings
    "rbxassetid://82191642276319",  -- Judgement's Reach
    "rbxassetid://124340599144108", -- Twirling Strikes
    "rbxassetid://104824728032437", -- Severing Path
    "rbxassetid://89582140026963",  -- Resolute Slash
    "rbxassetid://117178057848472", -- Veilstep
    "rbxassetid://140185219044200", -- Revolve
    "rbxassetid://105121164520635", -- Projection Breaker
    "rbxassetid://75190685223546",  -- Decisive Strike
    "rbxassetid://120136894011461", -- Ultra Spin
    "rbxassetid://93901924492394",  -- Ultra Cannon
    "rbxassetid://73522808400163",  -- Puppet Barrage
    "rbxassetid://129132347098646",             -- Black Mucus
    "rbxassetid://115097960689033", -- Garuda Rebound
    "rbxassetid://94347210073500",  -- Rising Rage
    "rbxassetid://103013818601982", -- Despair
    "rbxassetid://79860101129549",  -- Shut Up!
},
    -- internal set for fast lookup (built from AbilityAnimationIds)
    AbilityAnimationIdsSet = {
    },
    -- animations discovered under ReplicatedStorage.Animations
    RSAnimationsSet = {},
    -- animations specifically under ReplicatedStorage.Animations.misc.hits
    RSHitsSet = {},
    -- key to hold while blocking
    HoldKey = Enum.KeyCode.F,
    -- show a range visualizer for AutoBlock (abilities)
    ShowVisualizer = false,
    -- whether to block ability animations (separate toggle)
    BlockAbilities = false,
    -- whether to apply special handling for M1/hit animations after blocks
    BlockM1s = false,
    -- extra hold duration when an M1/hit follows a blocked animation
    BlockM1Extra = 0.5,
    -- separate range for M1/hit blocking
    BlockM1Range = 10,
    -- only block for the selected target
    OnlyTarget = false,
    -- only extend M1 blocks for the selected target
    BlockM1OnlyTarget = false,
    -- dash animation group (separate from abilities / M1s)
    BlockDashes = false,
    DashAnimationIds = {"rbxassetid://9443519528"},
    DashAnimationIdsSet = {},
    DashRange = 10,
    DashShowVisualizer = false,
    DashOnlyTarget = false,
    -- blocking method: "VIM" uses VirtualInputManager; "REMOTE" fires BlockService REMotes
    Method = "VIM",
}

local _autoBlockCurrentlyHolding = false
local lastBlockedByPlayer = {}
local _autoBlockExtraHoldUntil = 0
-- currently-blocking animation info
local _autoBlockCurrentAnimId = nil
local _autoBlockCurrentAnimName = nil

-- Track active relevant animations per player so we can react when they move into range mid-animation
local activePlayerAnims = {} -- [player] = { aid=string, name=string, isAbility=bool, isDash=bool, isHit=bool }
local autoBlockPlayerAnimConns = {} -- [player] = RBXScriptConnection

local function cleanupPlayerAnimConn(player)
    local conn = autoBlockPlayerAnimConns[player]
    if conn then
        pcall(function() conn:Disconnect() end)
        autoBlockPlayerAnimConns[player] = nil
    end
    activePlayerAnims[player] = nil
end

local function setupPlayerAnimConn(player)
    cleanupPlayerAnimConn(player)
    if not player or player == LocalPlayer then return end
    local char = player.Character
    if not char then return end
    local hum = char:FindFirstChild("Humanoid")
    if not hum then return end
    local conn
    conn = hum.AnimationPlayed:Connect(function(track)
        if not track or not track.Animation then return end
        local aid = tostring(track.Animation.AnimationId)
        local isAbility = (AutoBlock.AbilityAnimationIdsSet and AutoBlock.AbilityAnimationIdsSet[aid]) or (AutoBlock.RSAnimationsSet and AutoBlock.RSAnimationsSet[aid])
        local isDash = AutoBlock.DashAnimationIdsSet and AutoBlock.DashAnimationIdsSet[aid]
        local isHit = AutoBlock.RSHitsSet and AutoBlock.RSHitsSet[aid]
        if isAbility or isDash or isHit then
            activePlayerAnims[player] = { aid = aid, name = tostring(track.Name or track.Animation.Name or ""), isAbility = isAbility and true or false, isDash = isDash and true or false, isHit = isHit and true or false }
            -- clear when track stops
            local stoppedConn
            stoppedConn = track.Stopped:Connect(function()
                if stoppedConn then pcall(function() stoppedConn:Disconnect() end) end
                activePlayerAnims[player] = nil
            end)
        end
    end)
    autoBlockPlayerAnimConns[player] = conn
end

-- Setup for current players
for _, p in ipairs(Players:GetPlayers()) do
    if p ~= LocalPlayer then
        p.CharacterAdded:Connect(function(char) setupPlayerAnimConn(p) end)
        if p.Character then setupPlayerAnimConn(p) end
    end
end
Players.PlayerAdded:Connect(function(p)
    if p ~= LocalPlayer then
        p.CharacterAdded:Connect(function(char) setupPlayerAnimConn(p) end)
        if p.Character then setupPlayerAnimConn(p) end
    end
end)
Players.PlayerRemoving:Connect(function(p)
    cleanupPlayerAnimConn(p)
end)

local function _buildAutoBlockSet()
    AutoBlock.AbilityAnimationIdsSet = {}
    for _, id in ipairs(AutoBlock.AbilityAnimationIds) do
        AutoBlock.AbilityAnimationIdsSet[tostring(id)] = true
    end
    -- dash ids from config
    AutoBlock.DashAnimationIdsSet = {}
    for _, id in ipairs(AutoBlock.DashAnimationIds) do
        AutoBlock.DashAnimationIdsSet[tostring(id)] = true
    end
    -- scan ReplicatedStorage.Animations for available Animation objects
    AutoBlock.RSAnimationsSet = {}
    AutoBlock.RSHitsSet = {}
    -- animations under ReplicatedStorage.Animations.misc.hits.block (special handling)
    AutoBlock.RSBlockHitsSet = {}
    local ok, rs = pcall(function() return game:GetService("ReplicatedStorage"):FindFirstChild("Animations") end)
    if ok and rs and rs:IsA("Folder") then
        for _, inst in ipairs(rs:GetDescendants()) do
            if inst:IsA("Animation") then
                local aid = tostring(inst.AnimationId)
                local fullname = inst:GetFullName():lower()
                local name = tostring(inst.Name or ""):lower()
                -- Exclude common movement/parkour and hit animations from being treated as abilities
                local isExcluded = (fullname:find("land") ~= nil) or (name:find("land") ~= nil)
                    or (fullname:find("parkour") ~= nil) or (name:find("parkour") ~= nil)
                    or (fullname:find("hit[1-4]") ~= nil) or (name:find("hit[1-4]") ~= nil)
                if not isExcluded then
                    AutoBlock.RSAnimationsSet[aid] = true
                end
                
                -- M1 blocks: ONLY from Melee folder (Melee1, Melee2, Melee3, Melee4)
                if fullname:find(".melee") or fullname:find("melee") then
                    if name:find("melee1") or name:find("melee2") or name:find("melee3") or name:find("melee4") then
                        AutoBlock.RSHitsSet[aid] = true
                    end
                    -- also detect chase animations in melee folders for dash blocking
                    if name:find("chase") then
                        AutoBlock.DashAnimationIdsSet[aid] = true
                    end
                end
                
                -- 0.5 hold blocks: ONLY from misc.hits.block, and exclude HIT3 (only HIT1, HIT2, BLOCK)
                if fullname:find("replicatedstorage.animations.misc.hits.block") then
                    if not name:find("hit3") then
                        AutoBlock.RSBlockHitsSet[aid] = true
                    end
                end
                -- also populate dash set if placed under a folder named 'dash' (convention)
                -- Only treat animations explicitly named 'chase' as dash-block targets.
                if fullname:find("dash") and name:find("chase") then
                    AutoBlock.DashAnimationIdsSet[aid] = true
                end
            end
        end
    end
end

-- Keep ReplicatedStorage scan up-to-date
local rsAnimConnection: RBXScriptConnection?
local rsAnimRemovingConnection: RBXScriptConnection?
do
    local ok, rs = pcall(function() return game:GetService("ReplicatedStorage"):FindFirstChild("Animations") end)
    if ok and rs and rs:IsA("Folder") then
        rsAnimConnection = rs.DescendantAdded:Connect(function()
            _buildAutoBlockSet()
        end)
        rsAnimRemovingConnection = rs.DescendantRemoving:Connect(function()
            _buildAutoBlockSet()
        end)
    end
end

    -- AutoBlock hold/release helpers (support VIM and REMOTE methods)
    local function AutoBlock_DoHold()
        if AutoBlock.Method == "VIM" then
            pcall(function()
                VirtualInputManager:SendKeyEvent(true, AutoBlock.HoldKey, false, game)
            end)
        else
            pcall(function()
                local rs = game:GetService("ReplicatedStorage")
                if rs and rs:FindFirstChild("Knit") and rs.Knit:FindFirstChild("Knit") and rs.Knit.Knit.Services and rs.Knit.Knit.Services.BlockService and rs.Knit.Knit.Services.BlockService.RE and rs.Knit.Knit.Services.BlockService.RE.Activated then
                    rs.Knit.Knit.Services.BlockService.RE.Activated:FireServer()
                else
                    -- try direct path (best-effort)
                    game:GetService("ReplicatedStorage").Knit.Knit.Services.BlockService.RE.Activated:FireServer()
                end
            end)
        end
    end

    local function AutoBlock_DoRelease()
        if AutoBlock.Method == "VIM" then
            pcall(function()
                VirtualInputManager:SendKeyEvent(false, AutoBlock.HoldKey, false, game)
            end)
        else
            pcall(function()
                local rs = game:GetService("ReplicatedStorage")
                if rs and rs:FindFirstChild("Knit") and rs.Knit:FindFirstChild("Knit") and rs.Knit.Knit.Services and rs.Knit.Knit.Services.BlockService and rs.Knit.Knit.Services.BlockService.RE and rs.Knit.Knit.Services.BlockService.RE.Deactivated then
                    rs.Knit.Knit.Services.BlockService.RE.Deactivated:FireServer()
                else
                    game:GetService("ReplicatedStorage").Knit.Knit.Services.BlockService.RE.Deactivated:FireServer()
                end
            end)
        end
    end

function AutoBlock.AddAbilityAnimation(id: string)
    table.insert(AutoBlock.AbilityAnimationIds, id)
    _buildAutoBlockSet()
end

function AutoBlock.RemoveAbilityAnimation(id: string)
    for i, v in ipairs(AutoBlock.AbilityAnimationIds) do
        if v == id then
            table.remove(AutoBlock.AbilityAnimationIds, i)
            break
        end
    end
    _buildAutoBlockSet()
end

function AutoBlock.AddDashAnimation(id: string)
    table.insert(AutoBlock.DashAnimationIds, id)
    _buildAutoBlockSet()
end

function AutoBlock.RemoveDashAnimation(id: string)
    for i, v in ipairs(AutoBlock.DashAnimationIds) do
        if v == id then
            table.remove(AutoBlock.DashAnimationIds, i)
            break
        end
    end
    _buildAutoBlockSet()
end

_buildAutoBlockSet()

-- AutoBlock range visualizer
local autoBlockVisualizerPart: Part
local autoBlockVisualizerMesh: SpecialMesh?
local autoBlockVisualizerConnection: RBXScriptConnection?
local function UpdateAutoBlockVisualizer()
    if autoBlockVisualizerConnection then
        autoBlockVisualizerConnection:Disconnect()
        autoBlockVisualizerConnection = nil
    end
    if not AutoBlock.ShowVisualizer or not AutoBlock.BlockAbilities then
        if autoBlockVisualizerPart then
            autoBlockVisualizerPart.Parent = nil
        end
        return
    end
    if not autoBlockVisualizerPart then
        autoBlockVisualizerPart = Instance.new("Part")
        autoBlockVisualizerPart.Shape = Enum.PartType.Block
        autoBlockVisualizerPart.Size = Vector3.new(1, 0.2, 1)
        autoBlockVisualizerPart.Anchored = true
        autoBlockVisualizerPart.CanCollide = false
        autoBlockVisualizerPart.Transparency = 0.6
        autoBlockVisualizerPart.Material = Enum.Material.Neon
        autoBlockVisualizerPart.Color = Color3.new(0, 0.5, 1)
        autoBlockVisualizerPart.Name = "AutoBlockRangeVisualizer"

        autoBlockVisualizerMesh = Instance.new("SpecialMesh")
        autoBlockVisualizerMesh.MeshType = Enum.MeshType.Cylinder
        autoBlockVisualizerMesh.Scale = Vector3.new(AutoBlock.Range * 2, 0.2, AutoBlock.Range * 2)
        autoBlockVisualizerMesh.Parent = autoBlockVisualizerPart
    end

    autoBlockVisualizerMesh.Scale = Vector3.new(AutoBlock.Range * 2, 0.2, AutoBlock.Range * 2)
    autoBlockVisualizerPart.Parent = Workspace

    autoBlockVisualizerConnection = RunService.Heartbeat:Connect(function()
        if not AutoBlock.ShowVisualizer or not AutoBlock.BlockAbilities then
            autoBlockVisualizerPart.Parent = nil
            return
        end
        local character = LocalPlayer.Character
        if not character then
            autoBlockVisualizerPart.Parent = nil
            return
        end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then
            autoBlockVisualizerPart.Parent = nil
            return
        end
            -- Place auto-block visualizer at the bottom of the character's feet
            local bottomY = nil
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    local partBottom = part.Position.Y - part.Size.Y / 2
                    if not bottomY or partBottom < bottomY then
                        bottomY = partBottom
                    end
                end
            end
            if not bottomY then bottomY = hrp.Position.Y - hrp.Size.Y / 2 end
            local meshThickness = 1.0
            -- use a flattened sphere mesh for a consistent circular disc look
            if autoBlockVisualizerMesh then
                autoBlockVisualizerMesh.MeshType = Enum.MeshType.Sphere
                autoBlockVisualizerMesh.Scale = Vector3.new(AutoBlock.Range * 2, meshThickness, AutoBlock.Range * 2)
            end
            local placePos = Vector3.new(hrp.Position.X, bottomY + meshThickness / 2 + 0.05, hrp.Position.Z)
            autoBlockVisualizerPart.CFrame = CFrame.new(placePos)
            autoBlockVisualizerPart.Parent = Workspace
    end)
end

-- Block M1 range visualizer
local blockM1VisualizerPart: Part
local blockM1VisualizerMesh: SpecialMesh?
local blockM1VisualizerConnection: RBXScriptConnection?
local function UpdateBlockM1Visualizer()
    if blockM1VisualizerConnection then
        blockM1VisualizerConnection:Disconnect()
        blockM1VisualizerConnection = nil
    end
    if not AutoBlock.BlockM1s then
        if blockM1VisualizerPart then blockM1VisualizerPart.Parent = nil end
        return
    end
    if not blockM1VisualizerPart then
        blockM1VisualizerPart = Instance.new("Part")
        blockM1VisualizerPart.Shape = Enum.PartType.Block
        blockM1VisualizerPart.Size = Vector3.new(1, 0.2, 1)
        blockM1VisualizerPart.Anchored = true
        blockM1VisualizerPart.CanCollide = false
        blockM1VisualizerPart.Transparency = 0.6
        blockM1VisualizerPart.Material = Enum.Material.Neon
        blockM1VisualizerPart.Color = Color3.new(1, 0.5, 0)
        blockM1VisualizerPart.Name = "BlockM1RangeVisualizer"
        blockM1VisualizerMesh = Instance.new("SpecialMesh")
        blockM1VisualizerMesh.MeshType = Enum.MeshType.Sphere
        blockM1VisualizerMesh.Parent = blockM1VisualizerPart
    end
    blockM1VisualizerMesh.Scale = Vector3.new(AutoBlock.BlockM1Range * 2, 1.0, AutoBlock.BlockM1Range * 2)
    blockM1VisualizerPart.Parent = Workspace
    blockM1VisualizerConnection = RunService.Heartbeat:Connect(function()
        if not AutoBlock.BlockM1s or not AutoBlock.ShowVisualizer then blockM1VisualizerPart.Parent = nil; return end
        local character = LocalPlayer.Character
        if not character then blockM1VisualizerPart.Parent = nil; return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then blockM1VisualizerPart.Parent = nil; return end
        local bottomY = nil
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                local partBottom = part.Position.Y - part.Size.Y / 2
                if not bottomY or partBottom < bottomY then bottomY = partBottom end
            end
        end
        if not bottomY then bottomY = hrp.Position.Y - hrp.Size.Y / 2 end
        local placePos = Vector3.new(hrp.Position.X, bottomY + 0.5, hrp.Position.Z)
        blockM1VisualizerPart.CFrame = CFrame.new(placePos)
        blockM1VisualizerPart.Parent = Workspace
    end)
end

-- Dash group visualizer
local dashVisualizerPart: Part
local dashVisualizerMesh: SpecialMesh?
local dashVisualizerConnection: RBXScriptConnection?
local function UpdateDashVisualizer()
    if dashVisualizerConnection then
        dashVisualizerConnection:Disconnect()
        dashVisualizerConnection = nil
    end
    if not AutoBlock.BlockDashes then
        if dashVisualizerPart then dashVisualizerPart.Parent = nil end
        return
    end
    if not dashVisualizerPart then
        dashVisualizerPart = Instance.new("Part")
        dashVisualizerPart.Shape = Enum.PartType.Block
        dashVisualizerPart.Size = Vector3.new(1, 0.2, 1)
        dashVisualizerPart.Anchored = true
        dashVisualizerPart.CanCollide = false
        dashVisualizerPart.Transparency = 0.6
        dashVisualizerPart.Material = Enum.Material.Neon
        dashVisualizerPart.Color = Color3.new(0.8, 0.2, 0.8)
        dashVisualizerPart.Name = "DashRangeVisualizer"
        dashVisualizerMesh = Instance.new("SpecialMesh")
        dashVisualizerMesh.MeshType = Enum.MeshType.Sphere
        dashVisualizerMesh.Parent = dashVisualizerPart
    end
    dashVisualizerMesh.Scale = Vector3.new(AutoBlock.DashRange * 2, 1.0, AutoBlock.DashRange * 2)
    dashVisualizerPart.Parent = Workspace
    dashVisualizerConnection = RunService.Heartbeat:Connect(function()
        if not AutoBlock.BlockDashes or not AutoBlock.ShowVisualizer then dashVisualizerPart.Parent = nil; return end
        local character = LocalPlayer.Character
        if not character then dashVisualizerPart.Parent = nil; return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then dashVisualizerPart.Parent = nil; return end
        local bottomY = nil
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                local partBottom = part.Position.Y - part.Size.Y / 2
                if not bottomY or partBottom < bottomY then bottomY = partBottom end
            end
        end
        if not bottomY then bottomY = hrp.Position.Y - hrp.Size.Y / 2 end
        local placePos = Vector3.new(hrp.Position.X, bottomY + 0.5, hrp.Position.Z)
        dashVisualizerPart.CFrame = CFrame.new(placePos)
        dashVisualizerPart.Parent = Workspace
    end)
end

-- Bring Player range visualizer
local bringVisualizerPart: Part
local bringVisualizerMesh: SpecialMesh?
local bringVisualizerConnection: RBXScriptConnection?
local function UpdateBringVisualizer()
    if bringVisualizerConnection then
        bringVisualizerConnection:Disconnect()
        bringVisualizerConnection = nil
    end
    if not BringRequireTarget then
        if bringVisualizerPart then bringVisualizerPart.Parent = nil end
        return
    end
    if not bringVisualizerPart then
        bringVisualizerPart = Instance.new("Part")
        bringVisualizerPart.Shape = Enum.PartType.Block
        bringVisualizerPart.Size = Vector3.new(1, 0.2, 1)
        bringVisualizerPart.Anchored = true
        bringVisualizerPart.CanCollide = false
        bringVisualizerPart.Transparency = 0.6
        bringVisualizerPart.Material = Enum.Material.Neon
        bringVisualizerPart.Color = Color3.new(0, 1, 1)
        bringVisualizerPart.Name = "BringRangeVisualizer"
        bringVisualizerMesh = Instance.new("SpecialMesh")
        bringVisualizerMesh.MeshType = Enum.MeshType.Sphere
        bringVisualizerMesh.Parent = bringVisualizerPart
    end
    bringVisualizerMesh.Scale = Vector3.new(BringTargetRange * 2, 1.0, BringTargetRange * 2)
    bringVisualizerPart.Parent = Workspace
    bringVisualizerConnection = RunService.Heartbeat:Connect(function()
        if not BringRequireTarget then bringVisualizerPart.Parent = nil; return end
        local character = LocalPlayer.Character
        if not character then bringVisualizerPart.Parent = nil; return end
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if not hrp then bringVisualizerPart.Parent = nil; return end
        local bottomY = nil
        for _, part in pairs(character:GetDescendants()) do
            if part:IsA("BasePart") then
                local partBottom = part.Position.Y - part.Size.Y / 2
                if not bottomY or partBottom < bottomY then bottomY = partBottom end
            end
        end
        if not bottomY then bottomY = hrp.Position.Y - hrp.Size.Y / 2 end
        bringVisualizerMesh.Scale = Vector3.new(BringTargetRange * 2, 1.0, BringTargetRange * 2)
        local placePos = Vector3.new(hrp.Position.X, bottomY + 0.5, hrp.Position.Z)
        bringVisualizerPart.CFrame = CFrame.new(placePos)
        bringVisualizerPart.Parent = Workspace
    end)
end

-- === GUI Setup ===
-- Fly system (defined before GUI so callbacks can reference StartFly/StopFly)
local FlyEnabled = false
local flySpeed = 50
local FlyMethods = { "New Version", "Old Version" }
local SelectedFlyMethod = FlyMethods[1]
local flyConnection: RBXScriptConnection?
local flyInputConnectionBegin: RBXScriptConnection?
local flyInputConnectionEnd: RBXScriptConnection?
local flyKeys = { W=false, A=false, S=false, D=false, Space=false, LeftControl=false }

local function StopFly()
    FlyEnabled = false
    if flyConnection then flyConnection:Disconnect(); flyConnection = nil end
    if flyInputConnectionBegin then flyInputConnectionBegin:Disconnect(); flyInputConnectionBegin = nil end
    if flyInputConnectionEnd then flyInputConnectionEnd:Disconnect(); flyInputConnectionEnd = nil end
    local Players = game:GetService("Players")
    local plr = Players.LocalPlayer
    if plr then
        local char = plr.Character
        if char then
            local humanoid = char:FindFirstChild("Humanoid")
            if humanoid then pcall(function() humanoid.PlatformStand = false end) end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                local bv = hrp:FindFirstChild("_fly_bv")
                local bg = hrp:FindFirstChild("_fly_bg")
                if bv then pcall(function() bv:Destroy() end) end
                if bg then pcall(function() bg:Destroy() end) end
                pcall(function() hrp.AssemblyLinearVelocity = Vector3.new(0,0,0) end)
            end
        end
    end
end

local function StartFly()
    if FlyEnabled then return end
    FlyEnabled = true
    local UserInputService = game:GetService("UserInputService")
    local rs = game:GetService("RunService")
    flyInputConnectionBegin = UserInputService.InputBegan:Connect(function(inp, gp)
        if gp then return end
        if inp.KeyCode == Enum.KeyCode.W then flyKeys.W = true end
        if inp.KeyCode == Enum.KeyCode.S then flyKeys.S = true end
        if inp.KeyCode == Enum.KeyCode.A then flyKeys.A = true end
        if inp.KeyCode == Enum.KeyCode.D then flyKeys.D = true end
        if inp.KeyCode == Enum.KeyCode.Space then flyKeys.Space = true end
        if inp.KeyCode == Enum.KeyCode.LeftControl then flyKeys.LeftControl = true end
    end)
    flyInputConnectionEnd = UserInputService.InputEnded:Connect(function(inp, gp)
        if gp then return end
        if inp.KeyCode == Enum.KeyCode.W then flyKeys.W = false end
        if inp.KeyCode == Enum.KeyCode.S then flyKeys.S = false end
        if inp.KeyCode == Enum.KeyCode.A then flyKeys.A = false end
        if inp.KeyCode == Enum.KeyCode.D then flyKeys.D = false end
        if inp.KeyCode == Enum.KeyCode.Space then flyKeys.Space = false end
        if inp.KeyCode == Enum.KeyCode.LeftControl then flyKeys.LeftControl = false end
    end)

    flyConnection = rs.Heartbeat:Connect(function()
        if not FlyEnabled then return end
        local Players = game:GetService("Players")
        local plr = Players.LocalPlayer
        if not plr then return end
        local char = plr.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        local humanoid = char:FindFirstChild("Humanoid")
        if not hrp or not humanoid then return end
        local cam = workspace.CurrentCamera
        local look = cam and cam.CFrame and cam.CFrame.LookVector or Vector3.new(0,0,-1)
        local right = cam and cam.CFrame and cam.CFrame.RightVector or Vector3.new(1,0,0)
        local moveVec = Vector3.new(0,0,0)
        if flyKeys.W then moveVec = moveVec + Vector3.new(look.X,0,look.Z) end
        if flyKeys.S then moveVec = moveVec - Vector3.new(look.X,0,look.Z) end
        if flyKeys.D then moveVec = moveVec + Vector3.new(right.X,0,right.Z) end
        if flyKeys.A then moveVec = moveVec - Vector3.new(right.X,0,right.Z) end
        local up = 0
        if flyKeys.Space then up = up + 1 end
        if flyKeys.LeftControl then up = up - 1 end
        local hv = moveVec.Magnitude > 0 and moveVec.Unit * flySpeed or Vector3.new(0,0,0)
        local vel = Vector3.new(hv.X, up * flySpeed, hv.Z)
        if SelectedFlyMethod == "New Version" then
            pcall(function() humanoid.PlatformStand = true end)
            -- set assembly velocity directly for linear movement, with vertical clamping
            local desired = Vector3.new(vel.X, vel.Y, vel.Z)
            pcall(function() hrp.AssemblyLinearVelocity = desired end)
            -- rotate to face camera yaw only (avoid pitch)
            local horizLook = Vector3.new(look.X, 0, look.Z)
            if horizLook.Magnitude > 0.001 then
                pcall(function() hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + horizLook.Unit) end)
            end
        else
            -- BodyVelocity + BodyGyro fly
            pcall(function() humanoid.PlatformStand = true end)
            if not hrp:FindFirstChild("_fly_bv") then
                local bv = Instance.new("BodyVelocity") bv.Name = "_fly_bv" bv.MaxForce = Vector3.new(1e5,1e5,1e5) bv.Parent = hrp
                local bg = Instance.new("BodyGyro") bg.Name = "_fly_bg" bg.MaxTorque = Vector3.new(1e5,1e5,1e5) bg.Parent = hrp
            end
            local bv = hrp:FindFirstChild("_fly_bv")
            local bg = hrp:FindFirstChild("_fly_bg")
            if bv then pcall(function() bv.Velocity = vel end) end
            if bg then pcall(function() bg.CFrame = CFrame.new(hrp.Position, hrp.Position + look) end) end
        end
    end)
end

local AntiGroup = Tabs.Mods:AddLeftGroupbox("Anti-Stun")
AntiGroup:AddToggle("AntiDebuffToggle", {
    Text = "Enable",
    Default = false,
    Risky = true,
    Callback = function(value: boolean)
        AntiDebuff.Enabled = value
        if value then
            AntiDebuff.StartListener()
        else
            AntiDebuff.StopListener()
        end
    end
})

local HitoMacroGroup = Tabs.Mods:AddLeftGroupbox("Final Judgement Macro")
HitoMacroGroup:AddToggle("HitoMacroToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(value: boolean)
        if value then
            StartHitoMacro()
        else
            StopHitoMacro()
        end
    end,
})

HitoMacroGroup:AddSlider("HitoMacroDelaySlider", {
    Text = "Delay (ms)",
    Min = 0,
    Max = 1000,
    Default = _hitoMacroDelayMs,
    Rounding = 0,
    Compact = true,
    Callback = function(value: number)
        _hitoMacroDelayMs = math.clamp(value, 0, 1000)
    end,
})

    -- Fly controls in Mods tab
    local FlyGroup = Tabs.Mods:AddRightGroupbox("Fly")
    FlyGroup:AddToggle("FlyToggle", {
        Text = "Enable",
        Default = false,
        Risku = true,
        Callback = function(val)
            if val then StartFly() else StopFly() end
        end
    })
    FlyGroup:AddSlider("FlySpeedSlider", {
        Text = "Speed",
        Compact = true,
        Default = flySpeed,
        Min = 10,
        Max = 500,
        Rounding = 0,
        Callback = function(v) flySpeed = v end
    })
    FlyGroup:AddDropdown("FlyMethodSelect", {
        Text = "Method",
        Values = FlyMethods,
        Default = 1,
        Callback = function(value)
            SelectedFlyMethod = value
        end
    })

-- Custom Combo tabbox (first tab: enable/select/refresh; second tab: settings)
local CustomComboTabbox = Tabs.Combat:AddLeftTabbox()
local CustomComboTab = CustomComboTabbox:AddTab("Custom Combo")
local CustomComboSettingsTab = CustomComboTabbox:AddTab("Settings")

CustomComboTab:AddToggle("CustomComboToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(value: boolean)
        CustomCombo.Enabled = value
        if not value and customInputConnection then
            customInputConnection:Disconnect()
            customInputConnection = nil
        end
    end
})

local customComboNames = GetSequenceNames(CustomSequences)
if #customComboNames > 0 then
    CustomCombo.SelectedCombo = customComboNames[1]
end

local CustomComboDropdown = CustomComboTab:AddDropdown("CustomComboSelect", {
    Text = "Select Custom Combo",
    Values = customComboNames,
    Default = #customComboNames > 0 and 1 or nil,
    Callback = function(value: string)
        CustomCombo.SelectedCombo = value
    end
})

CustomComboTab:AddButton({
    Text = "Refresh Combos",
    Func = function()
        LoadCustomSequences()
        local names = GetSequenceNames(CustomSequences)
        CustomComboDropdown.Values = names
        CustomComboDropdown:BuildDropdownList()
        CustomComboDropdown:Display()
        if #names > 0 then
            if not table.find(names, CustomCombo.SelectedCombo) then
                CustomCombo.SelectedCombo = names[1]
            end
            CustomComboDropdown:SetValue(CustomCombo.SelectedCombo)
        else
            CustomCombo.SelectedCombo = nil
            CustomComboDropdown:SetValue(nil)
        end
    end
})

local keyOptions = {
    "E", "Q", "R", "F", "G", "T", "Z", "X", "C", "V", "B", "H", "N", "Y"
}
local keyMap = {
    E = Enum.KeyCode.E,
    Q = Enum.KeyCode.Q,
    R = Enum.KeyCode.R,
    F = Enum.KeyCode.F,
    G = Enum.KeyCode.G,
    T = Enum.KeyCode.T,
    Z = Enum.KeyCode.Z,
    X = Enum.KeyCode.X,
    C = Enum.KeyCode.C,
    V = Enum.KeyCode.V,
    B = Enum.KeyCode.B,
    H = Enum.KeyCode.H,
    N = Enum.KeyCode.N,
    Y = Enum.KeyCode.Y,
}

local TriggerKeyLabel = CustomComboSettingsTab:AddLabel("Trigger Key")
TriggerKeyLabel:AddKeyPicker("TriggerKeyPicker", {
    Default = "Q",
    Mode = "Click",
    Callback = function()
        if not CustomCombo.Enabled then return end
        if RangeCheck.CustomEnabled then
            local dist = GetActivationDistance()
            if dist > RangeCheck.Range then return end
        end
        CustomCombo.CurrentThread = task.spawn(CustomCombo.ExecuteSequence, CustomCombo.SelectedCombo)
    end
})

local CancelKeyLabel = CustomComboSettingsTab:AddLabel("Cancel Combo Key")
CancelKeyLabel:AddKeyPicker("CancelKeyPicker", {
    Default = "H",
    Mode = "Click",
    Callback = function()
        if CustomCombo.CurrentThread then
            task.cancel(CustomCombo.CurrentThread)
            CustomCombo.CurrentThread = nil
            CustomCombo.ReleaseAllKeys()
        end
        if _autoBlockCurrentlyHolding then
            pcall(AutoBlock_DoRelease)
            _autoBlockCurrentlyHolding = false
        end
    end
})

CustomComboSettingsTab:AddDivider()

CustomComboSettingsTab:AddToggle("CustomRangeCheckToggle", {
    Text = "Activate Only In Range",
    Default = false,
    Callback = function(value: boolean)
        RangeCheck.CustomEnabled = value
    end
})

CustomComboSettingsTab:AddToggle("ShowRangeVisualizerToggle", {
    Text = "Show Range Visualizer",
    Default = RangeCheck.ShowVisualizer,
    Callback = function(value: boolean)
        RangeCheck.ShowVisualizer = value
        if value then
            UpdateVisualizer()
        else
            visualizerPart.Parent = nil
            if visualizerConnection then
                visualizerConnection:Disconnect()
                visualizerConnection = nil
            end
        end
    end
})
-- Moved Range controls here from the Range Settings group
CustomComboSettingsTab:AddSlider("RangeSlider", {
    Text = "Range",
    Min = 1,
    Max = 100,
    Default = RangeCheck.Range,
    Rounding = 0,
    Compact = true,
    Callback = function(value: number)
        RangeCheck.Range = value
        if visualizerMesh then
            visualizerMesh.Scale = Vector3.new(value * 2, 0.2, value * 2)
        else
            visualizerPart.Size = Vector3.new(value * 2, 0.1, value * 2)
        end
    end
})





-- AutoBlock / Block M1s tabbox for cleaner organization
local AutoBlockTabbox = Tabs.Combat:AddRightTabbox()
local AutoBlockTab = AutoBlockTabbox:AddTab("Autoblock")

-- Autoblock master enable removed from UI; use per-group toggles above to enable blocking.
-- Autoblock tab: per-group enable toggles (Abilities / M1s / Dashes)
AutoBlockTab:AddToggle("AutoBlockBlockAbilities", {
    Text = "Block Abilities",
    Default = AutoBlock.BlockAbilities,
    Callback = function(value: boolean)
        AutoBlock.BlockAbilities = value
        UpdateAutoBlockVisualizer()
    end
})
AutoBlockTab:AddToggle("AutoBlockBlockM1s", {
    Text = "Block M1s",
    Default = AutoBlock.BlockM1s,
    Callback = function(value: boolean)
        AutoBlock.BlockM1s = value
        UpdateBlockM1Visualizer()
    end
})
AutoBlockTab:AddToggle("AutoBlockBlockDashes", {
    Text = "Block Dashes",
    Default = AutoBlock.BlockDashes,
    Callback = function(value: boolean)
        AutoBlock.BlockDashes = value
        UpdateDashVisualizer()
    end
})

-- Settings tab: Abilities, M1s and Dash group controls
local SettingsTab = AutoBlockTabbox:AddTab("Settings")
-- Block Abilities controls (moved from Autoblock tab)
-- Abilities controls (enable toggle moved to Autoblock tab)
-- Universal visualizer toggle (applies to all blocking visualizers)

SettingsTab:AddSlider("AutoBlockAbilitiesRange", {
    Text = "Abilities Range",
    Min = 1,
    Max = 100,
    Default = AutoBlock.Range,
    Rounding = 0,
    Compact = true,
    Callback = function(value)
        AutoBlock.Range = value
        UpdateAutoBlockVisualizer()
    end
})
SettingsTab:AddToggle("AutoBlockAbilitiesOnlyTarget", {
    Text = "Ability Block Only For Target",
    Default = AutoBlock.OnlyTarget,
    Callback = function(value)
        AutoBlock.OnlyTarget = value
    end
})
SettingsTab:AddDivider()

-- `AutoBlockMethodSelect` moved further down (below visualizers)

-- Block M1s enable toggle moved to Autoblock tab
SettingsTab:AddSlider("AutoBlockM1RangeSlider", {
    Text = "M1 Range",
    Min = 1,
    Max = 100,
    Default = AutoBlock.BlockM1Range,
    Rounding = 0,
    Compact = true,
    Callback = function(value)
        AutoBlock.BlockM1Range = value
        UpdateBlockM1Visualizer()
    end
})
SettingsTab:AddToggle("AutoBlockM1OnlyTargetToggle", {
    Text = "Block M1 Only For Target",
    Default = AutoBlock.BlockM1OnlyTarget,
    Callback = function(value)
        AutoBlock.BlockM1OnlyTarget = value
    end
})
SettingsTab:AddDivider()

-- Dash group controls
-- Block Dashes enable toggle moved to Autoblock tab
SettingsTab:AddSlider("AutoBlockDashRange", {
    Text = "Dash Range",
    Min = 1,
    Max = 100,
    Default = AutoBlock.DashRange,
    Rounding = 0,
    Compact = true,
    Callback = function(value)
        AutoBlock.DashRange = value
        UpdateDashVisualizer()
    end
})
SettingsTab:AddToggle("AutoBlockDashOnlyTarget", {
    Text = "Block Dashes Only For Target",
    Default = AutoBlock.DashOnlyTarget,
    Callback = function(value)
        AutoBlock.DashOnlyTarget = value
    end
})

SettingsTab:AddDivider()

SettingsTab:AddDropdown("AutoBlockMethodSelect", {
    Text = "Method",
    Values = {"VIM", "REMOTE"},
    Default = (AutoBlock.Method == "REMOTE") and 2 or 1,
    Callback = function(value)
        AutoBlock.Method = value
    end
})

SettingsTab:AddToggle("AutoBlockShowVisualizer", {
    Text = "Show Blocking Visualizers",
    Default = AutoBlock.ShowVisualizer,
    Callback = function(value: boolean)
        AutoBlock.ShowVisualizer = value
        UpdateAutoBlockVisualizer()
        UpdateBlockM1Visualizer()
        UpdateDashVisualizer()
    end
})



local TargetSection = Tabs.Combat:AddLeftGroupbox("Targeting")
TargetSection:AddToggle("TargetToggle", {
    Text = "Enable",
    Default = false,
    Callback = function(value: boolean)
        Target.Enabled = value
    end
})
local TargetKeyLabel = TargetSection:AddLabel("Target Key")
TargetKeyLabel:AddKeyPicker("TargetKeyPicker", {
    Default = "E",
    Mode = "Click",
    Callback = function()
        if Target.Enabled then
            SetTarget()
        end
    end
})

TargetSection:AddButton({
    Text = "Clear Target",
    Func = function()
        Target.CurrentTarget = nil
        Library:Notify("Target cleared")
        TargetLabel:SetText("Current Target: None")
        TargetHPLabel:SetText("HP: N/A")
    end
})
TargetSection:AddDivider()
local TargetLabel = TargetSection:AddLabel("Current Target: None")
local TargetHPLabel = TargetSection:AddLabel("HP: N/A")

-- Player selection dropdown (kept in sync when targets change)
local TargetPlayerDropdown: any
local TargetPlayerMap = {}
local function RefreshTargetPlayerDropdown()
    local vals = {}
    TargetPlayerMap = {}
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= LocalPlayer then
            local s = p.DisplayName .. " (@" .. p.Name .. ")"
            table.insert(vals, s)
            TargetPlayerMap[s] = p
        end
    end
    if TargetPlayerDropdown then
        TargetPlayerDropdown.Values = vals
        if TargetPlayerDropdown.BuildDropdownList then
            pcall(function() TargetPlayerDropdown:BuildDropdownList() end)
        end
    end
end
Players.PlayerAdded:Connect(function() RefreshTargetPlayerDropdown() end)
Players.PlayerRemoving:Connect(function() RefreshTargetPlayerDropdown() end)

TargetPlayerDropdown = TargetSection:AddDropdown("TargetPlayerSelect", {
    Text = "Select Player",
    Values = {},
    Default = nil,
    Callback = function(value: string)
        local pl = TargetPlayerMap[value]
        if not pl or pl == LocalPlayer then return end
        Target.CurrentTarget = pl
        Library:Notify("Targeted: " .. pl.DisplayName)
        TargetLabel:SetText("Current Target: " .. pl.DisplayName .. " (@" .. pl.Name .. ")")
    end
})
RefreshTargetPlayerDropdown()




-- Aimlock groupbox (separate)
local AimlockGroup = Tabs.Combat:AddRightGroupbox("Aimlock")
AimlockGroup:AddToggle("AimlockToggle", {
    Text = "Enable",
    Default = Target.AimlockEnabled,
    Callback = function(value: boolean)
        Target.AimlockEnabled = value
        -- Manage camera lock state when enabling/disabling aimlock
        if Target.AimlockMethod == "CameraLock" then
            if value then
                EnableCameraLock()
            else
                DisableCameraLock()
            end
        end
    end
})
-- Aimlock method selection
AimlockGroup:AddDropdown("AimlockMethodSelect", {
    Text = "Method",
    Values = { "CameraLock" },
    Default = 1,
    Callback = function(value: string)
        Target.AimlockMethod = value
        Library:Notify("Aimlock method: " .. value)
        -- Ensure camera lock state reflects selection
        if value == "CameraLock" and Target.AimlockEnabled then
            EnableCameraLock()
        else
            DisableCameraLock()
        end
    end,
})
-- Target key for aimlock removed: aimlock uses the Targeting system's `CurrentTarget` instead.

-- Range settings moved to Custom Combo Settings tab

-- === TRISESP CONTROLS ===
if getgenv().TrisESP then
    -- Ensure sensible defaults
    getgenv().TrisESP.Settings.HealthBarThickness = getgenv().TrisESP.Settings.HealthBarThickness or 2.5

    local espGroup = Tabs.Visuals:AddLeftGroupbox("ESP (TrisESP)")

    -- Kills / General
    local killsToggle = espGroup:AddToggle("ESPKillsToggle", {
        Text = "Kills ESP",
        Default = PlayerESPConfig.Kills.Enabled,
        Callback = function(v) PlayerESPConfig.Kills.Enabled = v end
    })

    espGroup:AddSlider("ESPMaxDistance", {
        Text = "Max Distance",
        Default = getgenv().TrisESP.Settings.MaxDistance,
        Min = 100,
        Max = 5000,
        Rounding = 0,
        Callback = function(v) getgenv().TrisESP.Settings.MaxDistance = v end
    })

    espGroup:AddDropdown("ESPNameMode", {
        Values = {"Name", "DisplayName"},
        Default = ({Name=1, DisplayName=2})[tostring(getgenv().TrisESP.Settings.NameMode)] or 2,
        Multi = false,
        Text = "Name Mode",
        Callback = function(v) getgenv().TrisESP.Settings.NameMode = v end
    })

    espGroup:AddToggle("ESPTeamCheck", {
        Text = "Team Check",
        Default = getgenv().TrisESP.Settings.TeamCheckEnabled,
        Callback = function(v) getgenv().TrisESP.Settings.TeamCheckEnabled = v end
    })

    -- Boxes (outline toggle + color picker)
    local boxesToggle = espGroup:AddToggle("ESPBoxes", {
        Text = "Show Boxes",
        Default = getgenv().TrisESP.Settings.Boxes,
        Callback = function(v) getgenv().TrisESP.Settings.Boxes = v; boxDep.Holder.Visible = v; boxDep.Visible = v end
    })

    boxesToggle:AddColorPicker("ESPBoxOutlineColor", {
        Title = "Outline Color",
        Default = getgenv().TrisESP.Settings.BoxOutlineColor,
        Callback = function(v) getgenv().TrisESP.Settings.BoxOutlineColor = v end
    })

    -- Box options (dependency box controlled by the Boxes toggle)
    local boxDep = espGroup:AddDependencyBox()
    boxDep:SetupDependencies({{boxesToggle, true}})
    boxDep.Holder.Visible = getgenv().TrisESP.Settings.Boxes or false
    boxDep.Visible = getgenv().TrisESP.Settings.Boxes or false
    boxDep:AddSlider("ESPBoxThickness", { Text = "Outline Thickness", Default = getgenv().TrisESP.Settings.Thickness, Min = 1, Max = 5, Rounding = 0, Callback = function(v) getgenv().TrisESP.Settings.Thickness = v end })

    -- Box fill independent toggle + color pickers (toggle keeps color pickers only)
    local fillToggle = espGroup:AddToggle("ESPBoxFill", {
        Text = "Box Fill",
        Default = getgenv().TrisESP.Settings.BoxFill,
        Callback = function(v) getgenv().TrisESP.Settings.BoxFill = v; fillDep.Holder.Visible = v; fillDep.Visible = v end
    })
    fillToggle:AddColorPicker("ESPBoxFillColor1", { Title = "Fill Color 1", Default = getgenv().TrisESP.Settings.BoxFillCustomColor1, Callback = function(v) getgenv().TrisESP.Settings.BoxFillCustomColor1 = v end })
    fillToggle:AddColorPicker("ESPBoxFillColor2", { Title = "Fill Color 2", Default = getgenv().TrisESP.Settings.BoxFillCustomColor2, Callback = function(v) getgenv().TrisESP.Settings.BoxFillCustomColor2 = v end })
    fillToggle:AddColorPicker("ESPBoxFillColor3", { Title = "Fill Color 3", Default = getgenv().TrisESP.Settings.BoxFillCustomColor3, Callback = function(v) getgenv().TrisESP.Settings.BoxFillCustomColor3 = v end })
    local fillDep = espGroup:AddDependencyBox()
    fillDep:SetupDependencies({{fillToggle, true}})
    fillDep.Holder.Visible = getgenv().TrisESP.Settings.BoxFill or false
    fillDep.Visible = getgenv().TrisESP.Settings.BoxFill or false
    fillDep:AddSlider("ESPBoxFillTransparency", { Text = "Fill Transparency", Default = getgenv().TrisESP.Settings.BoxFillAlpha1 or 0.5, Min = 0, Max = 1, Rounding = 2, Callback = function(v) getgenv().TrisESP.Settings.BoxFillAlpha1 = v; getgenv().TrisESP.Settings.BoxFillAlpha2 = v; getgenv().TrisESP.Settings.BoxFillAlpha3 = v end })
    fillDep:AddToggle("ESPBoxRotation", { Text = "Moving", Default = getgenv().TrisESP.Settings.AnimateBoxRotation, Callback = function(v) getgenv().TrisESP.Settings.AnimateBoxRotation = v end })
    fillDep:AddSlider("ESPBoxRotationSpeed", { Text = "Rotation Speed", Default = getgenv().TrisESP.Settings.BoxRotationSpeed, Min = 10, Max = 500, Rounding = 0, Callback = function(v) getgenv().TrisESP.Settings.BoxRotationSpeed = v end })

    -- Display options (use dependency boxes for nested controls)
    local displayDeps = espGroup:AddDependencyBox()
    displayDeps:SetupDependencies({})
    displayDeps:AddToggle("ESPShowName", { Text = "Show Name", Default = getgenv().TrisESP.Settings.ShowName, Callback = function(v) getgenv().TrisESP.Settings.ShowName = v end })
    displayDeps:AddToggle("ESPShowDistance", { Text = "Show Distance", Default = getgenv().TrisESP.Settings.ShowDistance, Callback = function(v) getgenv().TrisESP.Settings.ShowDistance = v end })
    displayDeps:AddToggle("ESPShowHealthText", { Text = "Show Health Text", Default = getgenv().TrisESP.Settings.ShowHealthText, Callback = function(v) getgenv().TrisESP.Settings.ShowHealthText = v end })

    -- Health bar toggle + dependency box for its options
    local healthToggle = displayDeps:AddToggle("ESPHealthBar", { Text = "Health Bar", Default = getgenv().TrisESP.Settings.HealthBarEnabled, Callback = function(v) getgenv().TrisESP.Settings.HealthBarEnabled = v; healthDep.Holder.Visible = v; healthDep.Visible = v end })
    healthToggle:AddColorPicker("ESPHealthColor1", { Title = "Health Color 1", Default = getgenv().TrisESP.Settings.HealthBarColor1, Callback = function(v) getgenv().TrisESP.Settings.HealthBarColor1 = v end })
    healthToggle:AddColorPicker("ESPHealthColor2", { Title = "Health Color 2", Default = getgenv().TrisESP.Settings.HealthBarColor2, Callback = function(v) getgenv().TrisESP.Settings.HealthBarColor2 = v end })
    healthToggle:AddColorPicker("ESPHealthColor3", { Title = "Health Color 3", Default = getgenv().TrisESP.Settings.HealthBarColor3, Callback = function(v) getgenv().TrisESP.Settings.HealthBarColor3 = v end })
    local healthDep = displayDeps:AddDependencyBox()
    healthDep:SetupDependencies({{healthToggle, true}})
    healthDep.Holder.Visible = getgenv().TrisESP.Settings.HealthBarEnabled or false
    healthDep.Visible = getgenv().TrisESP.Settings.HealthBarEnabled or false
    healthDep:AddDropdown("ESPHealthBarPosition", { Values = {"Left", "Right"}, Default = ({Left=1, Right=2})[getgenv().TrisESP.Settings.HealthBarPosition] or 1, Multi = false, Text = "Health Bar Position", Callback = function(v) getgenv().TrisESP.Settings.HealthBarPosition = v end })
    healthDep:AddToggle("ESPHealthOutlineFollow", { Text = "Health Outline Follow", Default = getgenv().TrisESP.Settings.HealthOutlineFollow, Callback = function(v) getgenv().TrisESP.Settings.HealthOutlineFollow = v end })
    healthDep:AddToggle("ESPHealthGradientAnim", { Text = "Moving", Default = getgenv().TrisESP.Settings.HealthGradientEnabled, Callback = function(v) getgenv().TrisESP.Settings.HealthGradientEnabled = v end })
    healthDep:AddSlider("ESPHealthGradientSpeed", { Text = "Gradient Speed", Default = getgenv().TrisESP.Settings.HealthGradientSpeed, Min = 0.1, Max = 5, Rounding = 1, Callback = function(v) getgenv().TrisESP.Settings.HealthGradientSpeed = v end })
    -- Fixed default thickness enforced in TrisESP
    getgenv().TrisESP.Settings.HealthBarThickness = 2.5

    -- Tracers toggle + dependency box for options
    local tracersToggle = displayDeps:AddToggle("ESPTracers", { Text = "Tracers", Default = getgenv().TrisESP.Settings.Tracers, Callback = function(v) getgenv().TrisESP.Settings.Tracers = v; tracersDep.Holder.Visible = v; tracersDep.Visible = v end })
    tracersToggle:AddColorPicker("ESPTracerColor", { Title = "Tracer Color", Default = getgenv().TrisESP.Settings.TracerColor, Callback = function(v) getgenv().TrisESP.Settings.TracerColor = v end })
    local tracersDep = displayDeps:AddDependencyBox()
    tracersDep:SetupDependencies({{tracersToggle, true}})
    tracersDep.Holder.Visible = getgenv().TrisESP.Settings.Tracers or false
    tracersDep.Visible = getgenv().TrisESP.Settings.Tracers or false
    tracersDep:AddDropdown("ESPTracerFrom", { Values = {"Bottom", "Top", "Center"}, Default = ({Bottom=1, Top=2, Center=3})[getgenv().TrisESP.Settings.TracerFrom] or 1, Multi = false, Text = "Tracer From", Callback = function(v) getgenv().TrisESP.Settings.TracerFrom = v end })

    -- Chams
    local chamsToggle = espGroup:AddToggle("ESPChams", { Text = "Chams", Default = getgenv().TrisESP.Settings.Highlight, Callback = function(v) getgenv().TrisESP.Settings.Highlight = v; chamsDep.Holder.Visible = v; chamsDep.Visible = v end })
    chamsToggle:AddColorPicker("ESPChamColor", { Title = "Cham Color", Default = getgenv().TrisESP.Settings.GlobalChamColor, Callback = function(v) getgenv().TrisESP.Settings.GlobalChamColor = v end })
    local chamsDep = espGroup:AddDependencyBox()
    chamsDep:SetupDependencies({{chamsToggle, true}})
    chamsDep.Holder.Visible = getgenv().TrisESP.Settings.Highlight or false
    chamsDep.Visible = getgenv().TrisESP.Settings.Highlight or false
    chamsDep:AddSlider("ESPChamFillTransparency", { Text = "Fill Transparency", Default = getgenv().TrisESP.Settings.FillTransparency, Min = 0, Max = 1, Rounding = 2, Callback = function(v) getgenv().TrisESP.Settings.FillTransparency = v end })
    chamsDep:AddSlider("ESPChamOutlineTransparency", { Text = "Outline Transparency", Default = getgenv().TrisESP.Settings.OutlineTransparency, Min = 0, Max = 1, Rounding = 2, Callback = function(v) getgenv().TrisESP.Settings.OutlineTransparency = v end })
else
    Tabs.Visuals:AddLeftGroupbox("ESP"):AddLabel("TrisESP failed to load!")
end

-- HP and orientation update
local updateConnection: RBXScriptConnection?
updateConnection = RunService.RenderStepped:Connect(function()
    if not Target.CurrentTarget then
        TargetHPLabel:SetText("HP: N/A")
    else
        local targetChar = Target.CurrentTarget.Character
        if not targetChar then
            TargetHPLabel:SetText("HP: N/A")
        else
            local hum = targetChar:FindFirstChild("Humanoid") :: Humanoid?
            if hum then
                TargetHPLabel:SetText("HP: " .. math.floor(hum.Health) .. "/" .. hum.MaxHealth)
            else
                TargetHPLabel:SetText("HP: N/A")
            end
        end
    end
    local lpChar = LocalPlayer.Character
    if lpChar and Target.AimlockEnabled and Target.CurrentTarget then
        local targetChar = Target.CurrentTarget.Character
        if targetChar then
            local lpHrp = lpChar:FindFirstChild("HumanoidRootPart") :: BasePart?
            local targetHrp = targetChar:FindFirstChild("HumanoidRootPart") :: BasePart?
            if lpHrp and targetHrp then
                local lpPos = lpHrp.Position
                -- Camera lock: keep camera position but rotate to face the target
                local cam = Camera
                if cam and cam.CFrame then
                    local camPos = cam.CFrame.Position
                    local lookAt = targetHrp.Position
                    pcall(function()
                        cam.CFrame = CFrame.new(camPos, lookAt)
                    end)
                end
            end
        end
    end
    for player, esp in playerESPs do
        if player == LocalPlayer or not player.Character then
            -- remove any custom text we added for this player
            pcall(function()
                if getgenv().TrisESP and esp._lastKillsText then
                    getgenv().TrisESP.RemoveCustomText(player, esp._lastKillsText)
                    esp._lastKillsText = nil
                end
            end)
            continue
        end
        local char = player.Character
        local config = PlayerESPConfig

        -- Quick check: only compute box if Kills ESP is enabled
        if not config.Kills.Enabled then
            -- remove any custom text when Kills ESP disabled
            pcall(function()
                if getgenv().TrisESP and esp._lastKillsText then
                    getgenv().TrisESP.RemoveCustomText(player, esp._lastKillsText)
                    esp._lastKillsText = nil
                end
            end)
            continue
        end

        -- Compute a combined world-space AABB from cached body parts or use bounding box
        local pos2d, size2d
        do
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                -- Use HRP-based bounding box (much faster than scanning all descendants)
                local ok, cf, sz = pcall(function() return char:GetBoundingBox() end)
                if ok and cf and sz then
                    local corners = getCorners(cf, sz * 1.1)
                    pos2d, size2d = get2DBoxFromCorners(corners)
                else
                    pos2d = nil
                    size2d = nil
                end
            else
                pos2d = nil
                size2d = nil
            end
        end
        if not pos2d then
            pcall(function()
                if getgenv().TrisESP and esp._lastKillsText then
                    getgenv().TrisESP.RemoveCustomText(player, esp._lastKillsText)
                    esp._lastKillsText = nil
                end
            end)
            continue
        end

        local killsConfig = config.Kills
        local kills = 0
        -- Cache kills lookup (don't search every frame if player hasn't changed)
        if not wasPlayingAnim[player] then wasPlayingAnim[player] = {} end
        if not wasPlayingAnim[player].killsCache then
            wasPlayingAnim[player].killsCache = 0
            wasPlayingAnim[player].killsCacheTime = 0
        end
        -- Refresh kills every 1 second instead of every frame
        if tick() - wasPlayingAnim[player].killsCacheTime > 1 then
            local leaderstats = player:FindFirstChild("leaderstats")
            if leaderstats then
                local k = leaderstats:FindFirstChild("Kills")
                if k then 
                    wasPlayingAnim[player].killsCache = k.Value
                end
            end
            wasPlayingAnim[player].killsCacheTime = tick()
        else
            kills = wasPlayingAnim[player].killsCache
        end
        local newText = "Kills: " .. kills
        -- approximate text bounds for positioning: width ~= chars * size * 0.6, height = size
        local approxBounds = Vector2.new(string.len(newText) * (killsConfig.Size or 14) * 0.6, killsConfig.Size or 14)
        local textPos = getTextPosition(killsConfig.Position, pos2d, size2d, approxBounds)
        -- update TrisESP custom text only when changed
        if getgenv().TrisESP then
            if esp._lastKillsText ~= newText then
                pcall(function()
                    if esp._lastKillsText then
                        getgenv().TrisESP.RemoveCustomText(player, esp._lastKillsText)
                    end
                    getgenv().TrisESP.AddCustomText(player, newText)
                    esp._lastKillsText = newText
                end)
            end
        end
        -- TrisESP handles visibility for the custom text we added
    end
    local lpChar = LocalPlayer.Character
    if lpChar and (AutoBlock.BlockAbilities or AutoBlock.BlockM1s or AutoBlock.BlockDashes) then
            local lpHrp = lpChar:FindFirstChild("HumanoidRootPart")
            local lpHum = lpChar:FindFirstChild("Humanoid") :: Humanoid?
            if lpHrp then
                local lpPos = lpHrp.Position
                -- Allow the local player's own hit1/hit2 animations (from misc) to extend
                -- the extra-hold timer by 0.5s (this is local-only). Do NOT set
                -- `shouldHold` from local animations; blocking behavior is driven by
                -- other players' animations only.
                if lpHum then
                    for _, track in ipairs(lpHum:GetPlayingAnimationTracks()) do
                        if not track or not track.IsPlaying then continue end
                        local anim = track.Animation
                        if not anim then continue end
                        -- If the local player is playing a ReplicatedStorage misc.hits.block
                        -- animation, extend the extra-hold timer by the configured amount.
                        local aid = tostring(anim.AnimationId)
                        if AutoBlock.RSBlockHitsSet and AutoBlock.RSBlockHitsSet[aid] then
                            _autoBlockExtraHoldUntil = math.max(_autoBlockExtraHoldUntil, tick() + AutoBlock.BlockM1Extra)
                        end
                    end
                end
            local shouldHold = false
            local blockedAnimId, blockedAnimName = nil, nil
            -- compute max range needed for any enabled group to avoid unnecessary checks
            local maxRange = 0
            if AutoBlock.BlockAbilities then maxRange = math.max(maxRange, AutoBlock.Range) end
            if AutoBlock.BlockM1s then maxRange = math.max(maxRange, AutoBlock.BlockM1Range) end
            if AutoBlock.BlockDashes then maxRange = math.max(maxRange, AutoBlock.DashRange) end
            if maxRange == 0 then maxRange = AutoBlock.Range end
            local animationSet = AutoBlock.AbilityAnimationIdsSet or {}
            local rsSet = AutoBlock.RSAnimationsSet or {}
            local hitsSet = AutoBlock.RSHitsSet or {}
            local dashSet = AutoBlock.DashAnimationIdsSet or {}
            local rsBlockHitsSet = AutoBlock.RSBlockHitsSet or {}
            
            -- IMPORTANT: Only check other players' animations. LocalPlayer is skipped.
            for _, p in ipairs(Players:GetPlayers()) do
                if p == LocalPlayer then continue end
                -- if OnlyTarget is enabled, skip anyone who isn't the CurrentTarget
                if AutoBlock.OnlyTarget and Target.CurrentTarget ~= p then
                    continue
                end
                
                local char = p.Character
                if char then
                    local hrp = char:FindFirstChild("HumanoidRootPart")
                    if hrp then
                        local dist = (hrp.Position - lpPos).Magnitude
                        -- First, check if we have an active relevant animation recorded from AnimationPlayed
                        local cached = activePlayerAnims[p]
                        if cached then
                            if cached.isDash and AutoBlock.BlockDashes and dist <= AutoBlock.DashRange then
                                if not AutoBlock.DashOnlyTarget or (Target.CurrentTarget == p) then
                                    shouldHold = true
                                    blockedAnimId = cached.aid
                                    blockedAnimName = cached.name
                                    lastBlockedByPlayer[p] = tick()
                                    break
                                end
                            end
                            if cached.isAbility and AutoBlock.BlockAbilities and dist <= AutoBlock.Range then
                                shouldHold = true
                                blockedAnimId = cached.aid
                                blockedAnimName = cached.name
                                lastBlockedByPlayer[p] = tick()
                                break
                            end
                            if cached.isHit and AutoBlock.BlockM1s and dist <= AutoBlock.BlockM1Range then
                                if (not AutoBlock.BlockM1OnlyTarget) or (Target.CurrentTarget == p) then
                                    blockedAnimId = cached.aid
                                    blockedAnimName = cached.name
                                    lastBlockedByPlayer[p] = tick()
                                    shouldHold = true
                                    break
                                end
                            end
                        end
                        if dist <= maxRange then
                            local hum = char:FindFirstChild("Humanoid") :: Humanoid?
                            if hum then
                                for _, track in ipairs(hum:GetPlayingAnimationTracks()) do
                                    if not track or not track.IsPlaying then continue end
                                    local anim = track.Animation
                                    if not anim then continue end
                                    local aid = tostring(anim.AnimationId)
                                    
                                    -- CRITICAL: RSBlockHitsSet animations are ONLY for local player.
                                    -- Completely skip these for any other player.
                                    if rsBlockHitsSet[aid] then
                                        continue
                                    end
                                    
                                    -- check which group the animation belongs to
                                    local isAbility = animationSet[aid]
                                    local isDash = dashSet[aid]
                                    
                                    -- dash handling
                                    if isDash then
                                        if AutoBlock.BlockDashes and dist <= AutoBlock.DashRange then
                                            if not AutoBlock.DashOnlyTarget or (Target.CurrentTarget == p) then
                                                shouldHold = true
                                                blockedAnimId = aid
                                                blockedAnimName = tostring(anim.Name or "")
                                                lastBlockedByPlayer[p] = tick()
                                                break
                                            end
                                        end
                                    -- ability handling: only explicit ability IDs
                                    elseif isAbility then
                                        if AutoBlock.BlockAbilities and dist <= AutoBlock.Range then
                                            shouldHold = true
                                            blockedAnimId = aid
                                            blockedAnimName = tostring(anim.Name or "")
                                            lastBlockedByPlayer[p] = tick()
                                            break
                                        end
                                    end
                                    
                                    -- M1/hit handling: check hits but skip RSBlockHitsSet (already checked above)
                                    if AutoBlock.BlockM1s and hitsSet[aid] then
                                        if dist <= AutoBlock.BlockM1Range then
                                            if (not AutoBlock.BlockM1OnlyTarget) or (Target.CurrentTarget == p) then
                                                blockedAnimId = aid
                                                blockedAnimName = tostring(anim.Name or "")
                                                lastBlockedByPlayer[p] = tick()
                                                shouldHold = true
                                                break
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                if shouldHold then break end
            end
            local desiredHold = shouldHold or tick() < _autoBlockExtraHoldUntil
            if desiredHold and not _autoBlockCurrentlyHolding then
                AutoBlock_DoHold()
                _autoBlockCurrentlyHolding = true
                -- persist current blocking animation info for later reference
                _autoBlockCurrentAnimId = blockedAnimId
                _autoBlockCurrentAnimName = blockedAnimName
                pcall(function()
                    local msg = "Blocking"
                    if _autoBlockCurrentAnimId then
                        if _autoBlockCurrentAnimName and _autoBlockCurrentAnimName ~= "" then
                            msg = "Blocking: " .. _autoBlockCurrentAnimName .. " (" .. _autoBlockCurrentAnimId .. ")"
                        else
                            msg = "Blocking: " .. _autoBlockCurrentAnimId
                        end
                    end
                    Library:Notify(msg)
                    if DebugNotifications then
                        print("[AutoBlock DEBUG] " .. msg)
                    end
                end)
            elseif (not desiredHold) and _autoBlockCurrentlyHolding then
                AutoBlock_DoRelease()
                _autoBlockCurrentlyHolding = false
                -- clear stored anim info
                _autoBlockCurrentAnimId = nil
                _autoBlockCurrentAnimName = nil
                pcall(function()
                    Library:Notify("Stopped blocking")
                    if DebugNotifications then
                        print("[AutoBlock DEBUG] Stopped blocking")
                    end
                end)
            end
        end
    else
        -- ensure key released if AutoBlock disabled or no character
        if _autoBlockCurrentlyHolding then
            AutoBlock_DoRelease()
            _autoBlockCurrentlyHolding = false
        end
    end
end)

local cancelConnection: RBXScriptConnection?
cancelConnection = UserInputService.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
    if gameProcessed then return end
    -- Keys that should cancel AutoBlock hold when pressed
    local stopKeys = {
        [Enum.KeyCode.One] = true,
        [Enum.KeyCode.Two] = true,
        [Enum.KeyCode.Three] = true,
        [Enum.KeyCode.Four] = true,
        [Enum.KeyCode.Q] = true,
        [Enum.KeyCode.R] = true,
    }

    if stopKeys[input.KeyCode] or input.UserInputType == Enum.UserInputType.MouseButton1 then
        if _autoBlockCurrentlyHolding then
            pcall(AutoBlock_DoRelease)
            _autoBlockCurrentlyHolding = false
            pcall(function() Library:Notify("AutoBlock cancelled by input") end)
        end
    end
end)

------------------------
local player = game.Players.LocalPlayer

local BringPlayerTabbox = Tabs.Rage:AddLeftTabbox()
local BringPlayerTab = BringPlayerTabbox:AddTab("Bring Player")
local SettingsBringTab = BringPlayerTabbox:AddTab("Settings")

local MovementEnabled = false
local speed = 100  -- Default movement speed
local arrivalThreshold = 1  -- Default distance threshold for arrival (changed to 1)
local returnTimeout = 5  -- Default timeout for return movement (in seconds)
local bringMaxAttempt = 10 -- Maximum seconds to attempt reaching target before returning
local ReturnAfterBring = true -- whether to return to original position after bringing
local BringRequireTarget = false -- whether bring requires a target to be in range
local BringTargetRange = 100 -- range to check for target
local BringStopOnTargetDeath = false -- whether to stop bring if target dies

-- Preset animations (no free-form ID)
local PresetAnimations = {
    ["Rapid Punches"] = "rbxassetid://95421145178968",
    ["Crushing Blow"] = "rbxassetid://124901309160375",
    ["Judgement's Reach"] = "rbxassetid://82191642276319",
}
local animationId = PresetAnimations["Crushing Blow"]

-- Saved locations for teleport targets
local SavedLocations = {}    -- map name -> Vector3
local SelectedLocationName = nil
local locationsDropdown = nil
local delayBeforeGoing = 0.2
local saveLocationName = ""

-- Bring movement methods
local BringMethods = { "New Version", "Old Version" }
local SelectedBringMethod = BringMethods[1]

local connection  -- To store the animation connection for disconnection on respawn

-- File-based storage for saved locations (similar to CustomSequences)
local locationsFolder = 'TrisSploit/locations'
local function sanitizeFilename(name)
    return tostring(name):gsub("[\\/:*?\"<>|]", "_")
end

local function SaveLocationToFile(name, pos)
    if not isfolder(locationsFolder) then pcall(makefolder, locationsFolder) end
    local fname = sanitizeFilename(name)
    local content = string.format("{%f,%f,%f}", pos.X, pos.Y, pos.Z)
    pcall(function() writefile(locationsFolder.."/"..fname..".txt", content) end)
end

local function LoadSavedLocations()
    for k in pairs(SavedLocations) do SavedLocations[k] = nil end
    local ok = pcall(function()
        if not isfolder(locationsFolder) then return end
        for _, file in ipairs(listfiles(locationsFolder)) do
            if file:match("%.txt$") then
                local name = file:match("([^/\\]+)%.txt$")
                if name then
                    local content = readfile(file)
                    local loader = loadstring("return " .. content)
                    if loader then
                        local s, tbl = pcall(loader)
                        if s and type(tbl) == "table" and #tbl >= 3 then
                            SavedLocations[name] = Vector3.new(tbl[1], tbl[2], tbl[3])
                        end
                    end
                end
            end
        end
    end)
    return ok
end

-- Movement helper: use a unique name to avoid collisions with any existing moveTo
local function Move_Combat(position, timeout)
    local char = player.Character
    if not char or not position then return end

    local rootPart = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    if not rootPart or not humanoid then return end

    -- If already very close, skip
    if (rootPart.Position - position).Magnitude <= arrivalThreshold then return end

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5, 1e5, 1e5)
    bv.Velocity = Vector3.new(0,0,0)
    bv.Parent = rootPart

    local bg = Instance.new("BodyGyro")
    bg.MaxTorque = Vector3.new(1e5, 1e5, 1e5)
    bg.CFrame = CFrame.new(rootPart.Position, position)
    bg.Parent = rootPart

    humanoid.PlatformStand = true

    local startTime = tick()
    local rs = game:GetService("RunService")
    while rootPart and (rootPart.Position - position).Magnitude > arrivalThreshold do
        if timeout and (tick() - startTime) > timeout then break end
        local dir = (position - rootPart.Position)
        local dirUnit = dir.Magnitude > 0 and dir.Unit or Vector3.new(0,0,0)
        bv.Velocity = dirUnit * speed
        bg.CFrame = CFrame.new(rootPart.Position, position)
        rs.RenderStepped:Wait()
    end

    if bv and bv.Parent then pcall(function() bv:Destroy() end) end
    if bg and bg.Parent then pcall(function() bg:Destroy() end) end
    pcall(function() humanoid.PlatformStand = false end)
end

-- Alternative movement method using PlatformStand + AssemblyLinearVelocity + CFrame rotation
local function Move_PlatformAssemblyLinear(position, timeout)
    local char = player.Character
    if not char or not position then return end
    local rootPart = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    if not rootPart or not humanoid then return end

    humanoid.PlatformStand = true
    local startTime = tick()
    local rs = game:GetService("RunService")
    while rootPart and (rootPart.Position - position).Magnitude > arrivalThreshold do
        if timeout and (tick() - startTime) > timeout then break end
        local dir = (position - rootPart.Position)
        local horizontal = Vector3.new(dir.X, 0, dir.Z)
        -- compute a constant horizontal velocity (no easing)
        local horizSpeed = speed
        local vertSpeed = math.clamp(dir.Y, -speed, speed)
        local vel = Vector3.new(0, vertSpeed, 0)
        if horizontal.Magnitude > 0.001 then
            local horizUnit = horizontal.Unit
            vel = Vector3.new(horizUnit.X * horizSpeed, vertSpeed, horizUnit.Z * horizSpeed)
        end
        -- apply velocity directly for linear movement (no slowdown)
        pcall(function() rootPart.AssemblyLinearVelocity = vel end)
        -- rotate toward target only on yaw (avoid pitch)
        local camDir = Vector3.new((position - rootPart.Position).X, 0, (position - rootPart.Position).Z)
        if camDir.Magnitude > 0.001 then
            pcall(function() rootPart.CFrame = CFrame.new(rootPart.Position, rootPart.Position + camDir.Unit) end)
        end
        rs.RenderStepped:Wait()
    end
    -- stop movement
    pcall(function() rootPart.AssemblyLinearVelocity = Vector3.new(0,0,0) end)
    pcall(function() humanoid.PlatformStand = false end)
end

    -- Dispatcher for bring movement
    local function BringPlayerMoveTo(position, timeout)
        if not position then return end
        if SelectedBringMethod == "New Version" then
            return Move_PlatformAssemblyLinear(position, timeout)
        else
            return Move_Combat(position, timeout)
        end
    end

    -- Ensure follow methods mirror the available bring methods (set after BringMethods defined)
    -- (This will be re-assigned again below once BringMethods is declared.)

-- Dispatcher that calls the selected bring method

-- Function to set up animation detection on a given character
local function setupAnimationDetection(char)
    local humanoid = char:WaitForChild("Humanoid", 10)
    local animator = humanoid:WaitForChild("Animator", 10)
    if not humanoid or not animator then return end  -- Bail if not found

    -- Disconnect previous connection if it exists
    if connection then
        connection:Disconnect()
        connection = nil
    end

    connection = animator.AnimationPlayed:Connect(function(track)
        -- Toggle check
        if not MovementEnabled then return end

        -- Animation ID check (robust string comparison)
        if not track or not track.Animation or tostring(track.Animation.AnimationId) ~= tostring(animationId) then
            return
        end

        -- Target range check if enabled
        if BringRequireTarget then
            if not Target.CurrentTarget then return end
            local targetChar = Target.CurrentTarget.Character
            if not targetChar then return end
            local targetHrp = targetChar:FindFirstChild("HumanoidRootPart")
            local lpHrp = char:FindFirstChild("HumanoidRootPart")
            if not targetHrp or not lpHrp then return end
            local dist = (targetHrp.Position - lpHrp.Position).Magnitude
            if dist > BringTargetRange then return end
        end

        -- Run movement safely and restore fly state afterwards
        task.spawn(function()
            local wasFly = FlyEnabled
            local targetToCheck = BringStopOnTargetDeath and Target.CurrentTarget or nil
            local ok, err = pcall(function()
                local rootPart = char:FindFirstChild("HumanoidRootPart")
                if not rootPart then return end
                local originalPosition = rootPart.Position

                local targetPosition = nil
                if SelectedLocationName then
                    targetPosition = SavedLocations[SelectedLocationName]
                end
                if not targetPosition then
                    if Library and Library.Notify then
                        pcall(function() Library:Notify("No saved location selected for Bring Player") end)
                    end
                    return
                end

                task.wait(delayBeforeGoing)
                
                -- Check if target died before starting (if death check enabled)
                if targetToCheck then
                    local targetChar = targetToCheck.Character
                    if not targetChar then
                        if Library and Library.Notify then
                            pcall(function() Library:Notify("Target died, bring cancelled") end)
                        end
                        return
                    end
                    local targetHum = targetChar:FindFirstChild("Humanoid")
                    if not targetHum or targetHum.Health <= 0 then
                        if Library and Library.Notify then
                            pcall(function() Library:Notify("Target died, bring cancelled") end)
                        end
                        return
                    end
                end
                
                if type(BringPlayerMoveTo) == "function" then
                    -- disable flying when starting a bring
                    pcall(function() StopFly() end)
                    -- attempt to reach target for at most bringMaxAttempt seconds
                    local bringStartTime = tick()
                    BringPlayerMoveTo(targetPosition, bringMaxAttempt)
                    
                    -- Check if target died during bring (if death check enabled)
                    if targetToCheck then
                        local targetChar = targetToCheck.Character
                        if not targetChar or not targetChar:FindFirstChild("Humanoid") or targetChar.Humanoid.Health <= 0 then
                            if Library and Library.Notify then
                                pcall(function() Library:Notify("Target died, stopping bring") end)
                            end
                            return
                        end
                    end
                else
                    if Library and Library.Notify then pcall(function() Library:Notify("BringPlayerMoveTo not available") end) end
                end
                
                task.wait(0.5)
                if ReturnAfterBring then
                    if type(BringPlayerMoveTo) == "function" then
                        BringPlayerMoveTo(originalPosition, returnTimeout)
                        -- clear the captured return location so subsequent uses don't reuse it
                        originalPosition = nil
                    end
                end
            end)

            -- Re-enable fly only if it was enabled before the bring started
            if wasFly then
                pcall(function() StartFly() end)
            end

            if not ok then
                if Library and Library.Notify then
                    pcall(function() Library:Notify("BringPlayer movement error: " .. tostring(err)) end)
                end
            end
        end)
    end)
end

-- Initial setup
if player.Character then
    setupAnimationDetection(player.Character)
end
player.CharacterAdded:Connect(setupAnimationDetection)

-- UI elements
BringPlayerTab:AddToggle("BringPlayerToggle", {
    Text = "Enable",
    Risky = true,
    Default = false,
    Callback = function(Value)
        MovementEnabled = Value
    end
})

local animNames = {}
for name in PresetAnimations do table.insert(animNames, name) end
table.sort(animNames)
BringPlayerTab:AddDropdown("BringAnimationSelect", {
    Text = "Move",
    Values = animNames,
    Default = #animNames > 0 and 1 or nil,
    Callback = function(value)
        animationId = PresetAnimations[value]
    end
})

-- Settings tab configurations
SettingsBringTab:AddSlider("SpeedSlider", {
    Text = "Bring Speed",
    Default = 100,
    Min = 10,
    Compact = true,
    Max = 1000,
    Rounding = 0,
    Callback = function(Value)
        speed = Value
    end
})

SettingsBringTab:AddSlider("ArrivalThresholdSlider", {
    Text = "Arrivial Threshold",
    Default = 1,
    Min = 0.01,
    Compact = true,
    Max = 5,
    Rounding = 2,
    Callback = function(Value)
        arrivalThreshold = Value
    end
})

SettingsBringTab:AddSlider("ReturnTimeoutSlider", {
    Text = "Max Return Time (S)",
    Default = 5,
    Min = 1,
    Compact = true,
    Max = 30,
    Rounding = 0,
    Callback = function(Value)
        returnTimeout = Value
    end
})

SettingsBringTab:AddSlider("BringMaxAttemptSlider", {
    Text = "Max Bring Time (S)",
    Default = bringMaxAttempt,
    Min = 1,
    Max = 10,
    Compact = true,
    Rounding = 0,
    Callback = function(Value)
        bringMaxAttempt = Value
    end
})

SettingsBringTab:AddSlider("BringDelaySlider", {
    Text = "Start Delay (S)",
    Min = 0.01,
    Max = 2,
    Default = delayBeforeGoing,
    Rounding = 2,
    Compact = true,
    Callback = function(Value)
        delayBeforeGoing = Value
    end
})

SettingsBringTab:AddDropdown("BringMethodSelect", {
    Text = "Bring Method",
    Values = BringMethods,
    Default = 1,
    Callback = function(value)
        SelectedBringMethod = value
    end
})

SettingsBringTab:AddToggle("ReturnAfterBringToggle", {
    Text = "Return to Original Position",
    Default = ReturnAfterBring,
    Callback = function(Value)
        ReturnAfterBring = Value
    end
})

SettingsBringTab:AddDivider()

SettingsBringTab:AddToggle("BringRequireTargetToggle", {
    Text = "Require Target in Range",
    Default = BringRequireTarget,
    Callback = function(Value)
        BringRequireTarget = Value
        UpdateBringVisualizer()
    end
})



SettingsBringTab:AddToggle("BringShowVisualizerToggle", {
    Text = "Show Range Visualizer",
    Default = false,
    Callback = function(Value)
        if Value then
            UpdateBringVisualizer()
        else
            if bringVisualizerPart then bringVisualizerPart.Parent = nil end
            if bringVisualizerConnection then bringVisualizerConnection:Disconnect() end
        end
    end
})


SettingsBringTab:AddToggle("BringStopOnTargetDeathToggle", {
    Text = "Stop if Target Dies",
    Default = BringStopOnTargetDeath,
    Callback = function(Value)
        BringStopOnTargetDeath = Value
    end
})

SettingsBringTab:AddSlider("BringTargetRangeSlider", {
    Text = "Target Range (studs)",
    Default = BringTargetRange,
    Min = 10,
    Max = 500,
    Compact = true,
    Rounding = 0,
    Callback = function(Value)
        BringTargetRange = Value
        UpdateBringVisualizer()
    end
})
-- Locations dropdown and save button
locationsDropdown = SettingsBringTab:AddDropdown("BringLocationSelect", {
    Text = "Location",
    Values = {},
    Default = nil,
    Callback = function(value)
        SelectedLocationName = value
    end
})

local function UpdateLocationsDropdown()
    local names = {}
    for name in pairs(SavedLocations) do table.insert(names, name) end
    table.sort(names)
    locationsDropdown.Values = names
    if locationsDropdown then
        if locationsDropdown.BuildDropdownList then
            pcall(function() locationsDropdown:BuildDropdownList() end)
        end
        if #names > 0 then
            if locationsDropdown.SetValue then
                pcall(function() locationsDropdown:SetValue(names[1]) end)
            end
            SelectedLocationName = names[1]
        else
            if locationsDropdown.SetValue then pcall(function() locationsDropdown:SetValue(nil) end) end
            SelectedLocationName = nil
        end
    else
        SelectedLocationName = #names > 0 and names[1] or nil
    end
end
-- Input for save name
SettingsBringTab:AddInput("SaveLocationNameInput", {
    Text = "Save Name",
    Default = "",
    Callback = function(Value)
        saveLocationName = tostring(Value or "")
    end
})
SettingsBringTab:AddButton({
    Text = "Save Current Location",
    Func = function()
        local char = player.Character
        if not char then if Library and Library.Notify then pcall(function() Library:Notify("No character to save location from") end) end; return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then if Library and Library.Notify then pcall(function() Library:Notify("No HumanoidRootPart to save") end) end; return end
        local name = tostring(saveLocationName or "")
        if name == "" then if Library and Library.Notify then pcall(function() Library:Notify("Provide a name in the 'Save Name' input before saving") end) end; return end
        if SavedLocations[name] then if Library and Library.Notify then pcall(function() Library:Notify("A saved location with that name already exists") end) end; return end
        SavedLocations[name] = hrp.Position
        -- persist to disk like custom combos
        pcall(function() SaveLocationToFile(name, hrp.Position) end)
        LoadSavedLocations()
        UpdateLocationsDropdown()
        if locationsDropdown and locationsDropdown.SetValue then pcall(function() locationsDropdown:SetValue(name) end) end
        SelectedLocationName = name
        if Library and Library.Notify then pcall(function() Library:Notify("Saved location: " .. name) end) end
    end
})



-- Initialize locations dropdown on load
LoadSavedLocations()
UpdateLocationsDropdown()

-- (Previously provided rename UI removed; saving now uses the 'Save Name' input.)
------------------------

-- Setup SaveManager and ThemeManager
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetFolder('TrisSploit/jujutsu-shenanigans')
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:SetLibrary(Library)
ThemeManager:SetFolder('TrisSploit/themes')
ThemeManager:ApplyToTab(Tabs.Settings)

local Debugnigger = Tabs.Settings:AddRightGroupbox("Debug Notifications")

-- Add debug notifications toggle to Settings tab
Debugnigger:AddToggle("DebugNotificationsToggle", {
    Text = "Debug Notifications",
    Default = DebugNotifications,
    Callback = function(Value)
        DebugNotifications = Value
    end
})

SaveManager:LoadAutoloadConfig()

-- Status Labels settings: allow user to provide a GitHub raw URL to populate the Status box
-- Status labels are loaded from a pre-configured GitHub raw URL.
-- Replace the URL below with your repository's raw file URL (JSON array or Lua table returning labels).
-- Status labels removed; no auto-load or UI for status labels.

-- Initialize
AntiDebuff.StartListener()
if RangeCheck.ShowVisualizer then
    UpdateVisualizer()
end
if AutoBlock.ShowVisualizer then
    UpdateAutoBlockVisualizer()
end
if AutoBlock.BlockM1s then
    UpdateBlockM1Visualizer()
end
if AutoBlock.BlockDashes then
    UpdateDashVisualizer()
end

